<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Yezzi Tech</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Nice paper collection, computer tech records, and personal thoughts">
<meta property="og:type" content="website">
<meta property="og:title" content="Yezzi Tech">
<meta property="og:url" content="https://yezzi.tech/page/2/index.html">
<meta property="og:site_name" content="Yezzi Tech">
<meta property="og:description" content="Nice paper collection, computer tech records, and personal thoughts">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Mingzhe Liu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Yezzi Tech" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="/css/styles.css">

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">Yezzi Tech</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-以太坊交易池" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%B1%A0/">(no title)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%B1%A0/" class="article-date"><time datetime="2021-07-02T11:06:38.794Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a>交易池</h4><p>txpool主要用来存放当前提交的等待写入区块的交易，有远端的和本地的。</p>
<p>交易池包含所有已知的交易。交易被本地提交或从网络接收时进入交易池，交易在被区块链收纳后退出交易池。</p>
<p>交易池把交易分成两种：可处理交易:pending，已加入交易池但不可以执行:queue。交易在被接收和处理的过程中在两种状态之间转换。</p>
<p><img src="./picture/9.png"></p>
<h4 id="设置信息"><a href="#设置信息" class="headerlink" title="设置信息"></a>设置信息</h4><h6 id="交易池-1"><a href="#交易池-1" class="headerlink" title="交易池"></a>交易池</h6><p>交易池的主要内容有：区块链（主要实现了当前和从前的区块索引，和根据之前一个状态树的树根实现之前某处的stateDB的索引）、状态树StateDB，交易列表、queue交易和pending状态的交易、本地账户列表、本地交易存储</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	config      TxPoolConfig</span><br><span class="line">	chainconfig *params.ChainConfig</span><br><span class="line">	chain       blockChain</span><br><span class="line">	gasPrice    *big.Int</span><br><span class="line">	txFeed      event.Feed</span><br><span class="line">	scope       event.SubscriptionScope</span><br><span class="line">	signer      types.Signer</span><br><span class="line">	mu          sync.RWMutex</span><br><span class="line"></span><br><span class="line">	istanbul <span class="keyword">bool</span> <span class="comment">// Fork indicator whether we are in the istanbul stage.</span></span><br><span class="line"></span><br><span class="line">	currentState  *state.StateDB <span class="comment">// Current state in the blockchain head</span></span><br><span class="line">	pendingNonces *txNoncer      <span class="comment">// Pending state tracking virtual nonces</span></span><br><span class="line">	currentMaxGas <span class="keyword">uint64</span>         <span class="comment">// Current gas limit for transaction caps</span></span><br><span class="line"></span><br><span class="line">	locals  *accountSet <span class="comment">// Set of local transaction to exempt from eviction rules</span></span><br><span class="line">	journal *txJournal  <span class="comment">// Journal of local transaction to back up to disk</span></span><br><span class="line"></span><br><span class="line">	pending <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// All currently processable transactions</span></span><br><span class="line">	queue   <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// Queued but non-processable transactions</span></span><br><span class="line">	beats   <span class="keyword">map</span>[common.Address]time.Time <span class="comment">// Last heartbeat from each known account</span></span><br><span class="line">	all     *txLookup                    <span class="comment">// All transactions to allow lookups</span></span><br><span class="line">	priced  *txPricedList                <span class="comment">// All transactions sorted by price</span></span><br><span class="line"></span><br><span class="line">	chainHeadCh     <span class="keyword">chan</span> ChainHeadEvent</span><br><span class="line">	chainHeadSub    event.Subscription</span><br><span class="line">	reqResetCh      <span class="keyword">chan</span> *txpoolResetRequest</span><br><span class="line">	reqPromoteCh    <span class="keyword">chan</span> *accountSet</span><br><span class="line">	queueTxEventCh  <span class="keyword">chan</span> *types.Transaction</span><br><span class="line">	reorgDoneCh     <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	reorgShutdownCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">// requests shutdown of scheduleReorgLoop</span></span><br><span class="line">	wg              sync.WaitGroup <span class="comment">// tracks loop, scheduleReorgLoop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>config：配置文件</li>
<li>gasPrice：最低的gasprice限制</li>
<li>txFeed：通过txFeed来订阅txPool的消息</li>
<li>chainHeadCh：订阅了区块头的信息，当新的区块头生成时这里会收到通知</li>
<li>chainHeadSub：区块头消息的订阅器</li>
<li>signer：封装了事务签名处理</li>
<li>currentMaxGas：目前交易的上限GasLimit</li>
<li>locals：本地交易免除驱逐规则</li>
<li>journal：本地交易会写入磁盘</li>
<li>pending：正在处理的交易列表</li>
<li>queue：等待处理的交易列表</li>
<li>beats：每一个一直账号的最后一次心跳信息时间，用map存储</li>
<li>all：可以查找到所有交易</li>
<li>priced：按照价格排序的交易</li>
</ul>
<h6 id="交易池配置"><a href="#交易池配置" class="headerlink" title="交易池配置"></a>交易池配置</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TxPoolConfig are the configuration parameters of the transaction pool.</span></span><br><span class="line"><span class="keyword">type</span> TxPoolConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	Locals    []common.Address <span class="comment">// Addresses that should be treated by default as local</span></span><br><span class="line">	NoLocals  <span class="keyword">bool</span>             <span class="comment">// Whether local transaction handling should be disabled</span></span><br><span class="line">	Journal   <span class="keyword">string</span>           <span class="comment">// Journal of local transactions to survive node restarts</span></span><br><span class="line">	Rejournal time.Duration    <span class="comment">// Time interval to regenerate the local transaction journal</span></span><br><span class="line"></span><br><span class="line">	PriceLimit <span class="keyword">uint64</span> <span class="comment">// Minimum gas price to enforce for acceptance into the pool</span></span><br><span class="line">	PriceBump  <span class="keyword">uint64</span> <span class="comment">// Minimum price bump percentage to replace an already existing transaction (nonce)</span></span><br><span class="line"></span><br><span class="line">	AccountSlots <span class="keyword">uint64</span> <span class="comment">// Number of executable transaction slots guaranteed per account</span></span><br><span class="line">	GlobalSlots  <span class="keyword">uint64</span> <span class="comment">// Maximum number of executable transaction slots for all accounts</span></span><br><span class="line">	AccountQueue <span class="keyword">uint64</span> <span class="comment">// Maximum number of non-executable transaction slots permitted per account</span></span><br><span class="line">	GlobalQueue  <span class="keyword">uint64</span> <span class="comment">// Maximum number of non-executable transaction slots for all accounts</span></span><br><span class="line"></span><br><span class="line">	Lifetime time.Duration <span class="comment">// Maximum amount of time non-executable transaction are queued</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Locals: 定义了一组视为local交易的账户地址。任何来自此清单的交易均被视为 local 交易。</li>
<li>NoLocals: 是否禁止local交易处理。默认为 fasle,允许 local 交易。如果禁止，则来自 local 的交易均视为 remote 交易处理。</li>
<li>Journal： 存储local交易记录的文件名，默认是 <code>./transactions.rlp</code>。</li>
<li>Rejournal：定期将local交易存储文件中的时间间隔。默认为每小时一次。</li>
<li>PriceLimit： remote交易进入交易池的最低 Price 要求。此设置对 local 交易无效。默认值1。</li>
<li>PriceBump：替换交易时所要求的价格上调涨幅比例最低要求。任何低于要求的替换交易均被拒绝。</li>
<li>AccountSlots： 当交易池中可执行交易（是已在等待矿工打包的交易）量超标时，允许每个账户可以保留在交易池最低交易数。默认值是 16 笔。</li>
<li>GlobalSlots： 交易池中所允许的可执行交易量上限，高于上限时将释放部分交易。默认是 4096 笔交易。</li>
<li>AccountQueue：交易池中单个账户非可执行交易上限，默认是64笔。</li>
<li>GlobalQueue： 交易池中所有非可执行交易上限，默认1024 笔。</li>
<li>Lifetime： 允许 remote 的非可执行交易可在交易池存活的最长时间。交易池每分钟检查一次，一旦发现有超期的remote 账户，则移除该账户下的所有非可执行交易。默认为3小时。 </li>
</ul>
<h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><p>开启交易池后，以太坊开启一个goroutine执行loop函数用来监听主要事件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">loop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ev := &lt;-pool.chainHeadCh</span><br><span class="line">    <span class="keyword">case</span> &lt;-pool.chainHeadSub.Err()</span><br><span class="line">    <span class="keyword">case</span> &lt;-report.C</span><br><span class="line">    <span class="keyword">case</span> &lt;-evict.C</span><br><span class="line">    <span class="keyword">case</span> &lt;-journal.C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同时开启一个goroutine来调度reset和promoteExecutables事件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//requestPromoteExecutables requests a pool reset to the new head block.</span></span><br><span class="line"><span class="comment">//The returned channel is closed when the reset has occurred.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">requestReset</span><span class="params">(oldHead *types.Header, newHead *types.Header)</span> <span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> pool.reqResetCh &lt;- &amp;txpoolResetRequest&#123;oldHead, newHead&#125;:</span><br><span class="line">		<span class="keyword">return</span> &lt;-pool.reorgDoneCh</span><br><span class="line">	<span class="keyword">case</span> &lt;-pool.reorgShutdownCh:</span><br><span class="line">		<span class="keyword">return</span> pool.reorgShutdownCh</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//requestPromoteExecutables requests transaction promotion checks for the given addresses.</span></span><br><span class="line"><span class="comment">//The returned channel is closed when the promotion checks have occurred.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">requestPromoteExecutables</span><span class="params">(set *accountSet)</span> <span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> pool.reqPromoteCh &lt;- set:</span><br><span class="line">		<span class="keyword">return</span> &lt;-pool.reorgDoneCh</span><br><span class="line">	<span class="keyword">case</span> &lt;-pool.reorgShutdownCh:</span><br><span class="line">		<span class="keyword">return</span> pool.reorgShutdownCh</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (pool *TxPool) scheduleReorgLoop() &#123;</span><br><span class="line">case req := &lt;-pool.reqResetCh</span><br><span class="line">case req := &lt;-pool.reqPromoteCh</span><br><span class="line">case tx := &lt;-pool.queueTxEventCh</span><br><span class="line">case &lt;-curDone</span><br><span class="line">case &lt;-pool.reorgShutdownCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本地交易处理"><a href="#本地交易处理" class="headerlink" title="本地交易处理"></a>本地交易处理</h4><p>为了不丢失未完成的本地交易，以太坊交易池通过 journal 文件存储和管理当前交易池中的本地交易，并定期更新存储。</p>
<p>启动交易池时根据配置开启本地交易存储</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If local transactions and journaling is enabled, load from disk</span></span><br><span class="line"><span class="keyword">if</span> !config.NoLocals &amp;&amp; config.Journal != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">	pool.journal = newTxJournal(config.Journal)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := pool.journal.load(pool.AddLocals); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Failed to load transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := pool.journal.rotate(pool.local()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Failed to rotate transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在新的local 交易进入交易池时，将被实时写入 journal 文件。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">journalTx</span><span class="params">(from common.Address, tx *types.Transaction)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Only journal if it&#x27;s enabled and the transaction is local</span></span><br><span class="line">	<span class="keyword">if</span> pool.journal == <span class="literal">nil</span> || !pool.locals.contains(from) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := pool.journal.insert(tx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Failed to journal local transaction&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 定期对 journal 文件执行 <code>rotate</code>，将交易池中的本地交易写入journal文件，并丢弃旧数据。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-journal.C:</span><br><span class="line">			<span class="keyword">if</span> pool.journal != <span class="literal">nil</span> &#123;</span><br><span class="line">				pool.mu.Lock()</span><br><span class="line">				<span class="keyword">if</span> err := pool.journal.rotate(pool.local()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Warn(<span class="string">&quot;Failed to rotate local tx journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">				&#125;</span><br><span class="line">				pool.mu.Unlock()</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p> 在交易池首次启动 journal 时，将主动将该文件已存储的交易加载到交易池。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(journal *txJournal)</span> <span class="title">load</span><span class="params">(add <span class="keyword">func</span>([]*types.Transaction)</span> []<span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Skip the parsing if the journal file doesn&#x27;t exist at all</span></span><br><span class="line">	<span class="keyword">if</span> _, err := os.Stat(journal.path); os.IsNotExist(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Open the journal for loading any past transactions</span></span><br><span class="line">	input, err := os.Open(journal.path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> input.Close()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="交易进池"><a href="#交易进池" class="headerlink" title="交易进池"></a>交易进池</h4><p>交易增加add函数</p>
<p>func (pool *TxPool) add(tx *types.Transaction, local bool) (replaced bool, err error)</p>
<p>由一下几个部分组成：</p>
<p>先检查交易是否已经在交易池，如果是，则抛弃</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash := tx.Hash()</span><br><span class="line">	<span class="keyword">if</span> pool.all.Get(hash) != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Trace(<span class="string">&quot;Discarding already known transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		knownTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, ErrAlreadyKnown</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>验证交易有效性（在之后会解析这个函数）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := pool.validateTx(tx, local); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Trace(<span class="string">&quot;Discarding invalid transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	invalidTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看交易池是否已经满，如果满了，则抛弃价格低且非本地的交易。主要调用removeTx函数进行删除交易操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">uint64</span>(pool.all.Count()) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue &#123;</span><br><span class="line">	<span class="comment">// If the new transaction is underpriced, don&#x27;t accept it</span></span><br><span class="line">	<span class="keyword">if</span> !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) &#123;</span><br><span class="line">		log.Trace(<span class="string">&quot;Discarding underpriced transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;price&quot;</span>, tx.GasPrice())</span><br><span class="line">		underpricedTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, ErrUnderpriced</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// New transaction is better than our worse ones, make room for it</span></span><br><span class="line">	drop := pool.priced.Discard(pool.all.Slots()-<span class="keyword">int</span>(pool.config.GlobalSlots+pool.config.GlobalQueue)+numSlots(tx), pool.locals)</span><br><span class="line">	<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drop &#123;</span><br><span class="line">		log.Trace(<span class="string">&quot;Discarding freshly underpriced transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, tx.Hash(), <span class="string">&quot;price&quot;</span>, tx.GasPrice())</span><br><span class="line">		underpricedTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		pool.removeTx(tx.Hash(), <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果关联到该账户的可执行队列中存在一个相同 nonce 的交易时，需要进一步识别是否能替换。</p>
<p>以太坊早起的默认设计是，只要价格(gasPrice)高于原交易，则允许替换。但是17年7月底在 <a target="_blank" rel="noopener" href="https://github.com/ethereum/go-ethereum/pull/15401">#15401</a>被改进。人们愿意支付更多手续费的原因有两种情况，一是急于处理交易，但如果真是紧急交易，那么在发送交易之处，会使用高于推荐的gasprice来处理交易。另一种情况时，以太坊价格下跌，人们愿意支付更多手续费。上调多少手续费是合理的呢？以太币下跌10%，那么便可以上调10%的手续费，毕竟对于用户来说，手续费的面值是一样的。交易池的默认配置（pool.config.PriceBump）是10%，只有上调10%手续费的交易才允许替换掉已在等待执行的交易。一旦可以替换，则替换掉旧交易，移除旧交易，并将交易同步存储到 all 交易内存池中。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from, _ := types.Sender(pool.signer, tx) <span class="comment">// already validated</span></span><br><span class="line"><span class="keyword">if</span> list := pool.pending[from]; list != <span class="literal">nil</span> &amp;&amp; list.Overlaps(tx) &#123;</span><br><span class="line">	<span class="comment">// Nonce already pending, check if required price bump is met</span></span><br><span class="line">	inserted, old := list.Add(tx, pool.config.PriceBump)</span><br><span class="line">	<span class="keyword">if</span> !inserted &#123;</span><br><span class="line">		pendingDiscardMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, ErrReplaceUnderpriced</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// New transaction is better, replace old one</span></span><br><span class="line">	<span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</span><br><span class="line">		pool.all.Remove(old.Hash())</span><br><span class="line">		pool.priced.Removed(<span class="number">1</span>)</span><br><span class="line">		pendingReplaceMeter.Mark(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	pool.all.Add(tx)</span><br><span class="line">	pool.priced.Put(tx)</span><br><span class="line">	pool.journalTx(from, tx)</span><br><span class="line">	pool.queueTxEvent(tx)</span><br><span class="line">	log.Trace(<span class="string">&quot;Pooled new executable transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;from&quot;</span>, from, <span class="string">&quot;to&quot;</span>, tx.To())</span><br><span class="line">	<span class="keyword">return</span> old != <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该交易不需要替代可执行交易，则放入不可执行交易中。在进入非可执行队列之前，也要检查是否需要替换掉相同 nonce 的交易(enqueueTx)。 ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New transaction isn&#x27;t replacing a pending one, push into queue</span></span><br><span class="line">replaced, err = pool.enqueueTx(hash, tx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对交易检查是否为本地交易。如果是本地交易，则先检查本地账户列表是否有交易from的地址，如没有则添加。之后把交易加入本地交易列表中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark local addresses and journal local transactions</span></span><br><span class="line"><span class="keyword">if</span> local &#123;</span><br><span class="line">	<span class="keyword">if</span> !pool.locals.contains(from) &#123;</span><br><span class="line">		log.Info(<span class="string">&quot;Setting new local account&quot;</span>, <span class="string">&quot;address&quot;</span>, from)</span><br><span class="line">		pool.locals.add(from)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> local || pool.locals.contains(from) &#123;</span><br><span class="line">	localGauge.Inc(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">pool.journalTx(from, tx)</span><br></pre></td></tr></table></figure>

<h4 id="交易有效性检验"><a href="#交易有效性检验" class="headerlink" title="交易有效性检验"></a>交易有效性检验</h4><p>func (pool *TxPool) validateTx(tx *types.Transaction, local bool)解释如下：</p>
<p>首先检查交易大小不能过大</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">uint64</span>(tx.Size()) &gt; txMaxSize &#123;</span><br><span class="line">	<span class="keyword">return</span> ErrOversizedData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交易的金额不能为负数：理论上因为交易经过RLP编码不能处理负数，但如通过RPC直接发送交易则有这种错误的可能性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tx.Value().Sign() &lt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ErrNegativeValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交易的GAS费用不能超过区块的gas上限</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pool.currentMaxGas &lt; tx.Gas() &#123;   <span class="keyword">return</span> ErrGasLimit&#125;</span><br></pre></td></tr></table></figure>

<p>观察能否解析签名信息 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from, err := types.Sender(pool.signer, tx)<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;   <span class="keyword">return</span> ErrInvalidSender&#125;</span><br></pre></td></tr></table></figure>

<p>本地交易是否低于了最低gas费用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local = local || pool.locals.contains(from) <span class="comment">// account may be local even if the transaction arrived from the network</span></span><br><span class="line"><span class="keyword">if</span> !local &amp;&amp; pool.gasPrice.Cmp(tx.GasPrice()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ErrUnderpriced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查nonce值是否高于交易者的nonce值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pool.currentState.GetNonce(from) &gt; tx.Nonce() &#123;   <span class="keyword">return</span> ErrNonceTooLow&#125;</span><br></pre></td></tr></table></figure>

<p>检查交易者剩余钱够不够交易的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pool.currentState.GetBalance(from).Cmp(tx.Cost()) &lt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ErrInsufficientFunds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查交易设置的gas费用不能少于预估的最小费用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intrGas, err := IntrinsicGas(tx.Data(), tx.To() == <span class="literal">nil</span>, pool.homestead)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> tx.Gas() &lt; intrGas &#123;</span><br><span class="line">   <span class="keyword">return</span> ErrIntrinsicGas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="交易池更新"><a href="#交易池更新" class="headerlink" title="交易池更新"></a>交易池更新</h4><p>每当收到交易池更新信号的时候都会开启一个goroutine执行下runReorg函数，具体可分为交易池重置，交易池升级，交易池降级三个步骤。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">runReorg</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, reset *txpoolResetRequest, dirtyAccounts *accountSet, events <span class="keyword">map</span>[common.Address]*txSortedMap)</span></span></span><br></pre></td></tr></table></figure>

<h6 id="交易池重置"><a href="#交易池重置" class="headerlink" title="交易池重置"></a><strong>交易池重置</strong></h6><p>什么时候要执行交易池重置操作呢？分别是 创建交易池：NewTxPool；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTxPool</span><span class="params">(config TxPoolConfig, chainconfig *params.ChainConfig, chain blockChain)</span> *<span class="title">TxPool</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">pool.reset(<span class="literal">nil</span>, chain.CurrentBlock().Header())</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收到信号时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Launch next background reorg if needed</span></span><br><span class="line">		<span class="keyword">if</span> curDone == <span class="literal">nil</span> &amp;&amp; launchNextRun &#123;</span><br><span class="line">			<span class="comment">// Run the background reorg and announcements</span></span><br><span class="line">            <span class="comment">// 在这里执行的reset操作，执行完操作后把reset又重新建了一个，以便接受下次信号并执行相关操作</span></span><br><span class="line">			<span class="keyword">go</span> pool.runReorg(nextDone, reset, dirtyAccounts, queuedEvents)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare everything for the next round of reorg</span></span><br><span class="line">			curDone, nextDone = nextDone, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			launchNextRun = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">			reset, dirtyAccounts = <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">			queuedEvents = <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]*txSortedMap)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> req := &lt;-pool.reqResetCh:</span><br><span class="line">			<span class="comment">// Reset request: update head if request is already pending.</span></span><br><span class="line">			<span class="keyword">if</span> reset == <span class="literal">nil</span> &#123;</span><br><span class="line">				reset = req</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				reset.newHead = req.newHead</span><br><span class="line">			&#125;</span><br><span class="line">			launchNextRun = <span class="literal">true</span></span><br><span class="line">			pool.reorgDoneCh &lt;- nextDone</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-curDone:</span><br><span class="line">			curDone = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>func (pool *TxPool) reset(oldHead, newHead *types.Header)解释如下：</p>
<p>找到由于规范链更新而作废的交易：新区快头的父区块不等于老区块，说明新老区块不在同一条链。如果新头区块和旧头区块相差大于64，则所有交易不必回退到交易池。如果旧链的头区块大于新链的头区块高度，旧链向后退并回收所有回退的交易。如果新链的头区块大于旧链的头区块，新链后退并回收交易。当新旧链到达同一高度的时候同时回退，知道找到共同的父节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> oldHead != <span class="literal">nil</span> &amp;&amp; oldHead.Hash() != newHead.ParentHash &#123;</span><br><span class="line">	<span class="comment">// If the reorg is too deep, avoid doing it (will happen during fast sync)</span></span><br><span class="line">	oldNum := oldHead.Number.Uint64()</span><br><span class="line">	newNum := newHead.Number.Uint64()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> depth := <span class="keyword">uint64</span>(math.Abs(<span class="keyword">float64</span>(oldNum) - <span class="keyword">float64</span>(newNum))); depth &gt; <span class="number">64</span> &#123;</span><br><span class="line">		log.Debug(<span class="string">&quot;Skipping deep transaction reorg&quot;</span>, <span class="string">&quot;depth&quot;</span>, depth)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Reorg seems shallow enough to pull in all transactions into memory</span></span><br><span class="line">		<span class="keyword">var</span> discarded, included types.Transactions</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			rem = pool.chain.GetBlock(oldHead.Hash(), oldHead.Number.Uint64())</span><br><span class="line">			add = pool.chain.GetBlock(newHead.Hash(), newHead.Number.Uint64())</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> rem == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// This can happen if a setHead is performed, where we simply discard the old</span></span><br><span class="line">			<span class="comment">// head from the chain.</span></span><br><span class="line">			<span class="comment">// If that is the case, we don&#x27;t have the lost transactions any more, and</span></span><br><span class="line">			<span class="comment">// there&#x27;s nothing to add</span></span><br><span class="line">			<span class="keyword">if</span> newNum &lt; oldNum &#123;</span><br><span class="line">				<span class="comment">// If the reorg ended up on a lower number, it&#x27;s indicative of setHead being the cause</span></span><br><span class="line">				log.Debug(<span class="string">&quot;Skipping transaction reset caused by setHead&quot;</span>,</span><br><span class="line">					<span class="string">&quot;old&quot;</span>, oldHead.Hash(), <span class="string">&quot;oldnum&quot;</span>, oldNum, <span class="string">&quot;new&quot;</span>, newHead.Hash(), <span class="string">&quot;newnum&quot;</span>, newNum)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// If we reorged to a same or higher number, then it&#x27;s not a case of setHead</span></span><br><span class="line">				log.Warn(<span class="string">&quot;Transaction pool reset with missing oldhead&quot;</span>,</span><br><span class="line">					<span class="string">&quot;old&quot;</span>, oldHead.Hash(), <span class="string">&quot;oldnum&quot;</span>, oldNum, <span class="string">&quot;new&quot;</span>, newHead.Hash(), <span class="string">&quot;newnum&quot;</span>, newNum)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> rem.NumberU64() &gt; add.NumberU64() &#123;</span><br><span class="line">			discarded = <span class="built_in">append</span>(discarded, rem.Transactions()...)</span><br><span class="line">			<span class="keyword">if</span> rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()<span class="number">-1</span>); rem == <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Unrooted old chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, oldHead.Number, <span class="string">&quot;hash&quot;</span>, oldHead.Hash())</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> add.NumberU64() &gt; rem.NumberU64() &#123;</span><br><span class="line">			included = <span class="built_in">append</span>(included, add.Transactions()...)</span><br><span class="line">			<span class="keyword">if</span> add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()<span class="number">-1</span>); add == <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Unrooted new chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, newHead.Number, <span class="string">&quot;hash&quot;</span>, newHead.Hash())</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> rem.Hash() != add.Hash() &#123;</span><br><span class="line">			discarded = <span class="built_in">append</span>(discarded, rem.Transactions()...)</span><br><span class="line">			<span class="keyword">if</span> rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()<span class="number">-1</span>); rem == <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Unrooted old chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, oldHead.Number, <span class="string">&quot;hash&quot;</span>, oldHead.Hash())</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			included = <span class="built_in">append</span>(included, add.Transactions()...)</span><br><span class="line">			<span class="keyword">if</span> add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()<span class="number">-1</span>); add == <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Unrooted new chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, newHead.Number, <span class="string">&quot;hash&quot;</span>, newHead.Hash())</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		reinject = types.TxDifference(discarded, included)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Initialize the internal state to the current head</span></span><br><span class="line"><span class="keyword">if</span> newHead == <span class="literal">nil</span> &#123;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>给交易池设置最新的世界状态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">statedb, err := pool.chain.StateAt(newHead.Root)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Error(<span class="string">&quot;Failed to reset txpool state&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交易池参数设置</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pool.currentState = statedb</span><br><span class="line">pool.pendingNonces = newTxNoncer(statedb)</span><br><span class="line">pool.currentMaxGas = newHead.GasLimit</span><br></pre></td></tr></table></figure>

<p>把旧链回退的交易放回交易池</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.Debug(<span class="string">&quot;Reinjecting stale transactions&quot;</span>, <span class="string">&quot;count&quot;</span>, <span class="built_in">len</span>(reinject))</span><br><span class="line">senderCacher.<span class="built_in">recover</span>(pool.signer, reinject)</span><br><span class="line">pool.addTxsLocked(reinject, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>更新分叉指示器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next := <span class="built_in">new</span>(big.Int).Add(newHead.Number, big.NewInt(<span class="number">1</span>))pool.istanbul = pool.chainconfig.IsIstanbul(next)</span><br></pre></td></tr></table></figure>

<h6 id="交易池升级"><a href="#交易池升级" class="headerlink" title="交易池升级"></a>交易池升级</h6><p>promoteTx是将queue列表中的Txs放入pending并随时广播。把交易放入queue状态时不广播。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">promoteExecutables</span><span class="params">(accounts []common.Address)</span> []*<span class="title">types</span>.<span class="title">Transaction</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪这些被升级的交易以便第一时间广播她们</span></span><br><span class="line">	<span class="keyword">var</span> promoted []*types.Transaction</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用list跟踪一个账户的交易列表</span></span><br><span class="line">	<span class="keyword">for</span> _, addr := <span class="keyword">range</span> accounts &#123;</span><br><span class="line">		list := pool.queue[addr]</span><br><span class="line">		<span class="keyword">if</span> list == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span> <span class="comment">// Just in case someone calls with a non existing account</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//删除所有被认为太旧的事务（低nonce）</span></span><br><span class="line">		forwards := list.Forward(pool.currentState.GetNonce(addr))</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> forwards &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed old queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 放弃所有成本过高的交易（低余额或无gas）</span></span><br><span class="line">		drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drops &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed unpayable queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br><span class="line">		queuedNofundsMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(drops)))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 执行promote操作</span></span><br><span class="line">		readies := list.Ready(pool.pendingNonces.get(addr))</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> readies &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			<span class="keyword">if</span> pool.promoteTx(addr, hash, tx) &#123;</span><br><span class="line">				log.Trace(<span class="string">&quot;Promoting queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">				promoted = <span class="built_in">append</span>(promoted, tx)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		queuedGauge.Dec(<span class="keyword">int64</span>(<span class="built_in">len</span>(readies)))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 删除超过允许限制的所有事务</span></span><br><span class="line">		<span class="keyword">var</span> caps types.Transactions</span><br><span class="line">		<span class="keyword">if</span> !pool.locals.contains(addr) &#123;</span><br><span class="line">			caps = list.Cap(<span class="keyword">int</span>(pool.config.AccountQueue))</span><br><span class="line">			<span class="keyword">for</span> _, tx := <span class="keyword">range</span> caps &#123;</span><br><span class="line">				hash := tx.Hash()</span><br><span class="line">				pool.all.Remove(hash)</span><br><span class="line">				log.Trace(<span class="string">&quot;Removed cap-exceeding queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">			&#125;</span><br><span class="line">			queuedRateLimitMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(caps)))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将所有丢弃的项目标记为已删除</span></span><br><span class="line">		pool.priced.Removed(<span class="built_in">len</span>(forwards) + <span class="built_in">len</span>(drops) + <span class="built_in">len</span>(caps))</span><br><span class="line">		queuedGauge.Dec(<span class="keyword">int64</span>(<span class="built_in">len</span>(forwards) + <span class="built_in">len</span>(drops) + <span class="built_in">len</span>(caps)))</span><br><span class="line">		<span class="keyword">if</span> pool.locals.contains(addr) &#123;</span><br><span class="line">			localGauge.Dec(<span class="keyword">int64</span>(<span class="built_in">len</span>(forwards) + <span class="built_in">len</span>(drops) + <span class="built_in">len</span>(caps)))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Delete the entire queue entry if it became empty.</span></span><br><span class="line">		<span class="keyword">if</span> list.Empty() &#123;</span><br><span class="line">			<span class="built_in">delete</span>(pool.queue, addr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> promoted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="交易池降级"><a href="#交易池降级" class="headerlink" title="交易池降级"></a>交易池降级</h6><p>如果出现新块，验证pending池。这将删除已包含在区块中的任何交易或因另一个交易（例如更高的gas）而无效的任何交易。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">demoteUnexecutables</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 遍历pending列表，获取每个addr的最新nonce值</span></span><br><span class="line">	<span class="keyword">for</span> addr, list := <span class="keyword">range</span> pool.pending &#123;</span><br><span class="line">		nonce := pool.currentState.GetNonce(addr)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 剔除nonce小于上面nonce值的交易，从all和priced中删除</span></span><br><span class="line">		olds := list.Forward(nonce)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> olds &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed old pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 返回账户余额已经不足以支付交易费用和一些暂时无效的交易</span></span><br><span class="line">		drops, invalids := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drops &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed unpayable pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">		&#125;</span><br><span class="line">		pool.priced.Removed(<span class="built_in">len</span>(olds) + <span class="built_in">len</span>(drops))</span><br><span class="line">		pendingNofundsMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(drops)))</span><br><span class="line">		<span class="comment">//将暂时无效的交易放到queue中</span></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> invalids &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			log.Trace(<span class="string">&quot;Demoting pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">			pool.enqueueTx(hash, tx)</span><br><span class="line">		&#125;</span><br><span class="line">		pendingGauge.Dec(<span class="keyword">int64</span>(<span class="built_in">len</span>(olds) + <span class="built_in">len</span>(drops) + <span class="built_in">len</span>(invalids)))</span><br><span class="line">		<span class="keyword">if</span> pool.locals.contains(addr) &#123;</span><br><span class="line">			localGauge.Dec(<span class="keyword">int64</span>(<span class="built_in">len</span>(olds) + <span class="built_in">len</span>(drops) + <span class="built_in">len</span>(invalids)))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果有间隙，将后面的交易移动到queue列表中</span></span><br><span class="line">		<span class="keyword">if</span> list.Len() &gt; <span class="number">0</span> &amp;&amp; list.txs.Get(nonce) == <span class="literal">nil</span> &#123;</span><br><span class="line">			gapped := list.Cap(<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">for</span> _, tx := <span class="keyword">range</span> gapped &#123;</span><br><span class="line">				hash := tx.Hash()</span><br><span class="line">				log.Error(<span class="string">&quot;Demoting invalidated transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">				pool.enqueueTx(hash, tx)</span><br><span class="line">			&#125;</span><br><span class="line">			pendingGauge.Dec(<span class="keyword">int64</span>(<span class="built_in">len</span>(gapped)))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果经过上面的降级，pending里某个addr一个交易都没有，就把该账户给删除</span></span><br><span class="line">		<span class="keyword">if</span> list.Empty() &#123;</span><br><span class="line">			<span class="built_in">delete</span>(pool.pending, addr)</span><br><span class="line">			<span class="built_in">delete</span>(pool.beats, addr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%B1%A0/" data-id="ckqma5nsi001g0wu7etnn62gw" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-以太坊中的编码" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81/">(no title)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81/" class="article-date"><time datetime="2021-07-02T11:06:38.793Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RLP编码"><a href="#RLP编码" class="headerlink" title="RLP编码"></a>RLP编码</h2><p>RLP (递归长度前缀)提供了一种适用于任意二进制数据数组的编码，RLP已经成为以太坊中对对象进行序列化的主要编码方式。 RLP的唯一目标就是解决结构体的编码问题；对原子数据类型（比如，字符串，整数型，浮点型）的编码则交给更高层的协议；以太坊中要求数字必须是一个大端字节序的、没有零占位的存储的格式（也就是说，一个整数0和一个空数组是等同的）。</p>
<h4 id="RLP编码规则"><a href="#RLP编码规则" class="headerlink" title="RLP编码规则"></a>RLP编码规则</h4><p>总体可以概括为: <code>内容</code> (单字节) , <code>前缀+内容</code> (总长&lt;55) , 或 <code>前缀+长度+内容</code> (总长&gt;55)</p>
<ol>
<li><strong>规则1(内容).</strong> . [0x00, 0x7f] 范围内的 <code>单个字节</code> , RLP 编码内容就是字节内容本身。</li>
</ol>
<p>例子：</p>
<ul>
<li><code>‘a’ = 0x61</code></li>
<li>整数  <code>15(&#39;\x0f&#39;) = 0x0f</code></li>
</ul>
<ol>
<li><strong>规则2(前缀+内容).</strong> . 0-55字节长度的字符串，RLP编码是 <code>前缀（0x80+len(字符串)）+字符串内容</code></li>
</ol>
<p>例子：</p>
<ul>
<li>abc编码结果是0x83 0x61 0x62 0x63，其中0x83=0x80+len(“abc”)。</li>
<li>整数 1024(‘\x04\00’) = [0x82, 0x04, 0x00]</li>
<li>空字符串 “” = 0x80</li>
<li>字符串  <code>&quot;dog&quot; = [0x83, &#39;d&#39;, &#39;o&#39;, &#39;g&#39; ]</code></li>
</ul>
<ol>
<li><strong>规则3(前缀+长度+内容)</strong> . &gt;55字节长度字符串, RLP编码是 <code>前缀（0xb7＋len(len(字符串)))+len(字符串)+字符串内容</code></li>
</ol>
<p>例子:</p>
<ul>
<li>字符串 “Lorem ipsum dolor sit amet, consectetur adipisicing elit” = [0xb8, 0x38, ‘L’, ‘o’, ‘r’, ‘e’, ‘m’, ‘ ‘, … , ‘e’, ‘l’, ‘i’, ‘t’]</li>
</ul>
<ol>
<li><strong>规则4(前缀+内容).</strong> . 列表的总长度（列表的总长度指的是它包含的项的数量加它包含的各项的长度之和）是0-55字节，它的RLP编码是 <code>前缀(0xc0+len(列表总))+列表中各元素项的RLP编码</code> ，前缀取值范围是 <code>[0xc0, 0xf7]</code> 。</li>
</ol>
<p>例子:</p>
<ul>
<li><p>列表  <code>[&quot;cate&quot;,&quot;dog&quot;] = [0xc9, 0x84, &#39;c&#39;, &#39;a&#39;, &#39;t&#39;, &#39;e&#39;,0x83, &#39;d&#39;, &#39;o&#39;, &#39;g&#39; ]</code></p>
<p><code>0xc9</code> = 0xc0+ 1+4+1+3 (1:字符串长度的长度, 4:字符串长度, 1:字符串长度的长度,3:字符串长度)</p>
</li>
<li><p>列表  <code>[ [], [[]], [ [], [[]] ] ] = [0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0]</code></p>
</li>
<li><p><strong>规则5(前缀+长度+内容).</strong> ** ** 列表的总长度大于55字节，它的RLP编码是 <code>前缀(0xf7+len(len(列表总)))+len(列表总)+列表中各元素项的RLP编码</code> ，前缀取值范围是 <code>[0xf8, 0xff]</code> 。</p>
<p>例子:</p>
<ul>
<li><p>列表 <code>[&quot;The length of this sentence is more than 55 bytes, &quot;, &quot;I know it because I pre-designed it&quot;] = [0xf8 0x58 0xb3 &#39;T&#39;,&#39;h&#39;,&#39;e&#39;,...</code></p>
<p>0xf8=0xf7+1 (1:列表总长度的长度)</p>
<p>0x58=0x56+1+1 (0x56:列表总长度 1+1: 2个字符串长度的长度)</p>
<p>0xb3=0x80+0x33 (33: 字符串长度)</p>
</li>
</ul>
</li>
</ul>
<p>综合编码的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;abc&quot;,[&quot;The length of this sentence is more than 55 bytes, &quot;, &quot;I know it because I pre-designed it&quot;]]</span><br><span class="line">= [0xf8 0x5e 0x83 0x61 98 99 248 88 179 84 104 101 32 108 101 110 103 116 104 32 111 102 32 116 104 105 115 32 115 101 110 116 101 110 99 101 32 105 115 32 109 111 114 101 32 116 104 97 110 32 53 53 32 98 121 116 101 115 44 32 163 73 32 107 110 111 119 32 105 116 32 98 101 99 97 117 115 101 32 73 32 112 114 101 45 100 101 115 105 103 110 101 100 32 105 116]</span><br></pre></td></tr></table></figure>

<p>0xf8=0xf7+1 (1:列表总长度的长度)</p>
<p>0x5e=90 + 1 +2 +1 (90:字符串总长度 1:第一个字符串前缀长度 2: 第二个字符串前缀+长度 1: 第三个字符串前缀)</p>
<h4 id="RLP解码规则"><a href="#RLP解码规则" class="headerlink" title="RLP解码规则"></a>RLP解码规则</h4><ol>
<li>如果f∈ [0,128),　那么它是一个字节本身。</li>
</ol>
<p>2.　如果f∈[128,184)，那么它是一个长度不超过55的byte数组，数组的长度为  <code>l=f-128</code></p>
<p>3.　如果f∈[184,192)，那么它是一个长度超过55的数组，长度本身的编码长度 <code>ll=f-183</code> ,然后从第二个字节开始读取长度为ll的bytes，按照BigEndian编码成整数l，l即为数组的长度。</p>
<p>4.　如果f∈(192,247]，那么它是一个编码后总长度不超过55的列表，列表长度为 <code>l=f-192</code> 。递归使用规则1~4进行解码。</p>
<p>5.　如果f∈(247,256]，那么它是编码后长度大于55的列表，其长度本身的编码长度 <code>ll=f-247</code> ,然后从第二个字节读取长度为ll的bytes,按BigEndian编码成整数l，l即为子列表长度。然后递归根据解码规则进行解码。</p>
<h4 id="RLP在以太坊中的使用"><a href="#RLP在以太坊中的使用" class="headerlink" title="RLP在以太坊中的使用"></a>RLP在以太坊中的使用</h4><p>以构成交易树/状态树为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeriveSha</span><span class="params">(list DerivableList)</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">	keybuf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	trie := <span class="built_in">new</span>(trie.Trie)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; list.Len(); i++ &#123;</span><br><span class="line">		keybuf.Reset()</span><br><span class="line">        <span class="comment">//编码序号</span></span><br><span class="line">		rlp.Encode(keybuf, <span class="keyword">uint</span>(i))</span><br><span class="line">        <span class="comment">//编码list[i]并存入mpt树中</span></span><br><span class="line">		trie.Update(keybuf.Bytes(), list.GetRlp(i))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> trie.Hash()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构成最底层mpt树的时候，将 序号rlp编码，交易内容的rlp编码 构成一个键值对 放入mpt树中存储</p>
<h4 id="MPT中的编码"><a href="#MPT中的编码" class="headerlink" title="MPT中的编码"></a>MPT中的编码</h4><p>在以太坊协议中，不管是地址还是hash，都是一个16进制串，如”0x5b3edbcf7d0a97e95e57a4554a29ea66601b71ad”，数据最小的表示单位为一位16进制，如1、a等，但在编程实现中，数据的最小表示单位往往是byte（8bit，2位16进制数），这样在用byte来表示一串奇数长度的16进制串时会出现问题，如”5b3”和”5b30”，直接转成byte都是5b30。还有一种简单直观的转换方式，”5b3”-&gt;”050b03”，这种方式虽然简单，但是数据量会翻倍，不利于大量hash的计算，同时也会增加tree的大小，降低同步性能。Hex-Prefix Encoding能解决这些问题。</p>
<h6 id="hex编码"><a href="#hex编码" class="headerlink" title="hex编码"></a>hex编码</h6><p>用于树路径中，是将数据 key 进行半字节拆解而成。即依次将 key[0],key[1],…,key[n] 分别进行半字节拆分成两个数，再依次存放在长度为 len(key)+1 的数组中。 并在数组末尾写入终止符 <code>16</code>。算法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trie/encoding.go:65</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keybytesToHex</span><span class="params">(str []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(str)*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> nibbles = <span class="built_in">make</span>([]<span class="keyword">byte</span>, l)</span><br><span class="line">	<span class="keyword">for</span> i, b := <span class="keyword">range</span> str &#123;</span><br><span class="line">		nibbles[i*<span class="number">2</span>] = b / <span class="number">16</span></span><br><span class="line">		nibbles[i*<span class="number">2</span>+<span class="number">1</span>] = b % <span class="number">16</span></span><br><span class="line">	&#125;</span><br><span class="line">	nibbles[l<span class="number">-1</span>] = <span class="number">16</span></span><br><span class="line">	<span class="keyword">return</span> nibbles</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例如：字符串 “romane” 的 bytes 是 <code>[114 111 109 97 110 101]</code>，在 HEX 编码时将其依次处理：</p>
<table>
<thead>
<tr>
<th align="left">i</th>
<th align="left">key[i]</th>
<th align="left">key[i]二进制</th>
<th align="left">nibbles[i*2]=高四位</th>
<th align="left">nibbles[i*2+1]=低四位</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">114</td>
<td align="left">011100102</td>
<td align="left">01112= 7</td>
<td align="left">00102= 2</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">111</td>
<td align="left">011011112</td>
<td align="left">01102=6</td>
<td align="left">11112=15</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">109</td>
<td align="left">011011012</td>
<td align="left">01102=6</td>
<td align="left">11012=13</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">97</td>
<td align="left">011000012</td>
<td align="left">01102=6</td>
<td align="left">00012=1</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">110</td>
<td align="left">011011102</td>
<td align="left">01102=6</td>
<td align="left">11102=14</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">101</td>
<td align="left">011001012</td>
<td align="left">01102=6</td>
<td align="left">01012=5</td>
</tr>
</tbody></table>
<h6 id="HP-Hex-Prefix-编码"><a href="#HP-Hex-Prefix-编码" class="headerlink" title="HP(Hex-Prefix) 编码"></a>HP(Hex-Prefix) 编码</h6><p>输入 key 结尾为 0x10，则去掉这个终止符。</p>
<p>key 之前补一个二进制flag四元组(Nibble)， 这个四元组第 0 位区分奇偶信息，第 1 位区分节点类型。</p>
<p>如果输入 key 的长度是偶数，则再添加一个四元组 0x0 在 flag 四元组后。</p>
<p>将原来的 key 内容压缩，将分离的两个 hex(Nibble) 以高四位低四位进行合并成一个byte。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81/" data-id="ckqma5ns100110wu7bdgs4avk" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-以太坊RPC通信" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8ARPC%E9%80%9A%E4%BF%A1/">(no title)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8ARPC%E9%80%9A%E4%BF%A1/" class="article-date"><time datetime="2021-07-02T11:06:38.791Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p>启动geth</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">geth</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> args := ctx.Args(); <span class="built_in">len</span>(args) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid command: %q&quot;</span>, args[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	prepare(ctx)</span><br><span class="line">	node := makeFullNode(ctx)</span><br><span class="line">	<span class="keyword">defer</span> node.Close()</span><br><span class="line">	startNode(ctx, node)</span><br><span class="line">	node.Wait()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动node</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start create a live P2P node and starts running it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	n.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> n.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Short circuit if the node&#x27;s already running</span></span><br><span class="line">	<span class="keyword">if</span> n.server != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrNodeRunning</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := n.openDataDir(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the p2p server. This creates the node key and</span></span><br><span class="line">	<span class="comment">// discovery databases.</span></span><br><span class="line">	n.serverConfig = n.config.P2P</span><br><span class="line">	n.serverConfig.PrivateKey = n.config.NodeKey()</span><br><span class="line">	n.serverConfig.Name = n.config.NodeName()</span><br><span class="line">	n.serverConfig.Logger = n.log</span><br><span class="line">	<span class="keyword">if</span> n.serverConfig.StaticNodes == <span class="literal">nil</span> &#123;</span><br><span class="line">		n.serverConfig.StaticNodes = n.config.StaticNodes()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.serverConfig.TrustedNodes == <span class="literal">nil</span> &#123;</span><br><span class="line">		n.serverConfig.TrustedNodes = n.config.TrustedNodes()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.serverConfig.NodeDatabase == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		n.serverConfig.NodeDatabase = n.config.NodeDB()</span><br><span class="line">	&#125;</span><br><span class="line">	running := &amp;p2p.Server&#123;Config: n.serverConfig&#125;</span><br><span class="line">	n.log.Info(<span class="string">&quot;Starting peer-to-peer node&quot;</span>, <span class="string">&quot;instance&quot;</span>, n.serverConfig.Name)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Otherwise copy and specialize the P2P configuration</span></span><br><span class="line">	services := <span class="built_in">make</span>(<span class="keyword">map</span>[reflect.Type]Service)</span><br><span class="line">	<span class="keyword">for</span> _, constructor := <span class="keyword">range</span> n.serviceFuncs &#123;</span><br><span class="line">		<span class="comment">// Create a new context for the particular service</span></span><br><span class="line">		ctx := &amp;ServiceContext&#123;</span><br><span class="line">			config:         n.config,</span><br><span class="line">			services:       <span class="built_in">make</span>(<span class="keyword">map</span>[reflect.Type]Service),</span><br><span class="line">			EventMux:       n.eventmux,</span><br><span class="line">			AccountManager: n.accman,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> kind, s := <span class="keyword">range</span> services &#123; <span class="comment">// copy needed for threaded access</span></span><br><span class="line">			ctx.services[kind] = s</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Construct and save the service</span></span><br><span class="line">		service, err := constructor(ctx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		kind := reflect.TypeOf(service)</span><br><span class="line">		<span class="keyword">if</span> _, exists := services[kind]; exists &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;DuplicateServiceError&#123;Kind: kind&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		services[kind] = service</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Gather the protocols and start the freshly assembled P2P server</span></span><br><span class="line">	<span class="keyword">for</span> _, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">		running.Protocols = <span class="built_in">append</span>(running.Protocols, service.Protocols()...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := running.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> convertFileLockError(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Start each of the services</span></span><br><span class="line">	<span class="keyword">var</span> started []reflect.Type</span><br><span class="line">	<span class="keyword">for</span> kind, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">		<span class="comment">// Start the next service, stopping all previous upon failure</span></span><br><span class="line">		<span class="keyword">if</span> err := service.Start(running); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> _, kind := <span class="keyword">range</span> started &#123;</span><br><span class="line">				services[kind].Stop()</span><br><span class="line">			&#125;</span><br><span class="line">			running.Stop()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Mark the service started for potential cleanup</span></span><br><span class="line">		started = <span class="built_in">append</span>(started, kind)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Lastly start the configured RPC interfaces</span></span><br><span class="line">	<span class="keyword">if</span> err := n.startRPC(services); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">			service.Stop()</span><br><span class="line">		&#125;</span><br><span class="line">		running.Stop()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Finish initializing the startup</span></span><br><span class="line">	n.services = services</span><br><span class="line">	n.server = running</span><br><span class="line">	n.stop = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startRPC</p>
<p>以太坊rpc有4种实现方式分别是<strong>inproc</strong>，<strong>ipc</strong>，<strong>http</strong>，<strong>ws</strong>。inproc是进程内部调用，为console使用；http是以http接口方式提供访问；ws是以websocket的方式提供访问。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startRPC is a helper method to start all the various RPC endpoint during node</span></span><br><span class="line"><span class="comment">// startup. It&#x27;s not meant to be called at any time afterwards as it makes certain</span></span><br><span class="line"><span class="comment">// assumptions about the state of the node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">startRPC</span><span class="params">(services <span class="keyword">map</span>[reflect.Type]Service)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Gather all the possible APIs to surface</span></span><br><span class="line">    <span class="comment">// 先添加所有的api</span></span><br><span class="line">	apis := n.apis()</span><br><span class="line">	<span class="keyword">for</span> _, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">		apis = <span class="built_in">append</span>(apis, service.APIs()...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Start the various API endpoints, terminating all in case of errors</span></span><br><span class="line">    <span class="comment">// 分别启动InProc IPC HTTP WS</span></span><br><span class="line">	<span class="keyword">if</span> err := n.startInProc(apis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := n.startIPC(apis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.stopInProc()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := n.startHTTP(n.httpEndpoint, apis, n.config.HTTPModules, n.config.HTTPCors, n.config.HTTPVirtualHosts, n.config.HTTPTimeouts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.stopIPC()</span><br><span class="line">		n.stopInProc()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := n.startWS(n.wsEndpoint, apis, n.config.WSModules, n.config.WSOrigins, n.config.WSExposeAll); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.stopHTTP()</span><br><span class="line">		n.stopIPC()</span><br><span class="line">		n.stopInProc()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All API endpoints started successfully</span></span><br><span class="line">	n.rpcAPIs = apis</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以startHTTP为例进行追踪</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startHTTP initializes and starts the HTTP RPC endpoint.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">startHTTP</span><span class="params">(endpoint <span class="keyword">string</span>, apis []rpc.API, modules []<span class="keyword">string</span>, cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts rpc.HTTPTimeouts)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Short circuit if the HTTP endpoint isn&#x27;t being exposed</span></span><br><span class="line">	<span class="keyword">if</span> endpoint == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	listener, handler, err := rpc.StartHTTPEndpoint(endpoint, apis, modules, cors, vhosts, timeouts)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	n.log.Info(<span class="string">&quot;HTTP endpoint opened&quot;</span>, <span class="string">&quot;url&quot;</span>, fmt.Sprintf(<span class="string">&quot;http://%s&quot;</span>, endpoint), <span class="string">&quot;cors&quot;</span>, strings.Join(cors, <span class="string">&quot;,&quot;</span>), <span class="string">&quot;vhosts&quot;</span>, strings.Join(vhosts, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">	<span class="comment">// All listeners booted successfully</span></span><br><span class="line">	n.httpEndpoint = endpoint</span><br><span class="line">	n.httpListener = listener</span><br><span class="line">	n.httpHandler = handler</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HTTP相关的有3个字段：</p>
<p>httpEndpoint：这是一个字符串，表示IP和端口号，默认是localhost:8545<br>httpListener：这是一个接口，调用net.Listen()时返回，包含了Accept()/Close()/Addr()这3个函数，可以用来接受和关闭连接<br>httpHandler：这是一个需要重点分析的结构，定义位于rpc/types.go：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	services serviceRegistry</span><br><span class="line">	idgen    <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">ID</span></span></span><br><span class="line">	run      <span class="keyword">int32</span></span><br><span class="line">	codecs   mapset.Set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type serviceRegistry map[string]*service // collection of services<br>可以看到，其中有一个services字段，是一个map，key是Namespace，value是一个service实例。注意这个service类型首字母是小写的，所以是不对外暴露的，定义位于rpc/types.go：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	name          <span class="keyword">string</span>               <span class="comment">// name for service</span></span><br><span class="line">	callbacks     <span class="keyword">map</span>[<span class="keyword">string</span>]*callback <span class="comment">// registered handlers</span></span><br><span class="line">	subscriptions <span class="keyword">map</span>[<span class="keyword">string</span>]*callback <span class="comment">// available subscriptions/notifications</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service中包含了两个字段callbacks和subscriptions</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> callbacks <span class="keyword">map</span>[<span class="keyword">string</span>]*callback      <span class="comment">// collection of RPC callbacks</span></span><br><span class="line"><span class="keyword">type</span> subscriptions <span class="keyword">map</span>[<span class="keyword">string</span>]*callback  <span class="comment">// collection of subscription callbacks</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> callback <span class="keyword">struct</span> &#123;</span><br><span class="line">    rcvr        reflect.Value  <span class="comment">// receiver of method</span></span><br><span class="line">    method      reflect.Method <span class="comment">// callback</span></span><br><span class="line">    argTypes    []reflect.Type <span class="comment">// input argument types</span></span><br><span class="line">    hasCtx      <span class="keyword">bool</span>           <span class="comment">// method&#x27;s first argument is a context (not included in argTypes)</span></span><br><span class="line">    errPos      <span class="keyword">int</span>            <span class="comment">// err return idx, of -1 when method cannot return error</span></span><br><span class="line">    isSubscribe <span class="keyword">bool</span>           <span class="comment">// indication if the callback is a subscription</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>subscription是一种特殊的callback，而callback结构中包含了RPC API所需要的所有信息：</p>
<p>rcvr：方法的接收者，这是一个反射值类型，其实就是指向了之前的NewPublicEthereumAPI<br>method：对应rcvr中的函数<br>argTypes：函数参数的类型列表<br>hasCtx：标识函数的第一个参数是否是context.Context类型<br>isSubscribe：是否是subscription类型（因为它们共用一个结构定义）</p>
<p>注册流程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartHTTPEndpoint starts the HTTP RPC endpoint, configured with cors/vhosts/modules.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartHTTPEndpoint</span><span class="params">(endpoint <span class="keyword">string</span>, apis []API, modules []<span class="keyword">string</span>, cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts HTTPTimeouts)</span> <span class="params">(net.Listener, *Server, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := checkModuleAvailability(modules, apis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Generate the whitelist based on the allowed modules</span></span><br><span class="line">	whitelist := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, module := <span class="keyword">range</span> modules &#123;</span><br><span class="line">		whitelist[module] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Register all the APIs exposed by the services</span></span><br><span class="line">	handler := NewServer()</span><br><span class="line">	<span class="keyword">for</span> _, api := <span class="keyword">range</span> apis &#123;</span><br><span class="line">		<span class="keyword">if</span> whitelist[api.Namespace] || (<span class="built_in">len</span>(whitelist) == <span class="number">0</span> &amp;&amp; api.Public) &#123;</span><br><span class="line">			<span class="keyword">if</span> err := handler.RegisterName(api.Namespace, api.Service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			log.Debug(<span class="string">&quot;HTTP registered&quot;</span>, <span class="string">&quot;namespace&quot;</span>, api.Namespace)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All APIs registered, start the HTTP listener</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		listener net.Listener</span><br><span class="line">		err      error</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> listener, err = net.Listen(<span class="string">&quot;tcp&quot;</span>, endpoint); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> NewHTTPServer(cors, vhosts, timeouts, handler).Serve(listener)</span><br><span class="line">	<span class="keyword">return</span> listener, handler, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>registertname函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">RegisterName</span><span class="params">(name <span class="keyword">string</span>, receiver <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.services.registerName(name, receiver)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *serviceRegistry)</span> <span class="title">registerName</span><span class="params">(name <span class="keyword">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	rcvrVal := reflect.ValueOf(rcvr)</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;no service name for type %s&quot;</span>, rcvrVal.Type().String())</span><br><span class="line">	&#125;</span><br><span class="line">	callbacks := suitableCallbacks(rcvrVal)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(callbacks) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;service %T doesn&#x27;t have any suitable methods/subscriptions to expose&quot;</span>, rcvr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> r.services == <span class="literal">nil</span> &#123;</span><br><span class="line">		r.services = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]service)</span><br><span class="line">	&#125;</span><br><span class="line">	svc, ok := r.services[name]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		svc = service&#123;</span><br><span class="line">			name:          name,</span><br><span class="line">			callbacks:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*callback),</span><br><span class="line">			subscriptions: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*callback),</span><br><span class="line">		&#125;</span><br><span class="line">		r.services[name] = svc</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> name, cb := <span class="keyword">range</span> callbacks &#123;</span><br><span class="line">		<span class="keyword">if</span> cb.isSubscribe &#123;</span><br><span class="line">			svc.subscriptions[name] = cb</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			svc.callbacks[name] = cb</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是先创建一个service实例，然后填充它的callbacks和subscriptions字段。其中suitableCallbacks()函数会检查API定义是否符合标准，然后创建callback实例放入map中。</p>
<h3 id="创建服务："><a href="#创建服务：" class="headerlink" title="创建服务："></a>创建服务：</h3><p>在开启RPC服务的时候 开启http rpc请求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := n.startHTTP(n.httpEndpoint, apis, n.config.HTTPModules, n.config.HTTPCors, n.config.HTTPVirtualHosts, n.config.HTTPTimeouts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	n.stopIPC()</span><br><span class="line">	n.stopInProc()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startHTTP initializes and starts the HTTP RPC endpoint.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">startHTTP</span><span class="params">(endpoint <span class="keyword">string</span>, apis []rpc.API, modules []<span class="keyword">string</span>, cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts rpc.HTTPTimeouts)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Short circuit if the HTTP endpoint isn&#x27;t being exposed</span></span><br><span class="line">	<span class="keyword">if</span> endpoint == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	listener, handler, err := rpc.StartHTTPEndpoint(endpoint, apis, modules, cors, vhosts, timeouts)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	n.log.Info(<span class="string">&quot;HTTP endpoint opened&quot;</span>, <span class="string">&quot;url&quot;</span>, fmt.Sprintf(<span class="string">&quot;http://%s&quot;</span>, endpoint), <span class="string">&quot;cors&quot;</span>, strings.Join(cors, <span class="string">&quot;,&quot;</span>), <span class="string">&quot;vhosts&quot;</span>, strings.Join(vhosts, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">	<span class="comment">// All listeners booted successfully</span></span><br><span class="line">	n.httpEndpoint = endpoint</span><br><span class="line">	n.httpListener = listener</span><br><span class="line">	n.httpHandler = handler</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StartHTTPEndpoint   启动一个线程开启serve服务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartHTTPEndpoint starts the HTTP RPC endpoint, configured with cors/vhosts/modules.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartHTTPEndpoint</span><span class="params">(endpoint <span class="keyword">string</span>, apis []API, modules []<span class="keyword">string</span>, cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts HTTPTimeouts)</span> <span class="params">(net.Listener, *Server, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := checkModuleAvailability(modules, apis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Generate the whitelist based on the allowed modules</span></span><br><span class="line">	whitelist := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, module := <span class="keyword">range</span> modules &#123;</span><br><span class="line">		whitelist[module] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Register all the APIs exposed by the services</span></span><br><span class="line">	handler := NewServer()</span><br><span class="line">	<span class="keyword">for</span> _, api := <span class="keyword">range</span> apis &#123;</span><br><span class="line">		<span class="keyword">if</span> whitelist[api.Namespace] || (<span class="built_in">len</span>(whitelist) == <span class="number">0</span> &amp;&amp; api.Public) &#123;</span><br><span class="line">			<span class="keyword">if</span> err := handler.RegisterName(api.Namespace, api.Service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			log.Debug(<span class="string">&quot;HTTP registered&quot;</span>, <span class="string">&quot;namespace&quot;</span>, api.Namespace)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All APIs registered, start the HTTP listener</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		listener net.Listener</span><br><span class="line">		err      error</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> listener, err = net.Listen(<span class="string">&quot;tcp&quot;</span>, endpoint); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">go</span> NewHTTPServer(cors, vhosts, timeouts, handler).Serve(listener)</span><br><span class="line">	<span class="keyword">return</span> listener, handler, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用NewHTTPServer创建server</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPServer</span><span class="params">(cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts HTTPTimeouts, srv http.Handler)</span> *<span class="title">http</span>.<span class="title">Server</span></span> &#123;</span><br><span class="line">	<span class="comment">// Wrap the CORS-handler within a host-handler</span></span><br><span class="line">	handler := newCorsHandler(srv, cors)</span><br><span class="line">	handler = newVHostHandler(vhosts, handler)</span><br><span class="line">	handler = newGzipHandler(handler)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure timeout values are meaningful</span></span><br><span class="line">	<span class="keyword">if</span> timeouts.ReadTimeout &lt; time.Second &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Sanitizing invalid HTTP read timeout&quot;</span>, <span class="string">&quot;provided&quot;</span>, timeouts.ReadTimeout, <span class="string">&quot;updated&quot;</span>, DefaultHTTPTimeouts.ReadTimeout)</span><br><span class="line">		timeouts.ReadTimeout = DefaultHTTPTimeouts.ReadTimeout</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> timeouts.WriteTimeout &lt; time.Second &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Sanitizing invalid HTTP write timeout&quot;</span>, <span class="string">&quot;provided&quot;</span>, timeouts.WriteTimeout, <span class="string">&quot;updated&quot;</span>, DefaultHTTPTimeouts.WriteTimeout)</span><br><span class="line">		timeouts.WriteTimeout = DefaultHTTPTimeouts.WriteTimeout</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> timeouts.IdleTimeout &lt; time.Second &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Sanitizing invalid HTTP idle timeout&quot;</span>, <span class="string">&quot;provided&quot;</span>, timeouts.IdleTimeout, <span class="string">&quot;updated&quot;</span>, DefaultHTTPTimeouts.IdleTimeout)</span><br><span class="line">		timeouts.IdleTimeout = DefaultHTTPTimeouts.IdleTimeout</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Bundle and start the HTTP server</span></span><br><span class="line">	<span class="keyword">return</span> &amp;http.Server&#123;</span><br><span class="line">		Handler:      handler,</span><br><span class="line">		ReadTimeout:  timeouts.ReadTimeout,</span><br><span class="line">		WriteTimeout: timeouts.WriteTimeout,</span><br><span class="line">		IdleTimeout:  timeouts.IdleTimeout,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这里，handler是源码包中http.Server的一个组成部分，但是定义为一个接口，以太坊通过重载方法，将其自定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	Addr    <span class="keyword">string</span>  <span class="comment">// TCP address to listen on, &quot;:http&quot; if empty</span></span><br><span class="line">	Handler Handler <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line">。。。&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>处理http rpc请求的逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP serves JSON-RPC requests over HTTP.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Permit dumb empty requests for remote health-checks (AWS)</span></span><br><span class="line">	<span class="keyword">if</span> r.Method == http.MethodGet &amp;&amp; r.ContentLength == <span class="number">0</span> &amp;&amp; r.URL.RawQuery == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> code, err := validateRequest(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), code)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All checks passed, create a codec that reads direct from the request body</span></span><br><span class="line">	<span class="comment">// untilEOF and writes the response to w and order the server to process a</span></span><br><span class="line">	<span class="comment">// single request.</span></span><br><span class="line">	ctx := r.Context()</span><br><span class="line">	ctx = context.WithValue(ctx, <span class="string">&quot;remote&quot;</span>, r.RemoteAddr)</span><br><span class="line">	ctx = context.WithValue(ctx, <span class="string">&quot;scheme&quot;</span>, r.Proto)</span><br><span class="line">	ctx = context.WithValue(ctx, <span class="string">&quot;local&quot;</span>, r.Host)</span><br><span class="line">	<span class="keyword">if</span> ua := r.Header.Get(<span class="string">&quot;User-Agent&quot;</span>); ua != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		ctx = context.WithValue(ctx, <span class="string">&quot;User-Agent&quot;</span>, ua)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> origin := r.Header.Get(<span class="string">&quot;Origin&quot;</span>); origin != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		ctx = context.WithValue(ctx, <span class="string">&quot;Origin&quot;</span>, origin)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	w.Header().Set(<span class="string">&quot;content-type&quot;</span>, contentType)</span><br><span class="line">	codec := newHTTPServerConn(r, w)</span><br><span class="line">	<span class="keyword">defer</span> codec.<span class="built_in">close</span>()</span><br><span class="line">	s.serveSingleRequest(ctx, codec)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serveSingleRequest reads and processes a single RPC request from the given codec. This</span></span><br><span class="line"><span class="comment">// is used to serve HTTP connections. Subscriptions and reverse calls are not allowed in</span></span><br><span class="line"><span class="comment">// this mode.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">serveSingleRequest</span><span class="params">(ctx context.Context, codec ServerCodec)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Don&#x27;t serve if server is stopped.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.LoadInt32(&amp;s.run) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	h := newHandler(ctx, codec, s.idgen, &amp;s.services)</span><br><span class="line">	h.allowSubscribe = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">defer</span> h.<span class="built_in">close</span>(io.EOF, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	reqs, batch, err := codec.readBatch()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">			codec.writeJSON(ctx, errorMessage(&amp;invalidMessageError&#123;<span class="string">&quot;parse error&quot;</span>&#125;))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> batch &#123;</span><br><span class="line">		h.handleBatch(reqs)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		h.handleMsg(reqs[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">handleMsg</span><span class="params">(msg *jsonrpcMessage)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ok := h.handleImmediate(msg); ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h.startCallProc(<span class="function"><span class="keyword">func</span><span class="params">(cp *callProc)</span></span> &#123;</span><br><span class="line">		answer := h.handleCallMsg(cp, msg)</span><br><span class="line">		h.addSubscriptions(cp.notifiers)</span><br><span class="line">		<span class="keyword">if</span> answer != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.conn.writeJSON(cp.ctx, answer)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, n := <span class="keyword">range</span> cp.notifiers &#123;</span><br><span class="line">			n.activate()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleCallMsg executes a call message and returns the answer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">handleCallMsg</span><span class="params">(ctx *callProc, msg *jsonrpcMessage)</span> *<span class="title">jsonrpcMessage</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> msg.isNotification():</span><br><span class="line">		h.handleCall(ctx, msg)</span><br><span class="line">		h.log.Debug(<span class="string">&quot;Served &quot;</span>+msg.Method, <span class="string">&quot;t&quot;</span>, time.Since(start))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> msg.isCall():</span><br><span class="line">		resp := h.handleCall(ctx, msg)</span><br><span class="line">		<span class="keyword">if</span> resp.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.log.Warn(<span class="string">&quot;Served &quot;</span>+msg.Method, <span class="string">&quot;reqid&quot;</span>, idForLog&#123;msg.ID&#125;, <span class="string">&quot;t&quot;</span>, time.Since(start), <span class="string">&quot;err&quot;</span>, resp.Error.Message)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			h.log.Debug(<span class="string">&quot;Served &quot;</span>+msg.Method, <span class="string">&quot;reqid&quot;</span>, idForLog&#123;msg.ID&#125;, <span class="string">&quot;t&quot;</span>, time.Since(start))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resp</span><br><span class="line">	<span class="keyword">case</span> msg.hasValidID():</span><br><span class="line">		<span class="keyword">return</span> msg.errorResponse(&amp;invalidRequestError&#123;<span class="string">&quot;invalid request&quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> errorMessage(&amp;invalidRequestError&#123;<span class="string">&quot;invalid request&quot;</span>&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleCall processes method calls.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">handleCall</span><span class="params">(cp *callProc, msg *jsonrpcMessage)</span> *<span class="title">jsonrpcMessage</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> msg.isSubscribe() &#123;</span><br><span class="line">		<span class="keyword">return</span> h.handleSubscribe(cp, msg)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//新建callback对象</span></span><br><span class="line">	<span class="keyword">var</span> callb *callback</span><br><span class="line">	<span class="keyword">if</span> msg.isUnsubscribe() &#123;</span><br><span class="line">		callb = h.unsubscribeCb</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		callb = h.reg.callback(msg.Method)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> callb == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> msg.errorResponse(&amp;methodNotFoundError&#123;method: msg.Method&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//解析出参数</span></span><br><span class="line">	args, err := parsePositionalArguments(msg.Params, callb.argTypes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> msg.errorResponse(&amp;invalidParamsError&#123;err.Error()&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h.runMethod(cp.ctx, msg, callb, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runMethod runs the Go callback for an RPC method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">runMethod</span><span class="params">(ctx context.Context, msg *jsonrpcMessage, callb *callback, args []reflect.Value)</span> *<span class="title">jsonrpcMessage</span></span> &#123;</span><br><span class="line">    <span class="comment">//传入method args得到结果</span></span><br><span class="line">	result, err := callb.call(ctx, msg.Method, args)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> msg.errorResponse(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msg.response(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call invokes the callback.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *callback)</span> <span class="title">call</span><span class="params">(ctx context.Context, method <span class="keyword">string</span>, args []reflect.Value)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;, errRes error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Create the argument slice.</span></span><br><span class="line">	fullargs := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>, <span class="number">2</span>+<span class="built_in">len</span>(args))</span><br><span class="line">	<span class="keyword">if</span> c.rcvr.IsValid() &#123;</span><br><span class="line">		fullargs = <span class="built_in">append</span>(fullargs, c.rcvr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.hasCtx &#123;</span><br><span class="line">		fullargs = <span class="built_in">append</span>(fullargs, reflect.ValueOf(ctx))</span><br><span class="line">	&#125;</span><br><span class="line">	fullargs = <span class="built_in">append</span>(fullargs, args...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Catch panic while running the callback.</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">			buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">			buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">			log.Error(<span class="string">&quot;RPC method &quot;</span> + method + <span class="string">&quot; crashed: &quot;</span> + fmt.Sprintf(<span class="string">&quot;%v\n%s&quot;</span>, err, buf))</span><br><span class="line">			errRes = errors.New(<span class="string">&quot;method handler crashed&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// Run the callback.</span></span><br><span class="line">    <span class="comment">// 主要执行这一步</span></span><br><span class="line">	results := c.fn.Call(fullargs)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(results) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.errPos &gt;= <span class="number">0</span> &amp;&amp; !results[c.errPos].IsNil() &#123;</span><br><span class="line">		<span class="comment">// Method has returned non-nil error value.</span></span><br><span class="line">		err := results[c.errPos].Interface().(error)</span><br><span class="line">		<span class="keyword">return</span> reflect.Value&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results[<span class="number">0</span>].Interface(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里留一个坑。现已知go调用rpc是通过反射reflect实现的，reflect反射是指一类应用，它们能够自描述和自控制。具体实现还未完全掌握。</p>
<h3 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h3><p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST --data &#x27;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getBlockByHash&quot;,&quot;params&quot;:[&quot;0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331&quot;, true],&quot;id&quot;:1&#125;&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;jsonrpc&quot;</span>:<span class="string">&quot;2.0&quot;</span>,</span><br><span class="line"><span class="attr">&quot;result&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;number&quot;</span>: <span class="string">&quot;0x1b4&quot;</span>, <span class="comment">// 436</span></span><br><span class="line">    <span class="attr">&quot;hash&quot;</span>: <span class="string">&quot;0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;parentHash&quot;</span>: <span class="string">&quot;0x9646252be9520f6e71339a8df9c55e4d7619deeb018d2a3f2d21fc165dde5eb5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;nonce&quot;</span>: <span class="string">&quot;0xe04d296d2460cfb8472af2c5fd05b5a214109c25688d3704aed5484f9a7792f2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sha3Uncles&quot;</span>: <span class="string">&quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;logsBloom&quot;</span>: <span class="string">&quot;0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;transactionsRoot&quot;</span>: <span class="string">&quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;stateRoot&quot;</span>: <span class="string">&quot;0xd5855eb08b3387c0af375e9cdb6acfc05eb8f519e419b874b6ff2ffda7ed1dff&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;miner&quot;</span>: <span class="string">&quot;0x4e65fda2159562a496f9f3522f89122a3088497a&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;difficulty&quot;</span>: <span class="string">&quot;0x027f07&quot;</span>, <span class="comment">// 163591</span></span><br><span class="line">    <span class="attr">&quot;totalDifficulty&quot;</span>:  <span class="string">&quot;0x027f07&quot;</span>, <span class="comment">// 163591</span></span><br><span class="line">    <span class="attr">&quot;extraData&quot;</span>: <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>:  <span class="string">&quot;0x027f07&quot;</span>, <span class="comment">// 163591</span></span><br><span class="line">    <span class="attr">&quot;gasLimit&quot;</span>: <span class="string">&quot;0x9f759&quot;</span>, <span class="comment">// 653145</span></span><br><span class="line">    <span class="attr">&quot;gasUsed&quot;</span>: <span class="string">&quot;0x9f759&quot;</span>, <span class="comment">// 653145</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;0x54e34e8e&quot;</span> <span class="comment">// 1424182926</span></span><br><span class="line">    <span class="string">&quot;transactions&quot;</span>: [&#123;...&#125;,&#123; ... &#125;] </span><br><span class="line">    <span class="string">&quot;uncles&quot;</span>: [<span class="string">&quot;0x1606e5...&quot;</span>, <span class="string">&quot;0xd5145a9...&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>请求对象需要包括下面4个字段：</p>
<ul>
<li>jsonrpc：协议版本号，固定是2.0</li>
<li>method：请求调用的函数名，可以看到是Namespace_Method这种命名方式</li>
<li>params： 函数参数列表，一般是一个数组</li>
<li>id：客户端和服务器之前通信的一个标识，服务器返回响应时必须返回相同的id。可以是数字或者字符串，不建议设为NULL</li>
</ul>
<p>返回的响应需要包含以下字段：</p>
<ul>
<li>jsonrpc：协议版本号，固定是2.0</li>
<li>result/error：返回的结果或者错误，二选一</li>
<li>id：客户端和服务器之前通信的一个标识，服务器返回响应时必须返回相同的id。可以是数字或者字符串，不建议设为NULL</li>
</ul>
<p>当收到调用rpc请求时一般会调用Dial函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dial creates a new client for the given URL.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The currently supported URL schemes are &quot;http&quot;, &quot;https&quot;, &quot;ws&quot; and &quot;wss&quot;. If rawurl is a</span></span><br><span class="line"><span class="comment">// file name with no URL scheme, a local socket connection is established using UNIX</span></span><br><span class="line"><span class="comment">// domain sockets on supported platforms and named pipes on Windows. If you want to</span></span><br><span class="line"><span class="comment">// configure transport options, use DialHTTP, DialWebsocket or DialIPC instead.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For websocket connections, the origin is set to the local host name.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The client reconnects automatically if the connection is lost.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(rawurl <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> DialContext(context.Background(), rawurl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DialContext creates a new RPC client, just like Dial.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The context is used to cancel or time out the initial connection establishment. It does</span></span><br><span class="line"><span class="comment">// not affect subsequent interactions with the client.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, rawurl <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span> &#123;</span><br><span class="line">	u, err := url.Parse(rawurl)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> u.Scheme &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;http&quot;</span>, <span class="string">&quot;https&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> DialHTTP(rawurl)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;ws&quot;</span>, <span class="string">&quot;wss&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> DialWebsocket(ctx, rawurl, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;stdio&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> DialStdIO(ctx)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> DialIPC(ctx, rawurl)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;no known transport for URL scheme %q&quot;</span>, u.Scheme)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在console/bridge.go控制台处理时也会调用到</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Send implements the web3 provider &quot;send&quot; method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bridge)</span> <span class="title">Send</span><span class="params">(call jsre.Call)</span> <span class="params">(goja.Value, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">// Remarshal the request into a Go value.</span></span><br><span class="line">	<span class="comment">// Execute the requests.</span></span><br><span class="line">	<span class="keyword">var</span> resps []*goja.Object</span><br><span class="line">	<span class="keyword">for</span> _, req := <span class="keyword">range</span> reqs &#123;</span><br><span class="line">		resp := call.VM.NewObject()</span><br><span class="line">		resp.Set(<span class="string">&quot;jsonrpc&quot;</span>, <span class="string">&quot;2.0&quot;</span>)</span><br><span class="line">		resp.Set(<span class="string">&quot;id&quot;</span>, req.ID)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> result json.RawMessage</span><br><span class="line">		err = b.client.Call(&amp;result, req.Method, req.Params...)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后还是调用到rpc/client.go 的call方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Call</span><span class="params">(result <span class="keyword">interface</span>&#123;&#125;, method <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	<span class="keyword">return</span> c.CallContext(ctx, result, method, args...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">CallContext</span><span class="params">(ctx context.Context, result <span class="keyword">interface</span>&#123;&#125;, method <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	msg, err := c.newMessage(method, args...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	op := &amp;requestOp&#123;ids: []json.RawMessage&#123;msg.ID&#125;, resp: <span class="built_in">make</span>(<span class="keyword">chan</span> *jsonrpcMessage, <span class="number">1</span>)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.isHTTP &#123;</span><br><span class="line">		err = c.sendHTTP(ctx, op, msg)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = c.send(ctx, op, msg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dispatch has accepted the request and will close the channel when it quits.</span></span><br><span class="line">	<span class="keyword">switch</span> resp, err := op.wait(ctx, c); &#123;</span><br><span class="line">	<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	<span class="keyword">case</span> resp.Error != <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> resp.Error</span><br><span class="line">	<span class="keyword">case</span> <span class="built_in">len</span>(resp.Result) == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> ErrNoResult</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> json.Unmarshal(resp.Result, &amp;result)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">sendHTTP</span><span class="params">(ctx context.Context, op *requestOp, msg <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	hc := c.writeConn.(*httpConn)</span><br><span class="line">	respBody, err := hc.doRequest(ctx, msg)</span><br><span class="line">	<span class="keyword">if</span> respBody != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> respBody.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> respBody != <span class="literal">nil</span> &#123;</span><br><span class="line">			buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">			<span class="keyword">if</span> _, err2 := buf.ReadFrom(respBody); err2 == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%v %v&quot;</span>, err, buf.String())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> respmsg jsonrpcMessage</span><br><span class="line">	<span class="keyword">if</span> err := json.NewDecoder(respBody).Decode(&amp;respmsg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	op.resp &lt;- &amp;respmsg</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rpc/http.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hc *httpConn)</span> <span class="title">doRequest</span><span class="params">(ctx context.Context, msg <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(io.ReadCloser, error)</span></span> &#123;</span><br><span class="line">	body, err := json.Marshal(msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	req := hc.req.WithContext(ctx)</span><br><span class="line">	req.Body = ioutil.NopCloser(bytes.NewReader(body))</span><br><span class="line">	req.ContentLength = <span class="keyword">int64</span>(<span class="built_in">len</span>(body))</span><br><span class="line"></span><br><span class="line">	resp, err := hc.client.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resp.StatusCode &lt; <span class="number">200</span> || resp.StatusCode &gt;= <span class="number">300</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> resp.Body, errors.New(resp.Status)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resp.Body, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往下调用就是源码包的http/client.go的方法了</p>
<p>eth/api.go和internal/ethapi/api.go的关系：internal包中的api是对jsonrpc的拓展</p>
<h3 id="关键命令"><a href="#关键命令" class="headerlink" title="关键命令"></a>关键命令</h3><p><strong>命令1</strong>: personal.newAccount(password) - 新建账户</p>
<p>api: internal/ethapi.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PrivateAccountAPI)</span> <span class="title">NewAccount</span><span class="params">(password <span class="keyword">string</span>)</span> <span class="params">(common.Address, error)</span>`</span></span><br></pre></td></tr></table></figure>

<p><strong>命令2</strong>：miner.start(threadNum) - 开始挖矿，默认<code>eth.accounts</code>第一个用户</p>
<p>api: eth/api.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PrivateMinerAPI)</span> <span class="title">Start</span><span class="params">(threads *<span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p><strong>命令3</strong>：miner.stop() - 停止挖矿</p>
<p>api: eth/api.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PrivateMinerAPI)</span> <span class="title">Stop</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>命令4</strong>：personal.unlockAccount(address, password) - 转账前解锁账户</p>
<p>api:  internal/ethapi.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PrivateAccountAPI)</span> <span class="title">UnlockAccount</span><span class="params">(addr common.Address, password <span class="keyword">string</span>, duration *<span class="keyword">uint64</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>命令5</strong>：eth.sendTransaction({from: _, to: _, value: _}) - 转账</p>
<p>api: ethapi/api.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PrivateAccountAPI)</span> <span class="title">SendTransaction</span><span class="params">(ctx context.Context, args SendTxArgs, passwd <span class="keyword">string</span>)</span> <span class="params">(common.Hash,error)</span></span></span><br></pre></td></tr></table></figure>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8ARPC%E9%80%9A%E4%BF%A1/" data-id="ckqma5nsh001e0wu75o3y3gf5" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-交易签名和验签" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E4%BA%A4%E6%98%93%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/">(no title)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E4%BA%A4%E6%98%93%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/" class="article-date"><time datetime="2021-07-02T11:06:38.790Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="以太坊中交易的结构有-r-s-v-字段"><a href="#以太坊中交易的结构有-r-s-v-字段" class="headerlink" title="以太坊中交易的结构有 r s v 字段"></a>以太坊中交易的结构有 r s v 字段</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">	AccountNonce <span class="keyword">uint64</span>          <span class="string">`json:&quot;nonce&quot;    gencodec:&quot;required&quot;`</span><span class="comment">//由交易发送者发出的的交易的数量，由 Tn 表示</span></span><br><span class="line">	Price        *big.Int        <span class="string">`json:&quot;gasPrice&quot; gencodec:&quot;required&quot;`</span><span class="comment">//为执行这个交易所需要进行的计算步骤消 耗的每单位 gas 的价格，以 Wei 为单位，由 Tp 表 示。</span></span><br><span class="line">	GasLimit     <span class="keyword">uint64</span>          <span class="string">`json:&quot;gas&quot;      gencodec:&quot;required&quot;`</span><span class="comment">//用于执行这个交易的最大 gas 数量。这个值须在交易开始前设置，且设定后不能再增加，由Tg 表示。</span></span><br><span class="line">	Recipient    *common.Address <span class="string">`json:&quot;to&quot;       rlp:&quot;nil&quot;`</span> <span class="comment">// nil means contract creation 160 位的消息调用接收者地址；对与合约创建交易，用 ∅ 表示 B0 的唯一成员。此字段由 Tt 表示</span></span><br><span class="line">	Amount       *big.Int        <span class="string">`json:&quot;value&quot;    gencodec:&quot;required&quot;`</span><span class="comment">//转移到接收者账户的 Wei 的数量；对于合约 创建，则代表给新建合约地址的初始捐款。由 Tv 表示。</span></span><br><span class="line">	Payload      []<span class="keyword">byte</span>          <span class="string">`json:&quot;input&quot;    gencodec:&quot;required&quot;`</span><span class="comment">//如果目标账户包含代码，该代码会执行，payload就是输入数据。</span></span><br><span class="line">																	  <span class="comment">//如果目标账户是零账户（账户地址是0），交易将创建一个新合约。</span></span><br><span class="line">																	  <span class="comment">//这个合约地址不是零地址，而是由合约创建者的地址和该地址发出过的交易数量（被称为nonce）计算得到。</span></span><br><span class="line">																	  <span class="comment">//创建合约交易的payload被当作EVM字节码执行。执行的输出做为合约代码被永久存储。这意味着，为了创建一个合约，</span></span><br><span class="line">																	  <span class="comment">//你不需要向合约发送真正的合约代码，而是发送能够返回真正代码的代码。</span></span><br><span class="line">	                                                                  <span class="comment">//</span></span><br><span class="line">	<span class="comment">// Signature values											      //</span></span><br><span class="line">	V *big.Int <span class="string">`json:&quot;v&quot; gencodec:&quot;required&quot;`</span><span class="comment">//v, r, s: 与交易签名相符的若干数值，用于确定交易的发送者，由 Tw，Tr 和 Ts 表示。</span></span><br><span class="line">	R *big.Int <span class="string">`json:&quot;r&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">	S *big.Int <span class="string">`json:&quot;s&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// This is only used when marshaling to JSON.</span></span><br><span class="line">	Hash *common.Hash <span class="string">`json:&quot;hash&quot; rlp:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="签名的函数"><a href="#签名的函数" class="headerlink" title="签名的函数"></a>签名的函数</h6><p>其实还是用secp256k1进行的签名，只是把比特币中签名的数据格式稍作改变</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//crypto/signature_nocgo.go:60</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sign</span><span class="params">(hash []<span class="keyword">byte</span>, prv *ecdsa.PrivateKey)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//检查哈希的长度是否为32字节</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(hash) != <span class="number">32</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;hash is required to be exactly 32 bytes (%d)&quot;</span>, <span class="built_in">len</span>(hash))</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//检查私钥的曲线符合secp256k1</span></span><br><span class="line">	<span class="keyword">if</span> prv.Curve != btcec.S256() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;private key curve is not secp256k1&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//传入私钥，签名的内容，私钥选项为非压缩，签名的返回为[27 + recid] [R] [S]</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	sig, err := btcec.SignCompact(btcec.S256(), (*btcec.PrivateKey)(prv), hash, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//比特币中第一个字节的值等于27+recid，因此 recid= sig[0]-27</span></span><br><span class="line">	v := sig[<span class="number">0</span>] - <span class="number">27</span> </span><br><span class="line">    <span class="comment">//调整顺序为r s v</span></span><br><span class="line">	<span class="built_in">copy</span>(sig, sig[<span class="number">1</span>:])</span><br><span class="line">	sig[<span class="number">64</span>] = v</span><br><span class="line">	<span class="keyword">return</span> sig, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="./picture/11.png!de"></p>
<p>简单地说，就是传入要签名的数据和私钥对结果进行签名，得到r s v 格式的签名结果，签名结果是65字节的字节数组。一个字节是8位，一个字符是4位，所以转化为字符串时长度为130.</p>
<p><strong>在交易签名时，V 值不再是recid, 而是 recid+ chainID*2+ 35(老版签名是recud+27)</strong></p>
<h6 id="验签的函数"><a href="#验签的函数" class="headerlink" title="验签的函数"></a>验签的函数</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	decodeHex:= <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">		b,err:=hex.DecodeString(s)</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	dataHash := sha256.Sum256([]<span class="keyword">byte</span>(<span class="string">&quot;ethereum&quot;</span>))</span><br><span class="line">	sig:=decodeHex(</span><br><span class="line"><span class="string">&quot;7912f50819764de81ab7791ab3d62f8dabe84c2fdb2f17d76465d28f8a968f7355fbb6cd8dfc7545b6258d4b032753b2074232b07f3911822b37f024cd10116600&quot;</span>)</span><br><span class="line">	pubkey:=decodeHex(</span><br><span class="line">	<span class="string">&quot;037db227d7094ce215c3a0f57e1bcc732551fe351f94249471934567e0f5dc1bf7&quot;</span>)</span><br><span class="line"></span><br><span class="line">	ok:=crypto.VerifySignature(pubkey,dataHash[:],sig[:<span class="built_in">len</span>(sig)<span class="number">-1</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;verify pass?&quot;</span>,ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入公钥，签名数据，验证是否验签通过。</p>
<p>关键点在于调用校验签名函数时，第三个参数sig 送入的是 <code>sig[:len(sig)-1]</code> 去掉了末尾的一个字节。这是因为函数<code>VerifySignature</code>要求 <code>sig</code>参数必须是<code>[R] [S]</code>格式，因此需要去除末尾的<code>[V]</code>。</p>
<p>实际在区块链中，为了安全性签名中加入了特性数据，比如签名类型(环签、单私钥签名等)、链标识符等。</p>
<h6 id="以太坊中区块中的交易的签名和验签"><a href="#以太坊中区块中的交易的签名和验签" class="headerlink" title="以太坊中区块中的交易的签名和验签"></a>以太坊中区块中的交易的签名和验签</h6><p>签名解析</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//core/types/transaction_signing.go</span></span><br><span class="line"><span class="comment">//tx是交易 s是签名器，根据区块高度不同有两个版本的签名器， prv是私匙</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignTx</span><span class="params">(tx *Transaction, s Signer, prv *ecdsa.PrivateKey)</span> <span class="params">(*Transaction, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//先对交易数据取哈希</span></span><br><span class="line">   h := s.Hash(tx)</span><br><span class="line">    <span class="comment">//用私钥对交易签名</span></span><br><span class="line">   sig, err := crypto.Sign(h[:], prv)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//将签名信息赋给交易</span></span><br><span class="line">   <span class="keyword">return</span> tx.WithSignature(s, sig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将签名信息赋给交易</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">WithSignature</span><span class="params">(signer Signer, sig []<span class="keyword">byte</span>)</span> <span class="params">(*Transaction, error)</span></span> &#123;</span><br><span class="line"> r, s, v, err := signer.SignatureValues(tx, sig)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line"> &#125;</span><br><span class="line"> cpy := &amp;Transaction&#123;data: tx.data&#125;</span><br><span class="line"> <span class="comment">//分别赋值给rsv   </span></span><br><span class="line"> cpy.data.R, cpy.data.S, cpy.data.V = r, s, v</span><br><span class="line"> <span class="keyword">return</span> cpy, <span class="literal">nil</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>验签解析</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//core/types/transaction_signing.go:127</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s EIP155Signer)</span> <span class="title">Sender</span><span class="params">(tx *Transaction)</span> <span class="params">(common.Address, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//看是不是老版交易</span></span><br><span class="line">   <span class="keyword">if</span> !tx.Protected() &#123; </span><br><span class="line">      <span class="keyword">return</span> HomesteadSigner&#123;&#125;.Sender(tx)</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//看chainid是否和签名器所指示的链id一致</span></span><br><span class="line">   <span class="keyword">if</span> tx.ChainId().Cmp(s.chainId) != <span class="number">0</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> common.Address&#123;&#125;, ErrInvalidChainId</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">   V := <span class="built_in">new</span>(big.Int).Sub(tx.data.V, s.chainIdMul)</span><br><span class="line">   V.Sub(V, big8)</span><br><span class="line">   <span class="keyword">return</span> recoverPlain(s.Hash(tx), tx.data.R, tx.data.S, V, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverPlain</span><span class="params">(sighash common.Hash, R, S, Vb *big.Int, homestead <span class="keyword">bool</span>)</span> <span class="params">(common.Address, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> Vb.BitLen() &gt; <span class="number">8</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> common.Address&#123;&#125;, ErrInvalidSig</span><br><span class="line">	&#125;</span><br><span class="line">	V := <span class="keyword">byte</span>(Vb.Uint64() - <span class="number">27</span>)</span><br><span class="line">	<span class="keyword">if</span> !crypto.ValidateSignatureValues(V, R, S, homestead) &#123;</span><br><span class="line">		<span class="keyword">return</span> common.Address&#123;&#125;, ErrInvalidSig</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// encode the signature in uncompressed format</span></span><br><span class="line">	r, s := R.Bytes(), S.Bytes()</span><br><span class="line">	sig := <span class="built_in">make</span>([]<span class="keyword">byte</span>, crypto.SignatureLength)</span><br><span class="line">	<span class="built_in">copy</span>(sig[<span class="number">32</span>-<span class="built_in">len</span>(r):<span class="number">32</span>], r)</span><br><span class="line">	<span class="built_in">copy</span>(sig[<span class="number">64</span>-<span class="built_in">len</span>(s):<span class="number">64</span>], s)</span><br><span class="line">	sig[<span class="number">64</span>] = V</span><br><span class="line">	<span class="comment">// recover the public key from the signature</span></span><br><span class="line">	pub, err := crypto.Ecrecover(sighash[:], sig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> common.Address&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(pub) == <span class="number">0</span> || pub[<span class="number">0</span>] != <span class="number">4</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> common.Address&#123;&#125;, errors.New(<span class="string">&quot;invalid public key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> addr common.Address</span><br><span class="line">	<span class="built_in">copy</span>(addr[:], crypto.Keccak256(pub[<span class="number">1</span>:])[<span class="number">12</span>:])</span><br><span class="line">	<span class="keyword">return</span> addr, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E4%BA%A4%E6%98%93%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/" data-id="ckqma5nrz000x0wu7b5oh7zet" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-以太坊Ghost协议" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8AGhost%E5%8D%8F%E8%AE%AE/">(no title)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8AGhost%E5%8D%8F%E8%AE%AE/" class="article-date"><time datetime="2021-07-02T11:06:38.790Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>前提条件：</p>
<p>比特币选用最长的链作为有效链。出块时间大概为10分钟，orphan block的出现较少。然而以太坊出块已经缩短为十几秒一个块，如果也只选用最长的链作为有效链，那么会大大地影响矿工的积极性。而且比特币的这种方式很可能会造成算力与奖励的不对等。</p>
<p>核心思想：对挖到无效的区块矿工给予奖励</p>
<p>挖到叔父区块根据离主区块的距离，得到7/8 6/8 …… 2/8 的区块奖励</p>
<p>包括一个叔父区块得到1/32的区块奖励</p>
<p><img src="./picture/5.png"></p>
<p>GHOST协议只给七代以内奖励： 鼓励分叉尽快合并</p>
<p>GHOST协议只给分叉后第一个区块奖励：防止分叉攻击</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8AGhost%E5%8D%8F%E8%AE%AE/" data-id="ckqma5ns0000y0wu7dbtr90rc" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-trie代码分析" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/trie%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">(no title)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/trie%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date"><time datetime="2021-07-02T11:06:38.789Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>MPT树在我的一个笔记中已经将过了（<a href="./%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">以太坊中的数据结构</a>）</p>
<p>在/trie目录下，geth给出了通用的MPT树的具体实现，下面分析一下代码。</p>
<p> 可以将 Trie 看做一个黑盒，分析下它暴露了什么接口。</p>
<p>[TOC]</p>
<h5 id="1-各个模块的大概作用"><a href="#1-各个模块的大概作用" class="headerlink" title="1.各个模块的大概作用"></a>1.各个模块的大概作用</h5><p>database.go：数据库是在trie数据结构和磁盘数据库之间的中间写入层。 目的是在内存中积累trie写操作，并且仅定期刷新一对尝试写入磁盘的内容，垃圾收集剩余的内容。</p>
<p>encoding.go：和hex编码有关</p>
<p>iterator.go：迭代器</p>
<p>node.go：定义了trie的四种节点和对节点的编码，数值类型操作，错误处理等。</p>
<p>proof.go：默克尔证明</p>
<p>secure_trie.go：SecureTrie使用密钥散列来包装Trie。 在安全的尝试下，所有访问操作使用keccak256对密钥进行哈希处理。 这样可以防止通过创建较长的节点链来调用代码，这会增加访问时间。与常规树相反，SecureTrie只能使用新建，并且必须具有附加的数据库。 该数据库还存储每个键的原像。不能并发使用。</p>
<p>sync.go：同步是主要的状态Trie同步调度程序，它提供了要检索的未知trie哈希，接受与所述哈希关联的节点数据并逐步重建trie，直到全部完成。</p>
<p>sync_bloom.go：快速同步过程中使用的Bloom筛选器，用于快速确定磁盘上是否已经存在Trie节点。 </p>
<p>trie.go：主要的定义</p>
<h5 id="2-一些比较重要的接口"><a href="#2-一些比较重要的接口" class="headerlink" title="2.一些比较重要的接口"></a>2.一些比较重要的接口</h5><h6 id="定义trie的结构："><a href="#定义trie的结构：" class="headerlink" title="定义trie的结构："></a>定义trie的结构：</h6><p>trie/go:树的结构，empty定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// emptyRoot is the known root hash of an empty trie.</span></span><br><span class="line">	emptyRoot = common.HexToHash(<span class="string">&quot;56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// emptyState is the known hash of an empty state trie entry.</span></span><br><span class="line">	emptyState = crypto.Keccak256Hash(<span class="literal">nil</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">	db   *Database</span><br><span class="line">	root node</span><br><span class="line">	<span class="comment">// Keep track of the number leafs which have been inserted since the last</span></span><br><span class="line">	<span class="comment">// hashing operation. This number will not directly map to the number of</span></span><br><span class="line">	<span class="comment">// actually unhashed nodes</span></span><br><span class="line">	unhashed <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>node.go:定义规范化mpt树的叶子节点</p>
<p><img src="picture/4.png" alt="4"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">interface</span> &#123;</span><br><span class="line">	fstring(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">	cache() (hashNode, <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	fullNode <span class="keyword">struct</span> &#123; <span class="comment">//可以携带多个子节点的节点</span></span><br><span class="line">		Children [<span class="number">17</span>]node <span class="comment">// Actual trie node data to encode/decode (needs custom encoder)</span></span><br><span class="line">		flags    nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	shortNode <span class="keyword">struct</span> &#123; <span class="comment">//只带一个子节点的节点</span></span><br><span class="line">		Key   []<span class="keyword">byte</span></span><br><span class="line">		Val   node</span><br><span class="line">		flags nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	hashNode  []<span class="keyword">byte</span> <span class="comment">//hashNode 是 fullNode 或 shortNode 对象的 RLP 编码的32 byte 的哈希值，表明该节点还没有载入内存</span></span><br><span class="line">	valueNode []<span class="keyword">byte</span> <span class="comment">//表示真正带有值的节点</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>trie.go：与mpt树有关的基本操作</p>
<h6 id="新建MPT树"><a href="#新建MPT树" class="headerlink" title="新建MPT树"></a>新建MPT树</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root common.Hash, db *Database)</span> <span class="params">(*Trie, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;trie.New called without a database&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	trie := &amp;Trie&#123;</span><br><span class="line">		db: db,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root != (common.Hash&#123;&#125;) &amp;&amp; root != emptyRoot &#123;</span><br><span class="line">		rootnode, err := trie.resolveHash(root[:], <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		trie.root = rootnode</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> trie, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">tryGet</span><span class="params">(origNode node, key []<span class="keyword">byte</span>, pos <span class="keyword">int</span>)</span> <span class="params">(value []<span class="keyword">byte</span>, newnode node, didResolve <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">TryUpdate</span><span class="params">(key, value []<span class="keyword">byte</span>)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">insert</span><span class="params">(n node, prefix, key []<span class="keyword">byte</span>, value node)</span> <span class="params">(<span class="keyword">bool</span>, node, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">delete</span><span class="params">(n node, prefix, key []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">bool</span>, node, error)</span></span> </span><br></pre></td></tr></table></figure>

<h6 id="解析哈希"><a href="#解析哈希" class="headerlink" title="解析哈希"></a>解析哈希</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">resolveHash</span><span class="params">(n hashNode, prefix []<span class="keyword">byte</span>)</span></span></span><br><span class="line">-&gt;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span> <span class="title">node</span><span class="params">(hash common.Hash)</span> <span class="title">node</span></span></span><br><span class="line">-&gt;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mustDecodeNode</span><span class="params">(hash, buf []<span class="keyword">byte</span>)</span> <span class="title">node</span></span> </span><br><span class="line">-&gt;</span><br><span class="line"><span class="comment">// decodeNode parses the RLP encoding of a trie node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeNode</span><span class="params">(hash, buf []<span class="keyword">byte</span>)</span> <span class="params">(node, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(buf) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, io.ErrUnexpectedEOF</span><br><span class="line">	&#125;</span><br><span class="line">	elems, _, err := rlp.SplitList(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;decode error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> c, _ := rlp.CountValues(elems); c &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		n, err := decodeShort(hash, elems)</span><br><span class="line">		<span class="keyword">return</span> n, wrapError(err, <span class="string">&quot;short&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">17</span>:</span><br><span class="line">		n, err := decodeFull(hash, elems)</span><br><span class="line">		<span class="keyword">return</span> n, wrapError(err, <span class="string">&quot;full&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;invalid number of list elements: %v&quot;</span>, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="将mpt树写入内存"><a href="#将mpt树写入内存" class="headerlink" title="将mpt树写入内存"></a>将mpt树写入内存</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Commit</span><span class="params">(onleaf LeafCallback)</span> <span class="params">(root common.Hash, err error)</span></span> </span><br></pre></td></tr></table></figure>

<h6 id="获取根哈希"><a href="#获取根哈希" class="headerlink" title="获取根哈希"></a>获取根哈希</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">hashRoot</span><span class="params">(db *Database)</span> <span class="params">(node, node, error)</span></span></span><br></pre></td></tr></table></figure>

<h6 id="rlp编码"><a href="#rlp编码" class="headerlink" title="rlp编码"></a>rlp编码</h6><p>database.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *cachedNode)</span> <span class="title">rlp</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node, ok := n.node.(rawNode); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">	&#125;</span><br><span class="line">	blob, err := rlp.EncodeToBytes(n.node)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> blob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="默克尔证明"><a href="#默克尔证明" class="headerlink" title="默克尔证明"></a>默克尔证明</h6><p>proof.go: prove方法用来获取指定 key 的默克尔证明。这个方法会遍历整个 MPT，获取从根节点到叶子节点这条路径上的所有节点的 hash 值列表。对于 key 不匹配的情况，则会返回一个最长匹配的列表。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SecureTrie)</span> <span class="title">Prove</span><span class="params">(key []<span class="keyword">byte</span>, fromLevel <span class="keyword">uint</span>, proofDb ethdb.KeyValueWriter)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.trie.Prove(key, fromLevel, proofDb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Prove</span><span class="params">(key []<span class="keyword">byte</span>, fromLevel <span class="keyword">uint</span>, proofDb ethdb.KeyValueWriter)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Collect all nodes on the path to key.</span></span><br><span class="line">	key = keybytesToHex(key)</span><br><span class="line">	<span class="keyword">var</span> nodes []node</span><br><span class="line">	tn := t.root</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(key) &gt; <span class="number">0</span> &amp;&amp; tn != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> n := tn.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *shortNode:</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(key) &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[:<span class="built_in">len</span>(n.Key)]) &#123;</span><br><span class="line">				<span class="comment">// The trie doesn&#x27;t contain the key.</span></span><br><span class="line">				tn = <span class="literal">nil</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tn = n.Val</span><br><span class="line">				key = key[<span class="built_in">len</span>(n.Key):]</span><br><span class="line">			&#125;</span><br><span class="line">			nodes = <span class="built_in">append</span>(nodes, n)</span><br><span class="line">		<span class="keyword">case</span> *fullNode:</span><br><span class="line">			tn = n.Children[key[<span class="number">0</span>]]</span><br><span class="line">			key = key[<span class="number">1</span>:]</span><br><span class="line">			nodes = <span class="built_in">append</span>(nodes, n)</span><br><span class="line">		<span class="keyword">case</span> hashNode:</span><br><span class="line">			<span class="keyword">var</span> err error</span><br><span class="line">			tn, err = t.resolveHash(n, <span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Error(fmt.Sprintf(<span class="string">&quot;Unhandled trie error: %v&quot;</span>, err))</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%T: invalid node: %v&quot;</span>, tn, tn))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	hasher := newHasher(<span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">defer</span> returnHasherToPool(hasher)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, n := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">		<span class="keyword">if</span> fromLevel &gt; <span class="number">0</span> &#123;</span><br><span class="line">			fromLevel--</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> hn node</span><br><span class="line">		n, hn = hasher.proofHash(n)</span><br><span class="line">		<span class="keyword">if</span> hash, ok := hn.(hashNode); ok || i == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// If the node&#x27;s database encoding is a hash (or is the</span></span><br><span class="line">			<span class="comment">// root node), it becomes a proof element.</span></span><br><span class="line">			enc, _ := rlp.EncodeToBytes(n)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				hash = hasher.hashData(enc)</span><br><span class="line">			&#125;</span><br><span class="line">			proofDb.Put(hash, enc)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> VerifyProof 方法以 roothash，key，proof 证明为参数，验证 key 是否存在于 MPT 的某条路径里，如果 key 确实存在，返回这个节点的索引 i，err 字段是 nil，否则返回 error。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyProof</span><span class="params">(rootHash common.Hash, key []<span class="keyword">byte</span>, proofDb ethdb.KeyValueReader)</span> <span class="params">(value []<span class="keyword">byte</span>, nodes <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	key = keybytesToHex(key)</span><br><span class="line">	wantHash := rootHash</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">		buf, _ := proofDb.Get(wantHash[:])</span><br><span class="line">		<span class="keyword">if</span> buf == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, i, fmt.Errorf(<span class="string">&quot;proof node %d (hash %064x) missing&quot;</span>, i, wantHash)</span><br><span class="line">		&#125;</span><br><span class="line">		n, err := decodeNode(wantHash[:], buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, i, fmt.Errorf(<span class="string">&quot;bad proof node %d: %v&quot;</span>, i, err)</span><br><span class="line">		&#125;</span><br><span class="line">		keyrest, cld := get(n, key)</span><br><span class="line">		<span class="keyword">switch</span> cld := cld.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">// The trie doesn&#x27;t contain the key.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, i, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> hashNode:</span><br><span class="line">			key = keyrest</span><br><span class="line">			<span class="built_in">copy</span>(wantHash[:], cld)</span><br><span class="line">		<span class="keyword">case</span> valueNode:</span><br><span class="line">			<span class="keyword">return</span> cld, i + <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h6><p> MPT 的 key 值实际上有三种编码方法，Raw 编码，Hex 编码，HP 编码，Raw 编码即原始的字节数组，这种方式的问题是它的一个字节的范围很大，fullNode 的子树这么多会影响检索效率，当树节点需要存储到数据库时，会根据16进制来进行编码，Hex 编码和 HP 编码没本质区别，可以理解为 Hex 编码是存在于内存的中间形式，在以太坊的黄皮书了介绍的是 Hex Prefix Encoding，即 HP 编码。 </p>
<p><strong>RAW编码</strong></p>
<p> 原生的 key 字节数组，不做修改，这种方式是 MPT 对外提供 API 的默认方式，如果数据需要插入到树里，Raw 编码需要转换为 Hex 编码。 </p>
<p><strong>Hex编码</strong></p>
<p>Hex 编码用于对内存里的树节点 key 进行编码，当树节点需要持久化到数据库时，Hex 编码被转换为 HP 编码。</p>
<p>具体来说，这个编码的每个字节包含 key 的半个字节，尾部加一个 byte 的『终结符』16，表示这是 hex 格式。节点被加载到内存时 key 使用的是这种编码，因为方便访问。</p>
<p>encoding.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keybytesToHex</span><span class="params">(str []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(str)*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> nibbles = <span class="built_in">make</span>([]<span class="keyword">byte</span>, l)</span><br><span class="line">	<span class="keyword">for</span> i, b := <span class="keyword">range</span> str &#123;</span><br><span class="line">		nibbles[i*<span class="number">2</span>] = b / <span class="number">16</span></span><br><span class="line">		nibbles[i*<span class="number">2</span>+<span class="number">1</span>] = b % <span class="number">16</span></span><br><span class="line">	&#125;</span><br><span class="line">	nibbles[l<span class="number">-1</span>] = <span class="number">16</span></span><br><span class="line">	<span class="keyword">return</span> nibbles</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HP编码</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToCompact</span><span class="params">(hex []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	terminator := <span class="keyword">byte</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> hasTerm(hex) &#123;</span><br><span class="line">		terminator = <span class="number">1</span></span><br><span class="line">		hex = hex[:<span class="built_in">len</span>(hex)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(hex)/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">	buf[<span class="number">0</span>] = terminator &lt;&lt; <span class="number">5</span> <span class="comment">// the flag byte</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(hex)&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">		buf[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; <span class="number">4</span> <span class="comment">// odd flag</span></span><br><span class="line">		buf[<span class="number">0</span>] |= hex[<span class="number">0</span>] <span class="comment">// first nibble is contained in the first byte</span></span><br><span class="line">		hex = hex[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	decodeNibbles(hex, buf[<span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">return</span> buf</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>全称是 Hex Prefix 编码，hex 编码解决了 key 是 keybytes 形式的数据插入 MPT 的问题，但这种方式有数据冗余的问题，对于 shortNode，目前 hex 格式下的 key，长度会是原来 keybytes 格式下的两倍，这一点对于节点的哈希计算影响很大，compact 编码用于对 hex 格式进行优化。compact encoding 的主要思路是将 Hex 格式字符串先恢复到 keybytes 格式，同时加入当前编码的标记位，表示奇偶不同长度的 hex 格式。</p>
<p>具体来说，compact 编码首先会将 hex 尾部标记的 byte 去掉，然后将原来 hex 编码的包含的 key 的半个字节（称为 nibble）一一合并为1 byte，最后如果 hex 格式编码有效长度为奇数，在头部增加 0011xxxx，其中 xxxx 为第一个 nibble，否则在头部增加 00100000。节点在写入数据库时使用的是 compact 编码，因为可以节约磁盘。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/trie%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ckqma5nrw000u0wu72kin9awm" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-reflect反射" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/reflect%E5%8F%8D%E5%B0%84/">(no title)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/reflect%E5%8F%8D%E5%B0%84/" class="article-date"><time datetime="2021-07-02T11:06:38.788Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>反射是指在程序运行期对程序本身进行访问和修改的能力</strong>。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。</p>
<p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p>
<p><strong>Go程序在运行期使用reflect包访问程序的反射信息</strong>。</p>
<p>reflect包实现了运行时反射，允许程序操作任意类型的对象。典型用法是用静态类型interface{}保存一个值，通过调用TypeOf获取其动态类型信息，该函数返回一个Type类型值。调用ValueOf函数返回一个Value类型值，该值代表运行时的数据。Zero接受一个Type类型参数并返回一个代表该类型零值的Value类型值。</p>
<p>Go 程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树（AST）对源码进行扫描后获得这些信息。</p>
<p><img src="./picture/reflect.png"></p>
<p>示例：</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/reflect%E5%8F%8D%E5%B0%84/" data-id="ckqma5nrv000s0wu71uxrg5rv" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-go并发底层原理" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/go%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">(no title)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/go%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="article-date"><time datetime="2021-07-02T11:06:38.687Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="1-DO-NOT-COMMUNICATE-BY-SHARING-MEMORY-INSTEAD-SHARE-MEMORY-BY-COMMUNICATING"><a href="#1-DO-NOT-COMMUNICATE-BY-SHARING-MEMORY-INSTEAD-SHARE-MEMORY-BY-COMMUNICATING" class="headerlink" title="1.DO NOT COMMUNICATE BY SHARING MEMORY; INSTEAD, SHARE MEMORY BY COMMUNICATING."></a>1.DO NOT COMMUNICATE BY SHARING MEMORY; INSTEAD, SHARE MEMORY BY COMMUNICATING.</h5><p>“不要以共享内存的方式来通信，相反，要通过通信来共享内存。”</p>
<p>普通的线程并发模型，就是像Java、C++、或者Python，他们线程间通信都是通过共享内存的方式来进行的。非常典型的方式就是，在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问，因此，在很多时候，衍生出一种方便操作的数据结构，叫做“线程安全的数据结构”。例如Java提供的包”java.util.concurrent”中的数据结构。Go中也实现了传统的线程并发模型。</p>
<p>Go的CSP并发模型，是通过<code>goroutine</code>和<code>channel</code>来实现的。</p>
<ul>
<li><code>goroutine</code> 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。</li>
<li><code>channel</code>是Go语言中各个并发结构体(<code>goroutine</code>)之前的通信机制。 通俗的讲，就是各个<code>goroutine</code>之间通信的”管道“，有点类似于Linux中的管道。</li>
</ul>
<p>2.</p>
<p>一个<strong>M</strong>会对应一个内核线程，一个<strong>M</strong>也会连接一个上下文<strong>P</strong>，一个上下文<strong>P</strong>相当于一个“处理器”，一个上下文连接一个或者多个Goroutine。</p>
<p>每有一个go语句被执行，runqueue队列就在其末尾加入一个goroutine，一旦上下文运行goroutine直到调度点，它会从其runqueue中弹出goroutine，设置堆栈和指令指针并开始运行goroutine。</p>
<p><img src="./picture/goroutine.png"></p>
<p><img src="./picture/GO2.png"></p>
<p>3.</p>
<p>在Goroutine中则不需这些额外的开销，所以一个Golang的程序中可以支持10w级别的Goroutine。</p>
<p>每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少（<em>goroutine：</em>2KB ，线程：8MB）</p>
<p>4.</p>
<p>每个P中的<code>Goroutine</code>不同导致他们运行的效率和时间也不同，在一个有很多P和M的环境中，不能让一个P跑完自身的<code>Goroutine</code>就没事可做了，因为或许其他的P有很长的<code>goroutine</code>队列要跑，得需要均衡。<br>该如何解决呢？</p>
<p>Go的做法倒也直接，从其他P中偷一半！</p>
<p><img src="./picture/go3.png"></p>
<p>5.P的必要性</p>
<p>我的理解是，如果没有P，当内核线程M0执行类似于同时执行代码和系统调用被阻塞的操作如syscall时，就会产生上下文丢失，有了P就可以新建一个内核线程并把上下文环境P分配给新的M1，而如果没有P的话，此时执行到一半的各类上下文环境和资源就会丢失。</p>
<p><img src="./picture/go5.png"></p>
<p>6.缺点：调度分配不公平</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/go%E5%B9%B6%E5%8F%91%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" data-id="ckqma5nrp000k0wu70aznb0rb" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-go反射" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/go%E5%8F%8D%E5%B0%84/">(no title)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/go%E5%8F%8D%E5%B0%84/" class="article-date"><time datetime="2021-07-02T11:06:38.686Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。也就是说，这类应用通过采用某种机制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。</p>
<p>每种语言的反射模型都不同，并且有些语言根本不支持反射。Golang语言实现了反射，反射机制就是在运行时动态的调用对象的方法和属性，官方自带的reflect包就是反射相关的，只要包含这个包就可以使用。</p>
<p>Golang的gRPC也是通过反射实现的。</p>
<p>Golang的官方包 reflect 实现了运行时反射（run-time reflection）。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/go%E5%8F%8D%E5%B0%84/" data-id="ckqma5nrn000j0wu713jq1cse" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  
    <article id="post-golang基础：big包和位运算" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/golang%E5%9F%BA%E7%A1%80%EF%BC%9Abig%E5%8C%85%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/">(no title)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/golang%E5%9F%BA%E7%A1%80%EF%BC%9Abig%E5%8C%85%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/" class="article-date"><time datetime="2021-07-02T11:06:38.684Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Big包：整数高精度计算"><a href="#Big包：整数高精度计算" class="headerlink" title="Big包：整数高精度计算"></a>Big包：整数高精度计算</h4><p> 实际开发中，对于超出 int64 或者 uint64 类型的大数进行计算时，如果对精度没有要求，使用 float32 或者 float64 就可以胜任，但如果对精度有严格要求的时候，我们就不能使用浮点数了，因为浮点数在内存中只能被近似的表示。</p>
<p>Go语言中 math/big 包实现了大数字的多精度计算，支持 Int（有符号整数）、Rat（有理数）和 Float（浮点数）等数字类型。</p>
<p>这些类型可以实现任意位数的数字，只要内存足够大，但缺点是需要更大的内存和处理开销，这使得它们使用起来要比内置的数字类型慢很多。 </p>
<p>常用定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">struct</span> &#123;</span><br><span class="line">	neg <span class="keyword">bool</span> <span class="comment">// sign</span></span><br><span class="line">	abs nat  <span class="comment">// absolute value of the integer</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//newInt函数只支持输入int64类型整数值返回big.Int，如果不是int64类型（如int类型），需要转换成int64再进行运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInt</span><span class="params">(x <span class="keyword">int64</span>)</span> *<span class="title">Int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">new</span>(Int).SetInt64(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *Int)</span> <span class="title">Set</span><span class="params">(x *Int)</span> *<span class="title">Int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> z != x &#123;</span><br><span class="line">		z.abs = z.abs.set(x.abs)</span><br><span class="line">		z.neg = x.neg</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *Int)</span> <span class="title">Abs</span><span class="params">(x *Int)</span> *<span class="title">Int</span></span> &#123;</span><br><span class="line">	z.Set(x)</span><br><span class="line">	z.neg = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add sets z to the sum x+y and returns z.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(z *Int)</span> <span class="title">Add</span><span class="params">(x, y *Int)</span> *<span class="title">Int</span></span> &#123;</span><br><span class="line">	neg := x.neg</span><br><span class="line">	<span class="keyword">if</span> x.neg == y.neg &#123;</span><br><span class="line">		<span class="comment">// x + y == x + y</span></span><br><span class="line">		<span class="comment">// (-x) + (-y) == -(x + y)</span></span><br><span class="line">		z.abs = z.abs.add(x.abs, y.abs)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// x + (-y) == x - y == -(y - x)</span></span><br><span class="line">		<span class="comment">// (-x) + y == y - x == -(x - y)</span></span><br><span class="line">		<span class="keyword">if</span> x.abs.cmp(y.abs) &gt;= <span class="number">0</span> &#123;</span><br><span class="line">			z.abs = z.abs.sub(x.abs, y.abs)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			neg = !neg</span><br><span class="line">			z.abs = z.abs.sub(y.abs, x.abs)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	z.neg = <span class="built_in">len</span>(z.abs) &gt; <span class="number">0</span> &amp;&amp; neg <span class="comment">// 0 has no sign</span></span><br><span class="line">	<span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于int64,int32,int16,uint的补充说明：</p>
<p>Int16  意思是16位整数(16bit integer)，相当于short  占2个字节   -32768 ~ 32767</p>
<p>Int32  意思是32位整数(32bit integer), 相当于 int      占4个字节   -2147483648 ~ 2147483647</p>
<p>Int64  意思是64位整数(64bit interger), 相当于 long long   占8个字节   -9223372036854775808 ~ 9223372036854775807</p>
<p>Byte  相当于byte(unsigned char)   0 ~ 255</p>
<p>WORD 等于  unsigned short     0 ~ 65535</p>
<p>uint则是不带符号的，表示范围是：2^32即0到4294967295。</p>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>位运算涉及到底层优化，一些算法及源码可能会经常遇见。</p>
<p>常用的位运算:</p>
<blockquote>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&amp;      与 AND</span><br><span class="line"></span><br><span class="line">|      或OR</span><br><span class="line"></span><br><span class="line">^      异或XOR，一元运算表示按位取反</span><br><span class="line"></span><br><span class="line">&amp;^     位清空 (AND NOT)</span><br><span class="line"></span><br><span class="line">&lt;&lt;     左移</span><br><span class="line"></span><br><span class="line">&gt;&gt;	 右移</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h4 id="关于Byte"><a href="#关于Byte" class="headerlink" title="关于Byte"></a>关于Byte</h4><p> 在go里面，byte是uint8的别名 。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/golang%E5%9F%BA%E7%A1%80%EF%BC%9Abig%E5%8C%85%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97/" data-id="ckqma5nrl000i0wu7c98vfwur" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      

    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="active"><span class="page-number">2</span></li><li><a class="page-number" href="/page/3/">3</a></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-next" rel="next" href="/page/3/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p> Nice papers collected in the field of <em>AI</em>, <em>Apllied Cryptography</em> and <em>Blockchain</em>, records of some computer technologies, and personal thoughts.  If you are inteseted in my field, feel free to contact me. (Wechat: mzliu_xdu) </p>

</div>


  


  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list" itemprop="keywords"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/go/" rel="tag">go</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/golang/" rel="tag">golang</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/hyperledger-fabric/" rel="tag">hyperledger fabric</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/java/" rel="tag">java</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/paper-notes/" rel="tag">paper notes</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/go/" style="font-size: 20px;">go</a> <a href="/tags/golang/" style="font-size: 10px;">golang</a> <a href="/tags/hyperledger-fabric/" style="font-size: 20px;">hyperledger fabric</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/paper-notes/" style="font-size: 10px;">paper notes</a> <a href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" style="font-size: 10px;">以太坊</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 10px;">区块链</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/07/">July 2021</a><span class="sidebar-module-list-count">28</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/07/">July 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">February 2020</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">August 2019</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2021/07/02/%E9%97%AE%E9%A2%98/">(no title)</a>
        </li>
      
        <li>
          <a href="/2021/07/02/%E7%8A%B6%E6%80%81%EF%BC%9B%E7%8A%B6%E6%80%81%E6%A0%91%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">(no title)</a>
        </li>
      
        <li>
          <a href="/2021/07/02/%E5%90%8E%E7%AB%AF%E6%96%87%E6%A1%A3/">(no title)</a>
        </li>
      
        <li>
          <a href="/2021/07/02/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8E%E7%AB%AF%E8%AF%B4%E6%98%8E/">(no title)</a>
        </li>
      
        <li>
          <a href="/2021/07/02/%E5%8C%BA%E5%9D%97%E4%B8%AD%E7%9A%84%E4%BA%A4%E6%98%93%E5%92%8C%E5%9B%9E%E6%89%A7%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">(no title)</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2021 Mingzhe Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>




<script src="/js/script.js"></script>


</body>
</html>
