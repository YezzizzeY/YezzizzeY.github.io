<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Yezzi Tech</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Nice paper collection, computer tech records, and personal thoughts">
<meta property="og:type" content="website">
<meta property="og:title" content="Yezzi Tech">
<meta property="og:url" content="https://yezzi.tech/page/2/index.html">
<meta property="og:site_name" content="Yezzi Tech">
<meta property="og:description" content="Nice paper collection, computer tech records, and personal thoughts">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Mingzhe Liu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Yezzi Tech" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="/css/styles.css">

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">Yezzi Tech</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-BlockChain-Papers-in-Top-Security-Conferences" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/BlockChain-Papers-in-Top-Security-Conferences/">BlockChain Papers in Top Security Conferences</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/BlockChain-Papers-in-Top-Security-Conferences/" class="article-date"><time datetime="2021-07-02T10:37:40.000Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Summarize blockchian papers in IEEE S&amp;P 2021, NDSS 2021, USENIX Security 2021 and CCS 2020</p>
        
          <p class="article-more-link">
            <a class="btn btn-primary" href="/2021/07/02/BlockChain-Papers-in-Top-Security-Conferences/#more">Read More</a>
          </p>
        
      
    </div>

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/BlockChain-Papers-in-Top-Security-Conferences/" data-id="ckqol3obx001znwu77w1a09h2" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/paper-notes/" rel="tag">paper notes</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-以太坊交易池" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%B1%A0/">以太坊交易池代码分析 part1(共2部分)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%B1%A0/" class="article-date"><time datetime="2021-07-02T10:37:40.000Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h4 id="交易池"><a href="#交易池" class="headerlink" title="交易池"></a>交易池</h4><p>txpool主要用来存放当前提交的等待写入区块的交易，有远端的和本地的。</p>
<p>交易池包含所有已知的交易。交易被本地提交或从网络接收时进入交易池，交易在被区块链收纳后退出交易池。</p>
<p>交易池把交易分成两种：可处理交易:pending，已加入交易池但不可以执行:queue。交易在被接收和处理的过程中在两种状态之间转换。</p>
<p><img src="./picture/9.png"></p>
<h4 id="设置信息"><a href="#设置信息" class="headerlink" title="设置信息"></a>设置信息</h4><h6 id="交易池-1"><a href="#交易池-1" class="headerlink" title="交易池"></a>交易池</h6><p>交易池的主要内容有：区块链（主要实现了当前和从前的区块索引，和根据之前一个状态树的树根实现之前某处的stateDB的索引）、状态树StateDB，交易列表、queue交易和pending状态的交易、本地账户列表、本地交易存储</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TxPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	config      TxPoolConfig</span><br><span class="line">	chainconfig *params.ChainConfig</span><br><span class="line">	chain       blockChain</span><br><span class="line">	gasPrice    *big.Int</span><br><span class="line">	txFeed      event.Feed</span><br><span class="line">	scope       event.SubscriptionScope</span><br><span class="line">	signer      types.Signer</span><br><span class="line">	mu          sync.RWMutex</span><br><span class="line"></span><br><span class="line">	istanbul <span class="keyword">bool</span> <span class="comment">// Fork indicator whether we are in the istanbul stage.</span></span><br><span class="line"></span><br><span class="line">	currentState  *state.StateDB <span class="comment">// Current state in the blockchain head</span></span><br><span class="line">	pendingNonces *txNoncer      <span class="comment">// Pending state tracking virtual nonces</span></span><br><span class="line">	currentMaxGas <span class="keyword">uint64</span>         <span class="comment">// Current gas limit for transaction caps</span></span><br><span class="line"></span><br><span class="line">	locals  *accountSet <span class="comment">// Set of local transaction to exempt from eviction rules</span></span><br><span class="line">	journal *txJournal  <span class="comment">// Journal of local transaction to back up to disk</span></span><br><span class="line"></span><br><span class="line">	pending <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// All currently processable transactions</span></span><br><span class="line">	queue   <span class="keyword">map</span>[common.Address]*txList   <span class="comment">// Queued but non-processable transactions</span></span><br><span class="line">	beats   <span class="keyword">map</span>[common.Address]time.Time <span class="comment">// Last heartbeat from each known account</span></span><br><span class="line">	all     *txLookup                    <span class="comment">// All transactions to allow lookups</span></span><br><span class="line">	priced  *txPricedList                <span class="comment">// All transactions sorted by price</span></span><br><span class="line"></span><br><span class="line">	chainHeadCh     <span class="keyword">chan</span> ChainHeadEvent</span><br><span class="line">	chainHeadSub    event.Subscription</span><br><span class="line">	reqResetCh      <span class="keyword">chan</span> *txpoolResetRequest</span><br><span class="line">	reqPromoteCh    <span class="keyword">chan</span> *accountSet</span><br><span class="line">	queueTxEventCh  <span class="keyword">chan</span> *types.Transaction</span><br><span class="line">	reorgDoneCh     <span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	reorgShutdownCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">// requests shutdown of scheduleReorgLoop</span></span><br><span class="line">	wg              sync.WaitGroup <span class="comment">// tracks loop, scheduleReorgLoop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>config：配置文件</li>
<li>gasPrice：最低的gasprice限制</li>
<li>txFeed：通过txFeed来订阅txPool的消息</li>
<li>chainHeadCh：订阅了区块头的信息，当新的区块头生成时这里会收到通知</li>
<li>chainHeadSub：区块头消息的订阅器</li>
<li>signer：封装了事务签名处理</li>
<li>currentMaxGas：目前交易的上限GasLimit</li>
<li>locals：本地交易免除驱逐规则</li>
<li>journal：本地交易会写入磁盘</li>
<li>pending：正在处理的交易列表</li>
<li>queue：等待处理的交易列表</li>
<li>beats：每一个一直账号的最后一次心跳信息时间，用map存储</li>
<li>all：可以查找到所有交易</li>
<li>priced：按照价格排序的交易</li>
</ul>
<h6 id="交易池配置"><a href="#交易池配置" class="headerlink" title="交易池配置"></a>交易池配置</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TxPoolConfig are the configuration parameters of the transaction pool.</span></span><br><span class="line"><span class="keyword">type</span> TxPoolConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	Locals    []common.Address <span class="comment">// Addresses that should be treated by default as local</span></span><br><span class="line">	NoLocals  <span class="keyword">bool</span>             <span class="comment">// Whether local transaction handling should be disabled</span></span><br><span class="line">	Journal   <span class="keyword">string</span>           <span class="comment">// Journal of local transactions to survive node restarts</span></span><br><span class="line">	Rejournal time.Duration    <span class="comment">// Time interval to regenerate the local transaction journal</span></span><br><span class="line"></span><br><span class="line">	PriceLimit <span class="keyword">uint64</span> <span class="comment">// Minimum gas price to enforce for acceptance into the pool</span></span><br><span class="line">	PriceBump  <span class="keyword">uint64</span> <span class="comment">// Minimum price bump percentage to replace an already existing transaction (nonce)</span></span><br><span class="line"></span><br><span class="line">	AccountSlots <span class="keyword">uint64</span> <span class="comment">// Number of executable transaction slots guaranteed per account</span></span><br><span class="line">	GlobalSlots  <span class="keyword">uint64</span> <span class="comment">// Maximum number of executable transaction slots for all accounts</span></span><br><span class="line">	AccountQueue <span class="keyword">uint64</span> <span class="comment">// Maximum number of non-executable transaction slots permitted per account</span></span><br><span class="line">	GlobalQueue  <span class="keyword">uint64</span> <span class="comment">// Maximum number of non-executable transaction slots for all accounts</span></span><br><span class="line"></span><br><span class="line">	Lifetime time.Duration <span class="comment">// Maximum amount of time non-executable transaction are queued</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Locals: 定义了一组视为local交易的账户地址。任何来自此清单的交易均被视为 local 交易。</li>
<li>NoLocals: 是否禁止local交易处理。默认为 fasle,允许 local 交易。如果禁止，则来自 local 的交易均视为 remote 交易处理。</li>
<li>Journal： 存储local交易记录的文件名，默认是 <code>./transactions.rlp</code>。</li>
<li>Rejournal：定期将local交易存储文件中的时间间隔。默认为每小时一次。</li>
<li>PriceLimit： remote交易进入交易池的最低 Price 要求。此设置对 local 交易无效。默认值1。</li>
<li>PriceBump：替换交易时所要求的价格上调涨幅比例最低要求。任何低于要求的替换交易均被拒绝。</li>
<li>AccountSlots： 当交易池中可执行交易（是已在等待矿工打包的交易）量超标时，允许每个账户可以保留在交易池最低交易数。默认值是 16 笔。</li>
<li>GlobalSlots： 交易池中所允许的可执行交易量上限，高于上限时将释放部分交易。默认是 4096 笔交易。</li>
<li>AccountQueue：交易池中单个账户非可执行交易上限，默认是64笔。</li>
<li>GlobalQueue： 交易池中所有非可执行交易上限，默认1024 笔。</li>
<li>Lifetime： 允许 remote 的非可执行交易可在交易池存活的最长时间。交易池每分钟检查一次，一旦发现有超期的remote 账户，则移除该账户下的所有非可执行交易。默认为3小时。 </li>
</ul>
<h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><p>开启交易池后，以太坊开启一个goroutine执行loop函数用来监听主要事件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">loop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ev := &lt;-pool.chainHeadCh</span><br><span class="line">    <span class="keyword">case</span> &lt;-pool.chainHeadSub.Err()</span><br><span class="line">    <span class="keyword">case</span> &lt;-report.C</span><br><span class="line">    <span class="keyword">case</span> &lt;-evict.C</span><br><span class="line">    <span class="keyword">case</span> &lt;-journal.C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同时开启一个goroutine来调度reset和promoteExecutables事件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//requestPromoteExecutables requests a pool reset to the new head block.</span></span><br><span class="line"><span class="comment">//The returned channel is closed when the reset has occurred.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">requestReset</span><span class="params">(oldHead *types.Header, newHead *types.Header)</span> <span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> pool.reqResetCh &lt;- &amp;txpoolResetRequest&#123;oldHead, newHead&#125;:</span><br><span class="line">		<span class="keyword">return</span> &lt;-pool.reorgDoneCh</span><br><span class="line">	<span class="keyword">case</span> &lt;-pool.reorgShutdownCh:</span><br><span class="line">		<span class="keyword">return</span> pool.reorgShutdownCh</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//requestPromoteExecutables requests transaction promotion checks for the given addresses.</span></span><br><span class="line"><span class="comment">//The returned channel is closed when the promotion checks have occurred.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">requestPromoteExecutables</span><span class="params">(set *accountSet)</span> <span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> pool.reqPromoteCh &lt;- set:</span><br><span class="line">		<span class="keyword">return</span> &lt;-pool.reorgDoneCh</span><br><span class="line">	<span class="keyword">case</span> &lt;-pool.reorgShutdownCh:</span><br><span class="line">		<span class="keyword">return</span> pool.reorgShutdownCh</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (pool *TxPool) scheduleReorgLoop() &#123;</span><br><span class="line">case req := &lt;-pool.reqResetCh</span><br><span class="line">case req := &lt;-pool.reqPromoteCh</span><br><span class="line">case tx := &lt;-pool.queueTxEventCh</span><br><span class="line">case &lt;-curDone</span><br><span class="line">case &lt;-pool.reorgShutdownCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本地交易处理"><a href="#本地交易处理" class="headerlink" title="本地交易处理"></a>本地交易处理</h4><p>为了不丢失未完成的本地交易，以太坊交易池通过 journal 文件存储和管理当前交易池中的本地交易，并定期更新存储。</p>
<p>启动交易池时根据配置开启本地交易存储</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If local transactions and journaling is enabled, load from disk</span></span><br><span class="line"><span class="keyword">if</span> !config.NoLocals &amp;&amp; config.Journal != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">	pool.journal = newTxJournal(config.Journal)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := pool.journal.load(pool.AddLocals); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Failed to load transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := pool.journal.rotate(pool.local()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Failed to rotate transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在新的local 交易进入交易池时，将被实时写入 journal 文件。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">journalTx</span><span class="params">(from common.Address, tx *types.Transaction)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Only journal if it&#x27;s enabled and the transaction is local</span></span><br><span class="line">	<span class="keyword">if</span> pool.journal == <span class="literal">nil</span> || !pool.locals.contains(from) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := pool.journal.insert(tx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Failed to journal local transaction&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 定期对 journal 文件执行 <code>rotate</code>，将交易池中的本地交易写入journal文件，并丢弃旧数据。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-journal.C:</span><br><span class="line">			<span class="keyword">if</span> pool.journal != <span class="literal">nil</span> &#123;</span><br><span class="line">				pool.mu.Lock()</span><br><span class="line">				<span class="keyword">if</span> err := pool.journal.rotate(pool.local()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Warn(<span class="string">&quot;Failed to rotate local tx journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">				&#125;</span><br><span class="line">				pool.mu.Unlock()</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p> 在交易池首次启动 journal 时，将主动将该文件已存储的交易加载到交易池。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(journal *txJournal)</span> <span class="title">load</span><span class="params">(add <span class="keyword">func</span>([]*types.Transaction)</span> []<span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Skip the parsing if the journal file doesn&#x27;t exist at all</span></span><br><span class="line">	<span class="keyword">if</span> _, err := os.Stat(journal.path); os.IsNotExist(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Open the journal for loading any past transactions</span></span><br><span class="line">	input, err := os.Open(journal.path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> input.Close()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="交易进池"><a href="#交易进池" class="headerlink" title="交易进池"></a>交易进池</h4><p>交易增加add函数</p>
<p>func (pool *TxPool) add(tx *types.Transaction, local bool) (replaced bool, err error)</p>
<p>由一下几个部分组成：</p>
<p>先检查交易是否已经在交易池，如果是，则抛弃</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash := tx.Hash()</span><br><span class="line">	<span class="keyword">if</span> pool.all.Get(hash) != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Trace(<span class="string">&quot;Discarding already known transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		knownTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, ErrAlreadyKnown</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>验证交易有效性（在之后会解析这个函数）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := pool.validateTx(tx, local); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Trace(<span class="string">&quot;Discarding invalid transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	invalidTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看交易池是否已经满，如果满了，则抛弃价格低且非本地的交易。主要调用removeTx函数进行删除交易操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">uint64</span>(pool.all.Count()) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue &#123;</span><br><span class="line">	<span class="comment">// If the new transaction is underpriced, don&#x27;t accept it</span></span><br><span class="line">	<span class="keyword">if</span> !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) &#123;</span><br><span class="line">		log.Trace(<span class="string">&quot;Discarding underpriced transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;price&quot;</span>, tx.GasPrice())</span><br><span class="line">		underpricedTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, ErrUnderpriced</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// New transaction is better than our worse ones, make room for it</span></span><br><span class="line">	drop := pool.priced.Discard(pool.all.Slots()-<span class="keyword">int</span>(pool.config.GlobalSlots+pool.config.GlobalQueue)+numSlots(tx), pool.locals)</span><br><span class="line">	<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drop &#123;</span><br><span class="line">		log.Trace(<span class="string">&quot;Discarding freshly underpriced transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, tx.Hash(), <span class="string">&quot;price&quot;</span>, tx.GasPrice())</span><br><span class="line">		underpricedTxMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		pool.removeTx(tx.Hash(), <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果关联到该账户的可执行队列中存在一个相同 nonce 的交易时，需要进一步识别是否能替换。</p>
<p>以太坊早起的默认设计是，只要价格(gasPrice)高于原交易，则允许替换。但是17年7月底在 <a target="_blank" rel="noopener" href="https://github.com/ethereum/go-ethereum/pull/15401">#15401</a>被改进。人们愿意支付更多手续费的原因有两种情况，一是急于处理交易，但如果真是紧急交易，那么在发送交易之处，会使用高于推荐的gasprice来处理交易。另一种情况时，以太坊价格下跌，人们愿意支付更多手续费。上调多少手续费是合理的呢？以太币下跌10%，那么便可以上调10%的手续费，毕竟对于用户来说，手续费的面值是一样的。交易池的默认配置（pool.config.PriceBump）是10%，只有上调10%手续费的交易才允许替换掉已在等待执行的交易。一旦可以替换，则替换掉旧交易，移除旧交易，并将交易同步存储到 all 交易内存池中。  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from, _ := types.Sender(pool.signer, tx) <span class="comment">// already validated</span></span><br><span class="line"><span class="keyword">if</span> list := pool.pending[from]; list != <span class="literal">nil</span> &amp;&amp; list.Overlaps(tx) &#123;</span><br><span class="line">	<span class="comment">// Nonce already pending, check if required price bump is met</span></span><br><span class="line">	inserted, old := list.Add(tx, pool.config.PriceBump)</span><br><span class="line">	<span class="keyword">if</span> !inserted &#123;</span><br><span class="line">		pendingDiscardMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, ErrReplaceUnderpriced</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// New transaction is better, replace old one</span></span><br><span class="line">	<span class="keyword">if</span> old != <span class="literal">nil</span> &#123;</span><br><span class="line">		pool.all.Remove(old.Hash())</span><br><span class="line">		pool.priced.Removed(<span class="number">1</span>)</span><br><span class="line">		pendingReplaceMeter.Mark(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	pool.all.Add(tx)</span><br><span class="line">	pool.priced.Put(tx)</span><br><span class="line">	pool.journalTx(from, tx)</span><br><span class="line">	pool.queueTxEvent(tx)</span><br><span class="line">	log.Trace(<span class="string">&quot;Pooled new executable transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;from&quot;</span>, from, <span class="string">&quot;to&quot;</span>, tx.To())</span><br><span class="line">	<span class="keyword">return</span> old != <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该交易不需要替代可执行交易，则放入不可执行交易中。在进入非可执行队列之前，也要检查是否需要替换掉相同 nonce 的交易(enqueueTx)。 ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New transaction isn&#x27;t replacing a pending one, push into queue</span></span><br><span class="line">replaced, err = pool.enqueueTx(hash, tx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对交易检查是否为本地交易。如果是本地交易，则先检查本地账户列表是否有交易from的地址，如没有则添加。之后把交易加入本地交易列表中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark local addresses and journal local transactions</span></span><br><span class="line"><span class="keyword">if</span> local &#123;</span><br><span class="line">	<span class="keyword">if</span> !pool.locals.contains(from) &#123;</span><br><span class="line">		log.Info(<span class="string">&quot;Setting new local account&quot;</span>, <span class="string">&quot;address&quot;</span>, from)</span><br><span class="line">		pool.locals.add(from)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> local || pool.locals.contains(from) &#123;</span><br><span class="line">	localGauge.Inc(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">pool.journalTx(from, tx)</span><br></pre></td></tr></table></figure>

<h4 id="交易有效性检验"><a href="#交易有效性检验" class="headerlink" title="交易有效性检验"></a>交易有效性检验</h4><p>func (pool *TxPool) validateTx(tx *types.Transaction, local bool)解释如下：</p>
<p>首先检查交易大小不能过大</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">uint64</span>(tx.Size()) &gt; txMaxSize &#123;</span><br><span class="line">	<span class="keyword">return</span> ErrOversizedData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交易的金额不能为负数：理论上因为交易经过RLP编码不能处理负数，但如通过RPC直接发送交易则有这种错误的可能性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tx.Value().Sign() &lt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ErrNegativeValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交易的GAS费用不能超过区块的gas上限</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pool.currentMaxGas &lt; tx.Gas() &#123;   <span class="keyword">return</span> ErrGasLimit&#125;</span><br></pre></td></tr></table></figure>

<p>观察能否解析签名信息 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from, err := types.Sender(pool.signer, tx)<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;   <span class="keyword">return</span> ErrInvalidSender&#125;</span><br></pre></td></tr></table></figure>

<p>本地交易是否低于了最低gas费用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local = local || pool.locals.contains(from) <span class="comment">// account may be local even if the transaction arrived from the network</span></span><br><span class="line"><span class="keyword">if</span> !local &amp;&amp; pool.gasPrice.Cmp(tx.GasPrice()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ErrUnderpriced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查nonce值是否高于交易者的nonce值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pool.currentState.GetNonce(from) &gt; tx.Nonce() &#123;   <span class="keyword">return</span> ErrNonceTooLow&#125;</span><br></pre></td></tr></table></figure>

<p>检查交易者剩余钱够不够交易的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> pool.currentState.GetBalance(from).Cmp(tx.Cost()) &lt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ErrInsufficientFunds</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查交易设置的gas费用不能少于预估的最小费用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intrGas, err := IntrinsicGas(tx.Data(), tx.To() == <span class="literal">nil</span>, pool.homestead)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> tx.Gas() &lt; intrGas &#123;</span><br><span class="line">   <span class="keyword">return</span> ErrIntrinsicGas</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="交易池更新"><a href="#交易池更新" class="headerlink" title="交易池更新"></a>交易池更新</h4><p>每当收到交易池更新信号的时候都会开启一个goroutine执行下runReorg函数，具体可分为交易池重置，交易池升级，交易池降级三个步骤。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">runReorg</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, reset *txpoolResetRequest, dirtyAccounts *accountSet, events <span class="keyword">map</span>[common.Address]*txSortedMap)</span></span></span><br></pre></td></tr></table></figure>

<h6 id="交易池重置"><a href="#交易池重置" class="headerlink" title="交易池重置"></a><strong>交易池重置</strong></h6><p>什么时候要执行交易池重置操作呢？分别是 创建交易池：NewTxPool；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTxPool</span><span class="params">(config TxPoolConfig, chainconfig *params.ChainConfig, chain blockChain)</span> *<span class="title">TxPool</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">pool.reset(<span class="literal">nil</span>, chain.CurrentBlock().Header())</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收到信号时：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Launch next background reorg if needed</span></span><br><span class="line">		<span class="keyword">if</span> curDone == <span class="literal">nil</span> &amp;&amp; launchNextRun &#123;</span><br><span class="line">			<span class="comment">// Run the background reorg and announcements</span></span><br><span class="line">            <span class="comment">// 在这里执行的reset操作，执行完操作后把reset又重新建了一个，以便接受下次信号并执行相关操作</span></span><br><span class="line">			<span class="keyword">go</span> pool.runReorg(nextDone, reset, dirtyAccounts, queuedEvents)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare everything for the next round of reorg</span></span><br><span class="line">			curDone, nextDone = nextDone, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			launchNextRun = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">			reset, dirtyAccounts = <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">			queuedEvents = <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]*txSortedMap)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> req := &lt;-pool.reqResetCh:</span><br><span class="line">			<span class="comment">// Reset request: update head if request is already pending.</span></span><br><span class="line">			<span class="keyword">if</span> reset == <span class="literal">nil</span> &#123;</span><br><span class="line">				reset = req</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				reset.newHead = req.newHead</span><br><span class="line">			&#125;</span><br><span class="line">			launchNextRun = <span class="literal">true</span></span><br><span class="line">			pool.reorgDoneCh &lt;- nextDone</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-curDone:</span><br><span class="line">			curDone = <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>func (pool *TxPool) reset(oldHead, newHead *types.Header)解释如下：</p>
<p>找到由于规范链更新而作废的交易：新区快头的父区块不等于老区块，说明新老区块不在同一条链。如果新头区块和旧头区块相差大于64，则所有交易不必回退到交易池。如果旧链的头区块大于新链的头区块高度，旧链向后退并回收所有回退的交易。如果新链的头区块大于旧链的头区块，新链后退并回收交易。当新旧链到达同一高度的时候同时回退，知道找到共同的父节点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> oldHead != <span class="literal">nil</span> &amp;&amp; oldHead.Hash() != newHead.ParentHash &#123;</span><br><span class="line">	<span class="comment">// If the reorg is too deep, avoid doing it (will happen during fast sync)</span></span><br><span class="line">	oldNum := oldHead.Number.Uint64()</span><br><span class="line">	newNum := newHead.Number.Uint64()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> depth := <span class="keyword">uint64</span>(math.Abs(<span class="keyword">float64</span>(oldNum) - <span class="keyword">float64</span>(newNum))); depth &gt; <span class="number">64</span> &#123;</span><br><span class="line">		log.Debug(<span class="string">&quot;Skipping deep transaction reorg&quot;</span>, <span class="string">&quot;depth&quot;</span>, depth)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Reorg seems shallow enough to pull in all transactions into memory</span></span><br><span class="line">		<span class="keyword">var</span> discarded, included types.Transactions</span><br><span class="line">		<span class="keyword">var</span> (</span><br><span class="line">			rem = pool.chain.GetBlock(oldHead.Hash(), oldHead.Number.Uint64())</span><br><span class="line">			add = pool.chain.GetBlock(newHead.Hash(), newHead.Number.Uint64())</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> rem == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// This can happen if a setHead is performed, where we simply discard the old</span></span><br><span class="line">			<span class="comment">// head from the chain.</span></span><br><span class="line">			<span class="comment">// If that is the case, we don&#x27;t have the lost transactions any more, and</span></span><br><span class="line">			<span class="comment">// there&#x27;s nothing to add</span></span><br><span class="line">			<span class="keyword">if</span> newNum &lt; oldNum &#123;</span><br><span class="line">				<span class="comment">// If the reorg ended up on a lower number, it&#x27;s indicative of setHead being the cause</span></span><br><span class="line">				log.Debug(<span class="string">&quot;Skipping transaction reset caused by setHead&quot;</span>,</span><br><span class="line">					<span class="string">&quot;old&quot;</span>, oldHead.Hash(), <span class="string">&quot;oldnum&quot;</span>, oldNum, <span class="string">&quot;new&quot;</span>, newHead.Hash(), <span class="string">&quot;newnum&quot;</span>, newNum)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// If we reorged to a same or higher number, then it&#x27;s not a case of setHead</span></span><br><span class="line">				log.Warn(<span class="string">&quot;Transaction pool reset with missing oldhead&quot;</span>,</span><br><span class="line">					<span class="string">&quot;old&quot;</span>, oldHead.Hash(), <span class="string">&quot;oldnum&quot;</span>, oldNum, <span class="string">&quot;new&quot;</span>, newHead.Hash(), <span class="string">&quot;newnum&quot;</span>, newNum)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> rem.NumberU64() &gt; add.NumberU64() &#123;</span><br><span class="line">			discarded = <span class="built_in">append</span>(discarded, rem.Transactions()...)</span><br><span class="line">			<span class="keyword">if</span> rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()<span class="number">-1</span>); rem == <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Unrooted old chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, oldHead.Number, <span class="string">&quot;hash&quot;</span>, oldHead.Hash())</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> add.NumberU64() &gt; rem.NumberU64() &#123;</span><br><span class="line">			included = <span class="built_in">append</span>(included, add.Transactions()...)</span><br><span class="line">			<span class="keyword">if</span> add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()<span class="number">-1</span>); add == <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Unrooted new chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, newHead.Number, <span class="string">&quot;hash&quot;</span>, newHead.Hash())</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> rem.Hash() != add.Hash() &#123;</span><br><span class="line">			discarded = <span class="built_in">append</span>(discarded, rem.Transactions()...)</span><br><span class="line">			<span class="keyword">if</span> rem = pool.chain.GetBlock(rem.ParentHash(), rem.NumberU64()<span class="number">-1</span>); rem == <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Unrooted old chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, oldHead.Number, <span class="string">&quot;hash&quot;</span>, oldHead.Hash())</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			included = <span class="built_in">append</span>(included, add.Transactions()...)</span><br><span class="line">			<span class="keyword">if</span> add = pool.chain.GetBlock(add.ParentHash(), add.NumberU64()<span class="number">-1</span>); add == <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Error(<span class="string">&quot;Unrooted new chain seen by tx pool&quot;</span>, <span class="string">&quot;block&quot;</span>, newHead.Number, <span class="string">&quot;hash&quot;</span>, newHead.Hash())</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		reinject = types.TxDifference(discarded, included)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Initialize the internal state to the current head</span></span><br><span class="line"><span class="keyword">if</span> newHead == <span class="literal">nil</span> &#123;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>给交易池设置最新的世界状态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">statedb, err := pool.chain.StateAt(newHead.Root)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Error(<span class="string">&quot;Failed to reset txpool state&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交易池参数设置</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pool.currentState = statedb</span><br><span class="line">pool.pendingNonces = newTxNoncer(statedb)</span><br><span class="line">pool.currentMaxGas = newHead.GasLimit</span><br></pre></td></tr></table></figure>

<p>把旧链回退的交易放回交易池</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log.Debug(<span class="string">&quot;Reinjecting stale transactions&quot;</span>, <span class="string">&quot;count&quot;</span>, <span class="built_in">len</span>(reinject))</span><br><span class="line">senderCacher.<span class="built_in">recover</span>(pool.signer, reinject)</span><br><span class="line">pool.addTxsLocked(reinject, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>更新分叉指示器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next := <span class="built_in">new</span>(big.Int).Add(newHead.Number, big.NewInt(<span class="number">1</span>))pool.istanbul = pool.chainconfig.IsIstanbul(next)</span><br></pre></td></tr></table></figure>

<h6 id="交易池升级"><a href="#交易池升级" class="headerlink" title="交易池升级"></a>交易池升级</h6><p>promoteTx是将queue列表中的Txs放入pending并随时广播。把交易放入queue状态时不广播。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">promoteExecutables</span><span class="params">(accounts []common.Address)</span> []*<span class="title">types</span>.<span class="title">Transaction</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟踪这些被升级的交易以便第一时间广播她们</span></span><br><span class="line">	<span class="keyword">var</span> promoted []*types.Transaction</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 用list跟踪一个账户的交易列表</span></span><br><span class="line">	<span class="keyword">for</span> _, addr := <span class="keyword">range</span> accounts &#123;</span><br><span class="line">		list := pool.queue[addr]</span><br><span class="line">		<span class="keyword">if</span> list == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span> <span class="comment">// Just in case someone calls with a non existing account</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//删除所有被认为太旧的事务（低nonce）</span></span><br><span class="line">		forwards := list.Forward(pool.currentState.GetNonce(addr))</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> forwards &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed old queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 放弃所有成本过高的交易（低余额或无gas）</span></span><br><span class="line">		drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drops &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed unpayable queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br><span class="line">		queuedNofundsMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(drops)))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 执行promote操作</span></span><br><span class="line">		readies := list.Ready(pool.pendingNonces.get(addr))</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> readies &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			<span class="keyword">if</span> pool.promoteTx(addr, hash, tx) &#123;</span><br><span class="line">				log.Trace(<span class="string">&quot;Promoting queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">				promoted = <span class="built_in">append</span>(promoted, tx)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		queuedGauge.Dec(<span class="keyword">int64</span>(<span class="built_in">len</span>(readies)))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 删除超过允许限制的所有事务</span></span><br><span class="line">		<span class="keyword">var</span> caps types.Transactions</span><br><span class="line">		<span class="keyword">if</span> !pool.locals.contains(addr) &#123;</span><br><span class="line">			caps = list.Cap(<span class="keyword">int</span>(pool.config.AccountQueue))</span><br><span class="line">			<span class="keyword">for</span> _, tx := <span class="keyword">range</span> caps &#123;</span><br><span class="line">				hash := tx.Hash()</span><br><span class="line">				pool.all.Remove(hash)</span><br><span class="line">				log.Trace(<span class="string">&quot;Removed cap-exceeding queued transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">			&#125;</span><br><span class="line">			queuedRateLimitMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(caps)))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将所有丢弃的项目标记为已删除</span></span><br><span class="line">		pool.priced.Removed(<span class="built_in">len</span>(forwards) + <span class="built_in">len</span>(drops) + <span class="built_in">len</span>(caps))</span><br><span class="line">		queuedGauge.Dec(<span class="keyword">int64</span>(<span class="built_in">len</span>(forwards) + <span class="built_in">len</span>(drops) + <span class="built_in">len</span>(caps)))</span><br><span class="line">		<span class="keyword">if</span> pool.locals.contains(addr) &#123;</span><br><span class="line">			localGauge.Dec(<span class="keyword">int64</span>(<span class="built_in">len</span>(forwards) + <span class="built_in">len</span>(drops) + <span class="built_in">len</span>(caps)))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Delete the entire queue entry if it became empty.</span></span><br><span class="line">		<span class="keyword">if</span> list.Empty() &#123;</span><br><span class="line">			<span class="built_in">delete</span>(pool.queue, addr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> promoted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="交易池降级"><a href="#交易池降级" class="headerlink" title="交易池降级"></a>交易池降级</h6><p>如果出现新块，验证pending池。这将删除已包含在区块中的任何交易或因另一个交易（例如更高的gas）而无效的任何交易。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">demoteUnexecutables</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 遍历pending列表，获取每个addr的最新nonce值</span></span><br><span class="line">	<span class="keyword">for</span> addr, list := <span class="keyword">range</span> pool.pending &#123;</span><br><span class="line">		nonce := pool.currentState.GetNonce(addr)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 剔除nonce小于上面nonce值的交易，从all和priced中删除</span></span><br><span class="line">		olds := list.Forward(nonce)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> olds &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed old pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 返回账户余额已经不足以支付交易费用和一些暂时无效的交易</span></span><br><span class="line">		drops, invalids := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas)</span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> drops &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			log.Trace(<span class="string">&quot;Removed unpayable pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">			pool.all.Remove(hash)</span><br><span class="line">		&#125;</span><br><span class="line">		pool.priced.Removed(<span class="built_in">len</span>(olds) + <span class="built_in">len</span>(drops))</span><br><span class="line">		pendingNofundsMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(drops)))</span><br><span class="line">		<span class="comment">//将暂时无效的交易放到queue中</span></span><br><span class="line">		<span class="keyword">for</span> _, tx := <span class="keyword">range</span> invalids &#123;</span><br><span class="line">			hash := tx.Hash()</span><br><span class="line">			log.Trace(<span class="string">&quot;Demoting pending transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">			pool.enqueueTx(hash, tx)</span><br><span class="line">		&#125;</span><br><span class="line">		pendingGauge.Dec(<span class="keyword">int64</span>(<span class="built_in">len</span>(olds) + <span class="built_in">len</span>(drops) + <span class="built_in">len</span>(invalids)))</span><br><span class="line">		<span class="keyword">if</span> pool.locals.contains(addr) &#123;</span><br><span class="line">			localGauge.Dec(<span class="keyword">int64</span>(<span class="built_in">len</span>(olds) + <span class="built_in">len</span>(drops) + <span class="built_in">len</span>(invalids)))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果有间隙，将后面的交易移动到queue列表中</span></span><br><span class="line">		<span class="keyword">if</span> list.Len() &gt; <span class="number">0</span> &amp;&amp; list.txs.Get(nonce) == <span class="literal">nil</span> &#123;</span><br><span class="line">			gapped := list.Cap(<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">for</span> _, tx := <span class="keyword">range</span> gapped &#123;</span><br><span class="line">				hash := tx.Hash()</span><br><span class="line">				log.Error(<span class="string">&quot;Demoting invalidated transaction&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">				pool.enqueueTx(hash, tx)</span><br><span class="line">			&#125;</span><br><span class="line">			pendingGauge.Dec(<span class="keyword">int64</span>(<span class="built_in">len</span>(gapped)))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果经过上面的降级，pending里某个addr一个交易都没有，就把该账户给删除</span></span><br><span class="line">		<span class="keyword">if</span> list.Empty() &#123;</span><br><span class="line">			<span class="built_in">delete</span>(pool.pending, addr)</span><br><span class="line">			<span class="built_in">delete</span>(pool.beats, addr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%B1%A0/" data-id="ckqol3obz0023nwu77lvx0w4k" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-后端文档" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E5%90%8E%E7%AB%AF%E6%96%87%E6%A1%A3/">fisco-bcos browser 改编整理</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E5%90%8E%E7%AB%AF%E6%96%87%E6%A1%A3/" class="article-date"><time datetime="2021-07-02T10:37:40.000Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h1 id="yezzi-browser1-0-文档"><a href="#yezzi-browser1-0-文档" class="headerlink" title="yezzi_browser1.0 文档"></a>yezzi_browser1.0 文档</h1><h2 id="一、产品简介"><a href="#一、产品简介" class="headerlink" title="一、产品简介"></a>一、产品简介</h2><h4 id="1-1-基本描述"><a href="#1-1-基本描述" class="headerlink" title="1.1 基本描述"></a>1.1 基本描述</h4><h6 id="yezzi-browser在fisco-bcos-browser基础上进行修改，和fisco-bcos-browser一样适配FISCO-BCOS-2-0-版本"><a href="#yezzi-browser在fisco-bcos-browser基础上进行修改，和fisco-bcos-browser一样适配FISCO-BCOS-2-0-版本" class="headerlink" title="yezzi_browser在fisco-bcos-browser基础上进行修改，和fisco-bcos-browser一样适配FISCO BCOS 2.0+版本"></a>yezzi_browser在fisco-bcos-browser基础上进行修改，和fisco-bcos-browser一样适配FISCO BCOS 2.0+版本</h6><p>区块链浏览器将区块链中的数据可视化，并进行实时展示。方便用户以Web页面的方式，获取当前区块链中的信息。而修改后的浏览器主要增加区块链中个性化数据的展示，以满足各种业务需求和区块链中交易的监管。</p>
<h4 id="1-2-主要功能模块"><a href="#1-2-主要功能模块" class="headerlink" title="1.2 主要功能模块"></a>1.2 主要功能模块</h4><p>媒体素材链的主要功能模块有：区块和交易一揽；业务数量统计；各种交易趋势；等等（正在考虑新增其他特性）</p>
<h5 id="1-2-1-区块链信息展示模块"><a href="#1-2-1-区块链信息展示模块" class="headerlink" title="1.2.1 区块链信息展示模块"></a>1.2.1 区块链信息展示模块</h5><p>和原版一样，主要展示了链上群组的具体信息，这些信息包括：概览信息，区块信息，交易信息。</p>
<h5 id="1-2-2-业务数据统计"><a href="#1-2-2-业务数据统计" class="headerlink" title="1.2.2 业务数据统计"></a>1.2.2 业务数据统计</h5><p>包括：上链素材统计；图片交易数量；图片侵权数量；图片确权总数；交易图片增长趋势；确权图片量增长趋势；</p>
<h2 id="二、安装说明"><a href="#二、安装说明" class="headerlink" title="二、安装说明"></a>二、安装说明</h2><h4 id="2-1-群组搭建"><a href="#2-1-群组搭建" class="headerlink" title="2.1 群组搭建"></a>2.1 群组搭建</h4><p>按照<a target="_blank" rel="noopener" href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/installation.html">FISCO BCOS</a>标准的搭建方式搭链即可</p>
<h4 id="2-2-部署说明"><a href="#2-2-部署说明" class="headerlink" title="2.2 部署说明"></a>2.2 部署说明</h4><p>参考<a target="_blank" rel="noopener" href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/browser/browser.html">fisco-bcos-browser文档</a></p>
<h6 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h6><h6 id="1-后端搭建步骤中，在gradle-build之前需要改动start-sh-在CLASSPATH一行加入conf-template-目的是在build-gradle中重写的jar命令中将resources中文件复制到conf-template中而没放到conf中，即使编译过，因为log4j2-xml缺失，运行dist中复制后的start-sh时会出现找不到该文件而报错，无法运行。需要注意的是，必须在编译Jar包之前修改start-sh文件，在dist目录存在时，gradle-build命令不会再对dist中的内容进行修改，即使里面缺少东西也不会按照gradle里面写的步骤进行下去。"><a href="#1-后端搭建步骤中，在gradle-build之前需要改动start-sh-在CLASSPATH一行加入conf-template-目的是在build-gradle中重写的jar命令中将resources中文件复制到conf-template中而没放到conf中，即使编译过，因为log4j2-xml缺失，运行dist中复制后的start-sh时会出现找不到该文件而报错，无法运行。需要注意的是，必须在编译Jar包之前修改start-sh文件，在dist目录存在时，gradle-build命令不会再对dist中的内容进行修改，即使里面缺少东西也不会按照gradle里面写的步骤进行下去。" class="headerlink" title="1.后端搭建步骤中，在gradle build之前需要改动start.sh,在CLASSPATH一行加入conf_template/: 目的是在build.gradle中重写的jar命令中将resources中文件复制到conf_template中而没放到conf中，即使编译过，因为log4j2.xml缺失，运行dist中复制后的start.sh时会出现找不到该文件而报错，无法运行。需要注意的是，必须在编译Jar包之前修改start.sh文件，在dist目录存在时，gradle build命令不会再对dist中的内容进行修改，即使里面缺少东西也不会按照gradle里面写的步骤进行下去。"></a>1.后端搭建步骤中，在gradle build之前需要改动start.sh,在CLASSPATH一行加入conf_template/: 目的是在build.gradle中重写的jar命令中将resources中文件复制到conf_template中而没放到conf中，即使编译过，因为log4j2.xml缺失，运行dist中复制后的start.sh时会出现找不到该文件而报错，无法运行。需要注意的是，必须在编译Jar包之前修改start.sh文件，在dist目录存在时，gradle build命令不会再对dist中的内容进行修改，即使里面缺少东西也不会按照gradle里面写的步骤进行下去。</h6><h6 id="2-运行前根目录下若有dist文件夹，先运行gradle-clean-再重新gradle-build"><a href="#2-运行前根目录下若有dist文件夹，先运行gradle-clean-再重新gradle-build" class="headerlink" title="2.运行前根目录下若有dist文件夹，先运行gradle clean 再重新gradle build"></a>2.运行前根目录下若有dist文件夹，先运行gradle clean 再重新gradle build</h6><h4 id="2-3-问题排查"><a href="#2-3-问题排查" class="headerlink" title="2.3 问题排查"></a>2.3 问题排查</h4><h5 id="2-3-1-主机无法复制文件和文字到虚拟机"><a href="#2-3-1-主机无法复制文件和文字到虚拟机" class="headerlink" title="2.3.1 主机无法复制文件和文字到虚拟机"></a>2.3.1 主机无法复制文件和文字到虚拟机</h5><p>解决方法1：安装vmware tools,并在设置中勾选上允许客户端和虚拟机。</p>
<p>解决方法2：在插入u盘的时候虚拟机会提示是否连接虚拟机，选是，后面按提示走就可以把u盘文件复制过去</p>
<h5 id="2-3-2-安装vmware-tools的选项显示灰色的解决方法"><a href="#2-3-2-安装vmware-tools的选项显示灰色的解决方法" class="headerlink" title="2.3.2 安装vmware tools的选项显示灰色的解决方法"></a>2.3.2 安装vmware tools的选项显示灰色的解决方法</h5><p>在虚拟机设置-硬件-   CD/DVD   CD/DVD2   软盘   中都勾选住使用物理驱动器-自动检测，之后重启即可</p>
<h5 id="2-3-3-mysql-root密码忘记怎么办？"><a href="#2-3-3-mysql-root密码忘记怎么办？" class="headerlink" title="2.3.3 mysql root密码忘记怎么办？"></a>2.3.3 mysql root密码忘记怎么办？</h5><p>1.关闭Mysql所有服务</p>
<p>2.修改mysql的登录设置,一般在 /etc/my.cnf中，在mysqld段中加上一句skip-grant-tables</p>
<p>3.重启mysql</p>
<p>4.使用数据库mysql : use mysql;</p>
<p>5.改root密码(123456) update user set password = password(‘123456’) where user = ‘root’;</p>
<p>有的版本的Mysql需要用 update user set authentication_string = password(‘123456’) where user = ‘root’;</p>
<p>6.将mysql登录设置改回来</p>
<p>7.重启mysql</p>
<h5 id="2-3-4-连接mysql时出现-can-not-connect-to-local-mysql-through-socket"><a href="#2-3-4-连接mysql时出现-can-not-connect-to-local-mysql-through-socket" class="headerlink" title="2.3.4 连接mysql时出现 can not connect to local mysql through socket"></a>2.3.4 连接mysql时出现 can not connect to local mysql through socket</h5><p>可能的解决方法1：service mysqld start</p>
<p>可能的解决方法2：完善mysql配置文件，/etc/my.cnf中添加[client]和[mysqld]选项，并且使这两个选项下的socket和default的参数值和[mysqld]中的一样</p>
<h5 id="2-3-5-gradle项目编译时出现-could-not-find-method-annotationProcessor-for-arguments"><a href="#2-3-5-gradle项目编译时出现-could-not-find-method-annotationProcessor-for-arguments" class="headerlink" title="2.3.5 gradle项目编译时出现 could not find method annotationProcessor() for arguments"></a>2.3.5 gradle项目编译时出现 could not find method annotationProcessor() for arguments</h5><p>多半是gradle的问题，重新配置下gradle试试</p>
<h5 id="2-3-6-使用数据库时出现OperationError-1698-”Access-denied-for-user-”"><a href="#2-3-6-使用数据库时出现OperationError-1698-”Access-denied-for-user-”" class="headerlink" title="2.3.6 使用数据库时出现OperationError:(1698,”Access denied for user ***”)"></a>2.3.6 使用数据库时出现OperationError:(1698,”Access denied for user ***”)</h5><p>数据库密码错了，看下配置文件或登陆下试试</p>
<h5 id="2-3-7-安装Mysql-python时出现问题：-usr-bin-ld-cannot-find-lssl"><a href="#2-3-7-安装Mysql-python时出现问题：-usr-bin-ld-cannot-find-lssl" class="headerlink" title="2.3.7 安装Mysql-python时出现问题：/usr/bin/ld: cannot find -lssl"></a>2.3.7 安装Mysql-python时出现问题：/usr/bin/ld: cannot find -lssl</h5><p>一般是血少链接库文件 使用 apt-get install lib***-dev</p>
<h5 id="2-3-8-有python2-X的环境却没有pip？"><a href="#2-3-8-有python2-X的环境却没有pip？" class="headerlink" title="2.3.8 有python2.X的环境却没有pip？"></a>2.3.8 有python2.X的环境却没有pip？</h5><p>配置apt源，重新下载python和pyhon-pip</p>
<h1 id="三、技术文档"><a href="#三、技术文档" class="headerlink" title="三、技术文档"></a>三、技术文档</h1><h4 id="3-1-后端文件目录"><a href="#3-1-后端文件目录" class="headerlink" title="3.1 后端文件目录"></a>3.1 后端文件目录</h4><p>.gradle：gradle缓存</p>
<p>.idea：idea缓存 </p>
<p>（dist）：编译后产生的目录</p>
<p>gradle：Gradle可以在没有安装Gradle的情况下使用，这时候就需要Gradle Wrapper了。Gradle Wrapper其实就是一个脚本文件，它会在没有安装Gradle的情况下为我们下载Gradle，之后我们就可以使用gradlew命令，像使用gradle一样来使用Gradle了。</p>
<p>log：若从idea直接启动项目，日志文件将产生在这里</p>
<p>src：项目文件</p>
<p>temp：临时文件</p>
<p>build.gradle：gradle是基于jvm的构建工具，build.gradle主要配置软件版本信息、引用库的配置，以及编译所需的配置</p>
<p>gradlew   gradlew.bat   :   linux和windows下运行gradlew命令使用的脚本</p>
<p>start.sh   stop.sh   status.sh   :   运行和停止脚本，会在项目编译后复制到dist目录中，项目就由其控制运行和停止</p>
<h4 id="3-2-后端项目解析"><a href="#3-2-后端项目解析" class="headerlink" title="3.2 后端项目解析"></a>3.2 后端项目解析</h4><h5 id="3-2-1-主要逻辑"><a href="#3-2-1-主要逻辑" class="headerlink" title="3.2.1 主要逻辑"></a>3.2.1 主要逻辑</h5><p><img src="./img/p1.png"></p>
<h5 id="3-2-2-数据同步"><a href="#3-2-2-数据同步" class="headerlink" title="3.2.2 数据同步"></a>3.2.2 数据同步</h5><p><img src="./img/p2.png"></p>
<h5 id="3-2-3-涉及到的注解"><a href="#3-2-3-涉及到的注解" class="headerlink" title="3.2.3 涉及到的注解"></a>3.2.3 涉及到的注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@MapperScan</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="meta">@GetMapping</span>   <span class="meta">@PostMapping</span>   <span class="meta">@PutMapping</span>   <span class="meta">@DeleteMapping</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-2-4-涉及到的组件"><a href="#3-2-4-涉及到的组件" class="headerlink" title="3.2.4 涉及到的组件"></a>3.2.4 涉及到的组件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">spring组件：</span><br><span class="line">	<span class="string">&quot;org.springframework:spring-core:$spring_version&quot;</span></span><br><span class="line">	<span class="string">&quot;org.springframework:spring-beans:$spring_version&quot;</span></span><br><span class="line">	<span class="string">&quot;org.springframework:spring-context:$spring_version&quot;</span></span><br><span class="line">	<span class="string">&quot;org.springframework:spring-tx:$spring_version&quot;</span></span><br><span class="line">	<span class="string">&quot;org.springframework:spring-jdbc:$spring_version&quot;</span></span><br><span class="line">	<span class="string">&quot;org.springframework:spring-web:$spring_version&quot;</span></span><br><span class="line">	<span class="string">&quot;org.springframework:spring-webmvc:$spring_version&quot;</span></span><br><span class="line">	</span><br><span class="line">    <span class="string">&quot;org.springframework.boot:spring-boot-starter-web:1.5.9.RELEASE&quot;</span>,</span><br><span class="line">	<span class="string">&quot;org.springframework.boot:spring-boot-autoconfigure:1.5.9.RELEASE&quot;</span>,</span><br><span class="line">	<span class="string">&quot;org.springframework.boot:spring-boot-configuration-processor:1.5.9.RELEASE&quot;</span>,</span><br><span class="line">	<span class="string">&quot;org.springframework.boot:spring-boot-starter-log4j2:1.5.9.RELEASE&quot;</span></span><br><span class="line">mysql组件：</span><br><span class="line">	<span class="string">&#x27;org.mybatis:mybatis:3.2.8&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;org.mybatis.spring.boot:mybatis-spring-boot-starter:1.3.1&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;mysql:mysql-connector-java:5.1.30&#x27;</span>,</span><br><span class="line">io组件：</span><br><span class="line">	<span class="string">&#x27;commons-io:commons-io:2.6&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;commons-fileupload:commons-fileupload:1.4&#x27;</span></span><br><span class="line">其他组件：</span><br><span class="line">jsonrpc4j：<span class="number">1.5</span><span class="number">.1</span></span><br><span class="line">fastjson：<span class="number">1.2</span><span class="number">.29</span></span><br><span class="line">lombok:<span class="number">1.18</span><span class="number">.2</span></span><br><span class="line">log4j2</span><br></pre></td></tr></table></figure>

<h5 id="3-2-5-部分代码片段解析"><a href="#3-2-5-部分代码片段解析" class="headerlink" title="3.2.5 部分代码片段解析"></a>3.2.5 部分代码片段解析</h5><h6 id="1-SchedulerConfig-java"><a href="#1-SchedulerConfig-java" class="headerlink" title="1.SchedulerConfig.java"></a>1.SchedulerConfig.java</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taskRegistrar.addTriggerTask(() -&gt; schedulerService.handleBlockChainInfo(),</span><br><span class="line">            (context) -&gt; <span class="keyword">new</span> CronTrigger(constants.getCronBlockChainInfo())</span><br><span class="line">                        .nextExecutionTime(context));</span><br></pre></td></tr></table></figure>

<p>箭头函数。Lambda表达式的本质只是一个语法糖,由编译器推断并帮你转换包装为常规的代码,因此你可以使用更少的代码来实现同样的功能。</p>
<p>addTriggerTask(task, trigger)   参数是两个函数，前一个参数是要执行的任务，后一个参数是触发条件。() -&gt; schedulerService.handleBlockChainInfo() 是箭头函数，表示无参数传递，返回值为schedulerService.handleBlockChainInfo() 。下一个函数代表传入一个箭头函数：context为参数，nextExecutionTime为返回函数，确定执行周期。</p>
<h6 id="2-简易流程分析（以拿区块链数据为例）"><a href="#2-简易流程分析（以拿区块链数据为例）" class="headerlink" title="2.简易流程分析（以拿区块链数据为例）"></a>2.简易流程分析（以拿区块链数据为例）</h6><p>controller:</p>
<p>注释写上方法名，参数，返回。继承抽象类BaseController(进行一些参数检查和错误处理)。之后规定http get方法，/{groupId}的写法是对应url中的/fisco-bcos-browser/home/blockChainInfo/1中的”1”，将地址中的数字直接拿出来而不需要再用参数。其使用@PathVariable绑定URI模板变量值，请求url中的动态参数。得到请求后直接传给service层的getBlockChainInfo函数并等待返回值。</p>
<p>需要注意的是，返回的值是自定义的BaseResponse类型，而是统一放到response对象的数据。该对象是一个bean由@Data注解修饰的数据域，内含状态码、状态消息、值域。有的服务返回BasePageResponse用于返回分页数据,和BaseResponse区别多了个totalCount值表示有几个值（一般是一个对象组成的list）被返回。这样做的好处是有利于前后端分离开发，更规范前端易解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;home&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockChainInfoController</span> <span class="keyword">extends</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BlockChainInfoService blockChainInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getBlockChainInfo.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupId groupId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/blockChainInfo/&#123;groupId&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseResponse <span class="title">getBlockChainInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;groupId&quot;)</span> <span class="keyword">int</span> groupId)</span> </span>&#123;</span><br><span class="line">        BaseResponse response = blockChainInfoService.getBlockChainInfo(groupId);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service:</p>
<p>新建BaseResponse对象。状态码对应success，之后直接调用mapper的方法调用数据库，将返回值放在response对象的data中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockChainInfoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BlockChainInfoMapper blockChainInfoMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    NodeMapper nodeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getBlockChainInfo.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupId groupId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseResponse <span class="title">getBlockChainInfo</span><span class="params">(<span class="keyword">int</span> groupId)</span> </span>&#123;</span><br><span class="line">        BaseResponse response = <span class="keyword">new</span> BaseResponse(ConstantCode.SUCCESS);</span><br><span class="line">        BlockChainInfo tbBlockChainInfo = blockChainInfoMapper.getBlockChainInfo(groupId);</span><br><span class="line">        response.setData(tbBlockChainInfo);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapper:</p>
<p>在/resources/mapper下的xml中用sql语言定义好数据库操作，在mapper文件中定义接口函数，就可以调用数据库了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockChainInfoMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">BlockChainInfo <span class="title">getBlockChainInfo</span><span class="params">(<span class="meta">@Param(value = &quot;groupId&quot;)</span> <span class="keyword">int</span> groupId)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;org.bcos.browser.mapper.BlockChainInfoMapper&quot;&gt;</span><br><span class="line">&lt;select id=&quot;getBlockChainInfo&quot; resultType=&quot;org.bcos.browser.entity.dto.BlockChainInfo&quot;&gt;</span><br><span class="line">    select &lt;include refid=&quot;ALL_COLUMN&quot; /&gt;</span><br><span class="line">    from tb_blockChainInfo_#&#123;groupId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>数据库对应的数据：</p>
<p><img src="./img/p3.png"></p>
<h6 id="3-数据同步流程代码分析"><a href="#3-数据同步流程代码分析" class="headerlink" title="3.数据同步流程代码分析"></a>3.数据同步流程代码分析</h6><p>写好rpc通信工具，以便使用json-rpc api调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Web3jRpc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    NodeMapper nodeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rpcRequest.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupId groupId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName rpc method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params params</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">rpcRequest</span><span class="params">(<span class="keyword">int</span> groupId, String methodName, Object[] params)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Node&gt; nodeList = nodeMapper.getManualNode(groupId);</span><br><span class="line">        <span class="keyword">if</span> (nodeList == <span class="keyword">null</span> || nodeList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;there are not manually added nodes&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nodeSize = nodeList.size();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Integer&gt; indexList = <span class="keyword">new</span> ArrayList&lt;&gt;(nodeSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexList.size() == nodeSize) &#123;</span><br><span class="line">                <span class="keyword">return</span> object;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = random.nextInt(nodeSize);</span><br><span class="line">            <span class="keyword">if</span> (indexList.contains(index)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Node node = nodeList.get(index);</span><br><span class="line">            indexList.add(index);</span><br><span class="line"></span><br><span class="line">            object = requestNode(methodName, params, node);</span><br><span class="line">            <span class="keyword">if</span> (object == <span class="keyword">null</span> &amp;&amp; indexList.size() &lt; nodeSize) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * requestNode.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName rpc method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params params</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node info</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">requestNode</span><span class="params">(String methodName, Object[] params, Node node)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">null</span>;</span><br><span class="line">        JsonRpcHttpClient client = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String url = String.format(Constants.RPC_BASE_URI, node.getIp(), node.getRpcPort());</span><br><span class="line">        log.debug(<span class="string">&quot;request url: &#123;&#125;&quot;</span>, url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client = <span class="keyword">new</span> JsonRpcHttpClient(<span class="keyword">new</span> URL(url));</span><br><span class="line">            client.setConnectionTimeoutMillis(<span class="number">5000</span>);</span><br><span class="line">            client.setReadTimeoutMillis(<span class="number">5000</span>);</span><br><span class="line">            object = client.invoke(methodName, params, Object.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;fail request methodName:&#123;&#125; ip:&#123;&#125; rpcPort:&#123;&#125;&quot;</span>, methodName, node.getIp(),</span><br><span class="line">                    node.getRpcPort(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义好自动处理（SchedulerConfig.java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchedulerConfig</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SchedulerService schedulerService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Constants constants;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        taskRegistrar.addTriggerTask(() -&gt; schedulerService.handleBlockChainInfo(),</span><br><span class="line">            (context) -&gt; <span class="keyword">new</span> CronTrigger(constants.getCronBlockChainInfo())</span><br><span class="line">                        .nextExecutionTime(context));</span><br><span class="line"></span><br><span class="line">        taskRegistrar.addTriggerTask(() -&gt; schedulerService.handleBlocks(),</span><br><span class="line">            (context) -&gt; <span class="keyword">new</span> CronTrigger(constants.getCronBlockInfo())</span><br><span class="line">                        .nextExecutionTime(context));</span><br><span class="line"></span><br><span class="line">        taskRegistrar.addTriggerTask(() -&gt; schedulerService.handleTxnByDay(),</span><br><span class="line">            (context) -&gt; <span class="keyword">new</span> CronTrigger(constants.getCronTxnByDay())</span><br><span class="line">                        .nextExecutionTime(context));</span><br><span class="line"></span><br><span class="line">        taskRegistrar.addTriggerTask(() -&gt; schedulerService.syncNodeInfo(),</span><br><span class="line">            (context) -&gt; <span class="keyword">new</span> CronTrigger(constants.getCronAyncNode())</span><br><span class="line">                .nextExecutionTime(context));</span><br><span class="line">        </span><br><span class="line">        taskRegistrar.addTriggerTask(() -&gt; schedulerService.checkNodeActive(),</span><br><span class="line">            (context) -&gt; <span class="keyword">new</span> CronTrigger(constants.getCronIfNodeActive())</span><br><span class="line">                        .nextExecutionTime(context));</span><br><span class="line"></span><br><span class="line">        taskRegistrar.addTriggerTask(() -&gt;schedulerService.deleteTxnSchedule(),</span><br><span class="line">                (context) -&gt; <span class="keyword">new</span> CronTrigger(constants.getCronDeleteTxn())</span><br><span class="line">                        .nextExecutionTime(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写自动处理的详细内容（ScheduleService.java），还是会调用mapper层来给数据库增加数据，例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * handleBlockChainInfo.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleBlockChainInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Group&gt; list = groupMapper.getGroupList();</span><br><span class="line">    <span class="keyword">for</span> (Group loop : list) &#123;</span><br><span class="line">        Object[] params = <span class="keyword">new</span> Object[] &#123;loop.getGroupId()&#125;;</span><br><span class="line">        <span class="comment">// get block number and txn</span></span><br><span class="line">        BlockNumberAndTxn blockNumberAndTxn = web3jRpc.getTxn(loop.getGroupId());</span><br><span class="line">        <span class="comment">// get txn</span></span><br><span class="line">        <span class="keyword">int</span> pendingTxn = CommonUtils.parseHexStr2Int((String) web3jRpc</span><br><span class="line">                .rpcRequest(loop.getGroupId(), Constants.GET_PENDING_TX_SIZE, params));</span><br><span class="line">        <span class="comment">// get pbftView</span></span><br><span class="line">        <span class="keyword">int</span> pbftView = CommonUtils.parseHexStr2Int((String) web3jRpc</span><br><span class="line">                .rpcRequest(loop.getGroupId(), Constants.GET_PBFT_VIEW, params));</span><br><span class="line"></span><br><span class="line">        BlockChainInfo blockChainInfo = <span class="keyword">new</span> BlockChainInfo();</span><br><span class="line">        blockChainInfo.setGroupId(loop.getGroupId());</span><br><span class="line">        blockChainInfo.setLatestNumber(blockNumberAndTxn.getBlockNumber());</span><br><span class="line">        blockChainInfo.setPbftView(pbftView);</span><br><span class="line">        blockChainInfo.setTxn(blockNumberAndTxn.getTxn());</span><br><span class="line">        blockChainInfo.setPendingTxn(pendingTxn);</span><br><span class="line">        blockChainInfoMapper.add(blockChainInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="3-2-6-部分组件整理"><a href="#3-2-6-部分组件整理" class="headerlink" title="3.2.6 部分组件整理"></a>3.2.6 部分组件整理</h5><h6 id="1-mybatis：持久层框架，用于操作mysql数据库"><a href="#1-mybatis：持久层框架，用于操作mysql数据库" class="headerlink" title="1.mybatis：持久层框架，用于操作mysql数据库"></a>1.mybatis：持久层框架，用于操作mysql数据库</h6><p>设置好xml的路径（本项目在resources/mapper）后，每个mapper接口文件对应一个xml，接口中写好方法，在xml中按照mysql语法写逻辑即可。例：TransactionMapper.xml：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getAmount&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;INTEGER&quot;&gt;</span><br><span class="line">    SELECT count(1) FROM tb_transaction_#&#123;groupId&#125;</span><br><span class="line">    WHERE 1 = 1</span><br><span class="line">    AND method = #&#123;method&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p> 官方教程：<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/index.html">mybatis教程链接</a></p>
<h6 id="2-jsonrpc4j：以json方式传输的rpc通讯工具"><a href="#2-jsonrpc4j：以json方式传输的rpc通讯工具" class="headerlink" title="2.jsonrpc4j：以json方式传输的rpc通讯工具"></a>2.jsonrpc4j：以json方式传输的rpc通讯工具</h6><p>JSON-RPC有C，C++，C#，Javascipt，Erlang，Objective-C，Java等多种语言的实现。既可独立使用，又可与spring无缝集合。</p>
<p>区块链，FISCO BCOS会在运行时启动rpc服务端并暴露端口可以通过rpc客户端直接连接并对区块链进行查询等操作，示例：RequestNode对象中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String url = String.format(Constants.RPC_BASE_URI, node.getIp(), node.getRpcPort());</span><br><span class="line">log.debug(<span class="string">&quot;request url: &#123;&#125;&quot;</span>, url);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    client = <span class="keyword">new</span> JsonRpcHttpClient(<span class="keyword">new</span> URL(url));</span><br><span class="line">    client.setConnectionTimeoutMillis(<span class="number">5000</span>);</span><br><span class="line">    client.setReadTimeoutMillis(<span class="number">5000</span>);</span><br><span class="line">    object = client.invoke(methodName, params, Object.class);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    log.warn(<span class="string">&quot;fail request methodName:&#123;&#125; ip:&#123;&#125; rpcPort:&#123;&#125;&quot;</span>, methodName, node.getIp(),</span><br><span class="line">            node.getRpcPort(), ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照api调用的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SyncInfoFromChain <span class="title">getSyncInfo</span><span class="params">(<span class="keyword">int</span> groupId, Node node)</span> </span>&#123;</span><br><span class="line">    SyncInfoFromChain result = <span class="keyword">null</span>;</span><br><span class="line">    Object[] params = <span class="keyword">new</span> Object[] &#123;groupId&#125;;</span><br><span class="line">    Object object = requestNode(Constants.GET_SYNC_STATUS, params, node);</span><br><span class="line">    <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = CommonUtils.object2JavaBean(object, SyncInfoFromChain.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意api调用时json字段每一个参数都是字符串数组</p>
<p>FISCO BCOS 的<a target="_blank" rel="noopener" href="https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/api.html">API文档</a></p>
<p>JSON-RPC for Java的<a target="_blank" rel="noopener" href="https://github.com/briandilley/jsonrpc4j">github地址</a></p>
<h6 id="3-springboot：web框架无需多说"><a href="#3-springboot：web框架无需多说" class="headerlink" title="3.springboot：web框架无需多说"></a>3.springboot：web框架无需多说</h6><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/html/">官方文档</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/api/">API文档</a></p>
<h6 id="4-fastjson：高效的json解析工具"><a href="#4-fastjson：高效的json解析工具" class="headerlink" title="4.fastjson：高效的json解析工具"></a>4.fastjson：高效的json解析工具</h6><p>github地址：<a href="alibaba/fastjson">alibaba/fastjson</a></p>
<p>gradle引入：<code>compile &#39;com.alibaba:fastjson:1.2.29&#39;</code></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONArray;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getTxn.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> groupId groupId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BlockNumberAndTxn <span class="title">getTxn</span><span class="params">(<span class="keyword">int</span> groupId)</span> </span>&#123;</span><br><span class="line">    BlockNumberAndTxn result = <span class="keyword">new</span> BlockNumberAndTxn();</span><br><span class="line">    Object[] params = <span class="keyword">new</span> Object[] &#123;groupId&#125;;</span><br><span class="line">    Object object = rpcRequest(groupId, Constants.GET_TOTAL_TRANSACTION_COUNT, params);</span><br><span class="line">    <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">        JSONObject json = JSONObject.parseObject(JSON.toJSONString(object));</span><br><span class="line">        result.setBlockNumber(CommonUtils.parseHexStr2Int(json.getString(<span class="string">&quot;blockNumber&quot;</span>)));</span><br><span class="line">        result.setTxn(CommonUtils.parseHexStr2Int(json.getString(<span class="string">&quot;txSum&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E5%90%8E%E7%AB%AF%E6%96%87%E6%A1%A3/" data-id="ckqol3oc00026nwu7a8z500kl" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-bloom过滤器代码分析" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/bloom%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">Bloom过滤器</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/02/25/bloom%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date"><time datetime="2020-02-25T15:54:34.000Z" itemprop="datePublished">2020-02-25</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h6 id="布隆过滤器简介"><a href="#布隆过滤器简介" class="headerlink" title="布隆过滤器简介"></a>布隆过滤器简介</h6><p>Bloom filter是用于测试元素成员资格的空间高效概率数据结构。数据结构以牺牲规定的假阳性率为代价实现了巨大的数据压缩。</p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>一个Bloom过滤器作为一个m位的数组全部设置为0。选择一组k个随机散列函数，在Bloom过滤器中添加元素时，元素将分别进行哈希散列，而对于每个k个输出，该索引处的相应的Bloom过滤器位将被设置为1。通过使用与之前相同的散列函数来完成Bloom过滤器的查询。如果在bloom过滤器中访问的所有k个比特被设置为1，则这很可能表明该元素位于该集合中。删除元素只能通过废除Bloom过滤器并从头重新创建来完成。</p>
<p>Bloom过滤器是由底层数组和哈希函数组合在一起工作的，根据对误报率要求的不同，可以选择一个哈希函数，也可以选2个、3个，一般情况下选3个。与哈希表不同，为节省空间，Bloom过滤器的底层数组的每一位是一个比特，1表示有映射，0表示无映射。数组的长度与问题规模、哈希函数、误报率等因素有关，根据数据集规模的不同，可选用适当的哈希函数与适合的数组大小。因为具体问题的不同，很难说那种实现是最好的。</p>
<h6 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h6><p>下面举例说明Bloom过滤器的工作过程。</p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS83LzkvMTZiZDVjMjAzMzU1ZTMzZg" alt="img"> </p>
<p>数据集{x,y,z}，底层数组长度m=18，初始值全部为0，哈希函数个数k=3，分别为H1、H2 、H3。</p>
<p>首先把数据集的每个元素分别通过3个不同的哈希函数映射到底层数组中，将数组中对应位置的值置为1。可以看到有哈希碰撞发生，这里不用解决哈希碰撞。</p>
<p>当要判断一个元素是否在数据集中时，例如w，则依次计算3个哈希值，找数组中的映射值，如果映射值有一个为0则，元素不存在数据集中，如果3个对应映射值全部为1，则元素很大概率在数据集中，不能完全确定（因为哈希碰撞的存在）。图中，元素w的其中一个哈希映射为0，所以w一定不在数据集中。</p>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>因为哈希碰撞的原因，底层数组对应映射值为1，有可能是其他元素与要查找的元素发生碰撞，实际上，该元素并不存在在数据集中。所以Bloom过滤器存在误报率。</p>
<p>Bloom过滤器，只有插入、查找操作，没有删除操作。</p>
<h6 id="以太坊中的布隆过滤器"><a href="#以太坊中的布隆过滤器" class="headerlink" title="以太坊中的布隆过滤器"></a>以太坊中的布隆过滤器</h6><p><strong>1.其中的两个带有bloom的结构：</strong></p>
<p>收据中的布隆过滤器是所有日志信息的布隆过滤器的并集</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Receipt <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Consensus fields: These fields are defined by the Yellow Paper</span></span><br><span class="line">	PostState         []<span class="keyword">byte</span> <span class="string">`json:&quot;root&quot;`</span><span class="comment">//现在是0（属于）B256,之前是交易前的状态跟</span></span><br><span class="line">	Status            <span class="keyword">uint64</span> <span class="string">`json:&quot;status&quot;`</span><span class="comment">//交易的状态码</span></span><br><span class="line">	CumulativeGasUsed <span class="keyword">uint64</span> <span class="string">`json:&quot;cumulativeGasUsed&quot; gencodec:&quot;required&quot;`</span><span class="comment">//包含交易数据的区块中当交易发生后的累积 gas 使用量</span></span><br><span class="line">	Bloom             Bloom  <span class="string">`json:&quot;logsBloom&quot;         gencodec:&quot;required&quot;`</span><span class="comment">//由这些日志信息构成的布隆过滤器</span></span><br><span class="line">	Logs              []*Log <span class="string">`json:&quot;logs&quot;              gencodec:&quot;required&quot;`</span><span class="comment">//日志集合</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Implementation fields: These fields are added by geth when processing a transaction.//执行领域，在执行交易时被geth添加，存储在区块链数据库</span></span><br><span class="line">	<span class="comment">// They are stored in the chain database.</span></span><br><span class="line">	TxHash          common.Hash    <span class="string">`json:&quot;transactionHash&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">	ContractAddress common.Address <span class="string">`json:&quot;contractAddress&quot;`</span></span><br><span class="line">	GasUsed         <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasUsed&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Inclusion information: These fields provide information about the inclusion of the</span></span><br><span class="line">	<span class="comment">//transaction corresponding to this receipt.//提供与此收据有关的交易记录</span></span><br><span class="line">	BlockHash        common.Hash <span class="string">`json:&quot;blockHash,omitempty&quot;`</span></span><br><span class="line">	BlockNumber      *big.Int    <span class="string">`json:&quot;blockNumber,omitempty&quot;`</span></span><br><span class="line">	TransactionIndex <span class="keyword">uint</span>        <span class="string">`json:&quot;transactionIndex&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区块中的布隆过滤器是所有收据中的布隆过滤器的并集</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header represents a block header in the Ethereum blockchain.</span></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">	ParentHash  common.Hash    <span class="string">`json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</span> <span class="comment">//父区块头的kec256位哈希</span></span><br><span class="line">	UncleHash   common.Hash    <span class="string">`json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</span> <span class="comment">//叔块哈希</span></span><br><span class="line">	Coinbase    common.Address <span class="string">`json:&quot;miner&quot;            gencodec:&quot;required&quot;`</span> <span class="comment">//矿工</span></span><br><span class="line">	Root        common.Hash    <span class="string">`json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</span> <span class="comment">//状态树树根</span></span><br><span class="line">	TxHash      common.Hash    <span class="string">`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</span> <span class="comment">//交易树树根</span></span><br><span class="line">	ReceiptHash common.Hash    <span class="string">`json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</span> <span class="comment">//收据树树根</span></span><br><span class="line">	Bloom       Bloom          <span class="string">`json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</span> <span class="comment">//所有交易的收据数据中可索引信息（产生日志的地址和日志主题）组成的Bloom过滤器</span></span><br><span class="line">	Difficulty  *big.Int       <span class="string">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span> <span class="comment">//区快难度水平</span></span><br><span class="line">	Number      *big.Int       <span class="string">`json:&quot;number&quot;           gencodec:&quot;required&quot;`</span> <span class="comment">//祖先的数量，创世是0</span></span><br><span class="line">	GasLimit    <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</span> <span class="comment">//gas开支上限</span></span><br><span class="line">	GasUsed     <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</span> <span class="comment">//用掉的gas之和</span></span><br><span class="line">	Time        <span class="keyword">uint64</span>         <span class="string">`json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</span> <span class="comment">//unix时间戳</span></span><br><span class="line">	Extra       []<span class="keyword">byte</span>         <span class="string">`json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</span> <span class="comment">//32字节以内的任意数据</span></span><br><span class="line">	MixDigest   common.Hash    <span class="string">`json:&quot;mixHash&quot;`</span>								 <span class="comment">//kec256哈希值与nonce一起证明当前区块承载了足够的计算量</span></span><br><span class="line">	Nonce       BlockNonce     <span class="string">`json:&quot;nonce&quot;`</span>								 <span class="comment">//64位的值，用来与mixhash一起证明当前区块承载了足够多的的计算量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.布隆过滤器的构成</strong></p>
<p><img src="./picture/6.png"></p>
<p><strong>3.布隆过滤器的实现</strong></p>
<p>在NewBlock函数中有一段对收据进行收据树构建和布隆过滤器构建的操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(receipts) == <span class="number">0</span> &#123;</span><br><span class="line">	b.header.ReceiptHash = EmptyRootHash</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	b.header.ReceiptHash = DeriveSha(Receipts(receipts))</span><br><span class="line">	b.header.Bloom = CreateBloom(receipts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中DeriveSha已经在Block模块讲过，遍历收据树/交易树构建mpt树并取树根哈希。</p>
<p>涉及到的Bloom调用关系：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*/core/types/bloom9.go*/</span></span><br><span class="line"><span class="comment">//这个作用是遍历收据，将收据中的日志信息构建布隆过滤器，求并集。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateBloom</span><span class="params">(receipts Receipts)</span> <span class="title">Bloom</span></span> &#123;</span><br><span class="line">	bin := <span class="built_in">new</span>(big.Int)</span><br><span class="line">	<span class="keyword">for</span> _, receipt := <span class="keyword">range</span> receipts &#123;</span><br><span class="line">		bin.Or(bin, LogsBloom(receipt.Logs))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> BytesToBloom(bin.Bytes())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个函数是具体对收据中的logs求布隆过滤器，这个函数有两层循环，先遍历每一个log，取出其中的地址执行bloom9过滤器函数得到结果，再对每一个log中的topic循环进行bloom9过滤得到结果，将所有过滤后的布隆过滤器结果保存并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LogsBloom</span><span class="params">(logs []*Log)</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line">	bin := <span class="built_in">new</span>(big.Int)</span><br><span class="line">	<span class="keyword">for</span> _, log := <span class="keyword">range</span> logs &#123;</span><br><span class="line">		bin.Or(bin, bloom9(log.Address.Bytes()))</span><br><span class="line">		<span class="keyword">for</span> _, b := <span class="keyword">range</span> log.Topics &#123;</span><br><span class="line">			bin.Or(bin, bloom9(b[:]))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bin</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把输入映射到digest中的三个位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bloom9</span><span class="params">(b []<span class="keyword">byte</span>)</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line">	b = crypto.Keccak256(b)<span class="comment">//对信息生成一个256位的哈希值，返回32字节</span></span><br><span class="line"></span><br><span class="line">	r := <span class="built_in">new</span>(big.Int)<span class="comment">//最后要返回的bloomfilter，先初始化为零</span></span><br><span class="line">    <span class="comment">//对b字节中的前六个字节，每两个字节组成一组，拼接在一起，进行和2047的位层面的and操作,也就是对2048取余，得到位于0-2047区间的一个数，因为bloomfilter的长度是2048位。循环的第一行取t为1，最后一行把1左移b这么多位，然后合并到上一轮得到的bloomfilter里，经过三轮，把三个位置置位1后返回bloomfilter</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">6</span>; i += <span class="number">2</span> &#123;</span><br><span class="line">		t := big.NewInt(<span class="number">1</span>)</span><br><span class="line">		b := (<span class="keyword">uint</span>(b[i+<span class="number">1</span>]) + (<span class="keyword">uint</span>(b[i]) &lt;&lt; <span class="number">8</span>)) &amp; <span class="number">2047</span></span><br><span class="line">		r.Or(r, t.Lsh(t, b))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询bin这个bloom里是否含有这个topic，先用bloom9对topic转换成bytes slice，之后先执行bloom和topic构成的临时bloomfilter的交集操作，看和topic的bloomfilter是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BloomLookup</span><span class="params">(bin Bloom, topic bytesBacked)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	bloom := bin.Big()</span><br><span class="line">	cmp := bloom9(topic.Bytes())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> bloom.And(bloom, cmp).Cmp(cmp) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bloom9函数（布隆过滤器的原始实现）：</p>
<p><a href="./golang%E5%9F%BA%E7%A1%80%EF%BC%9Abig%E5%8C%85%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97.md">(附：big包、多种int类型和位运算简介)</a></p>
<p><img src="./picture/7.png"></p>
<p><img src="./picture/8.png"></p>
<p>实际检索时，虽然bloomfilter是用big.Int存储的，但int包中比较两个数和判断包含关系时用的是位运算，所以虽然难以显示位的形式显示bloomfilter，但用big.Int形式存储bloomfilter恰到好处。</p>
<p>测试代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/imroc/biu&quot;</span></span><br><span class="line">	<span class="string">&quot;math/big&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bloom9</span><span class="params">()</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	b := []<span class="keyword">byte</span>(<span class="string">&quot;3A72978C1084E2d44D1Fa06DdC4A2d57&quot;</span>)</span><br><span class="line">	fmt.Println()</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(b)==<span class="number">32</span>)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	b1 := <span class="keyword">uint</span>(b[<span class="number">0</span>])</span><br><span class="line">	b2 := <span class="keyword">uint</span>(b[<span class="number">1</span>])</span><br><span class="line">	fmt.Println(<span class="keyword">uint</span>(b[<span class="number">0</span>]),<span class="keyword">uint</span>(b[<span class="number">1</span>]))</span><br><span class="line">	fmt.Println(biu.ToBinaryString(b1))</span><br><span class="line">	fmt.Println(biu.ToBinaryString(b2))</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	r := <span class="built_in">new</span>(big.Int)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">6</span>; i += <span class="number">2</span> &#123;</span><br><span class="line"></span><br><span class="line">		t := big.NewInt(<span class="number">1</span>)</span><br><span class="line">		fmt.Println(<span class="string">&quot;t:&quot;</span>,t)</span><br><span class="line">		tmp := (<span class="keyword">uint</span>(b[i+<span class="number">1</span>]) + (<span class="keyword">uint</span>(b[i]) &lt;&lt; <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">		b := (<span class="keyword">uint</span>(b[i+<span class="number">1</span>]) + (<span class="keyword">uint</span>(b[i]) &lt;&lt; <span class="number">8</span>)) &amp; <span class="number">2047</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;进行+操作后的uint数字&quot;</span>,tmp)</span><br><span class="line">		fmt.Println(<span class="string">&quot;进行+操作后的位表示&quot;</span>,biu.ToBinaryString(tmp))</span><br><span class="line">		fmt.Println(<span class="string">&quot;2047的位表示：&quot;</span>,biu.ToBinaryString(<span class="keyword">uint</span>(<span class="number">2047</span>)))</span><br><span class="line">		fmt.Println(<span class="string">&quot;和2047进行与操作后： &quot;</span>,biu.ToBinaryString(b))</span><br><span class="line"></span><br><span class="line">		r.Or(r, t.Lsh(t, b))</span><br><span class="line">		fmt.Println(<span class="string">&quot;r: &quot;</span>,r)</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//进行布隆过滤器实操，假设输入的是32字节的topic类型 0xabcd68033A72978C1084E2d44D1Fa06DdC4A2d57</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	bloom9()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">[51 65 55 50 57 55 56 67 49 48 56 52 69 50 100 52 52 68 49 70 97 48 54 68 100 67 52 65 50 100 53 55]</span><br><span class="line">51 65</span><br><span class="line">[00000000 00000000 00000000 00000000 00000000 00000000 00000000 00110011]</span><br><span class="line">[00000000 00000000 00000000 00000000 00000000 00000000 00000000 01000001]</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">t: 1</span><br><span class="line">进行+操作后的uint数字 13121</span><br><span class="line">进行+操作后的位表示 [00000000 00000000 00000000 00000000 00000000 00000000 00110011 01000001]</span><br><span class="line">2047的位表示： [00000000 00000000 00000000 00000000 00000000 00000000 00000111 11111111]</span><br><span class="line">和2047进行与操作后：  [00000000 00000000 00000000 00000000 00000000 00000000 00000011 01000001]</span><br><span class="line">r:  57277807836949922408837567867349676981443478344341305058882899404622128010705808318690568531649256750858719018437999440148793721514146753400890052083129159241025748615958424204533602522957957552490080016463490494951861107213475167230717574212948590592</span><br><span class="line"></span><br><span class="line">t: 1</span><br><span class="line">进行+操作后的uint数字 14130</span><br><span class="line">进行+操作后的位表示 [00000000 00000000 00000000 00000000 00000000 00000000 00110111 00110010]</span><br><span class="line">2047的位表示： [00000000 00000000 00000000 00000000 00000000 00000000 00000111 11111111]</span><br><span class="line">和2047进行与操作后：  [00000000 00000000 00000000 00000000 00000000 00000000 00000111 00110010]</span><br><span class="line">r:  314233160182030736919751647047283290074158037244463871560980478788853316627874708750078214927865002494324613164753036777329719824205199439641013233466169838342774747631715248648272107024198456863680846183894703107928994710112002923069118082222231268172316199217641800603788442740611117876684040992433870125828443074830556275747757471100557196447769555568234660880002738894725057172944300128715707792997028959370378366499845797661040563264104785434051255235127701702797547234944876551769642325371880354786760476631936450661453927975692274855249413926813696</span><br><span class="line"></span><br><span class="line">t: 1</span><br><span class="line">进行+操作后的uint数字 14647</span><br><span class="line">进行+操作后的位表示 [00000000 00000000 00000000 00000000 00000000 00000000 00111001 00110111]</span><br><span class="line">2047的位表示： [00000000 00000000 00000000 00000000 00000000 00000000 00000111 11111111]</span><br><span class="line">和2047进行与操作后：  [00000000 00000000 00000000 00000000 00000000 00000000 00000001 00110111]</span><br><span class="line">r:  314233160182030736919751647047283290074158037244463871560980478788853316627874708750078214927865002494324613164753036777329719824205199439641013233466169838342774747631715248648272107024198456863680846183894703107928994710112002923069118082222231268172316199217641800603788442740611117876684040992433870125828443074830556275747757471100557196447769555568234660880002738894725057172944300128715707792997028959370378366499845797661040563264104785434051255235127705874647226767972381229546412187778354188194030704469377753477094205748594190168823677524639744</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2020/02/25/bloom%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ckqol3oax0004nwu72lfwhsdu" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-btcoin中的utxo存储" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/btcoin%E4%B8%AD%E7%9A%84utxo%E5%AD%98%E5%82%A8/">Bitcoin中的UTXO模型代码（未完善）</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/02/25/btcoin%E4%B8%AD%E7%9A%84utxo%E5%AD%98%E5%82%A8/" class="article-date"><time datetime="2020-02-25T15:54:34.000Z" itemprop="datePublished">2020-02-25</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h5 id="package-blockchain"><a href="#package-blockchain" class="headerlink" title="package blockchain"></a>package blockchain</h5><p>Package blockchain implements bitcoin block handling and chain selection rules.</p>
<p>The bitcoin block handling and chain selection rules are an integral, and quite likely the most important, part of bitcoin. Unfortunately, at the time of this writing, these rules are also largely undocumented and had to be ascertained from the bitcoind source code. At its core, bitcoin is a distributed consensus of which blocks are valid and which ones will comprise the main block chain (public ledger) that ultimately determines accepted transactions, so it is extremely important that fully validating nodes agree on all rules.</p>
<h5 id="files"><a href="#files" class="headerlink" title="files"></a>files</h5><p>utxoset的操作中涉及到chainio.go upgrade.go validate.go</p>
<h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">latestUtxoSetBucketVersion = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>最新的UtxoSetBuket版本</p>
<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utxoSetVersionKeyName = []<span class="keyword">byte</span>(<span class="string">&quot;utxosetversion&quot;</span>)</span><br><span class="line">utxoSetBucketName = []<span class="keyword">byte</span>(<span class="string">&quot;utxosetv2&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>leveldb中存储utxoVersion的Key的名字</p>
<p>leveldb中存储utxoBuket的Key的名字</p>
<h5 id="func-dbFetchUtxoEntryByHash"><a href="#func-dbFetchUtxoEntryByHash" class="headerlink" title="func dbFetchUtxoEntryByHash"></a>func dbFetchUtxoEntryByHash</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dbFetchUtxoEntryByHash</span><span class="params">(dbTx database.Tx, hash *chainhash.Hash)</span> <span class="params">(*UtxoEntry, error)</span></span> </span><br></pre></td></tr></table></figure>

<p>用给定的hash取得对应的utxo，使用光标实现（为实现最效率），若没有则返回null</p>
<h5 id="func-dbFetchUtxoEntry"><a href="#func-dbFetchUtxoEntry" class="headerlink" title="func dbFetchUtxoEntry"></a>func dbFetchUtxoEntry</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dbFetchUtxoEntry</span><span class="params">(dbTx database.Tx, outpoint wire.OutPoint)</span> <span class="params">(*UtxoEntry, error)</span></span></span><br></pre></td></tr></table></figure>

<p>用数据库中已经存在的交易从utxo中取出交易的输出</p>
<h5 id="func-dbPutUtxoView"><a href="#func-dbPutUtxoView" class="headerlink" title="func dbPutUtxoView"></a>func dbPutUtxoView</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dbPutUtxoView</span><span class="params">(dbTx database.Tx, view *UtxoViewpoint)</span> <span class="title">error</span></span> </span><br><span class="line">	<span class="keyword">for</span> outpoint, entry := <span class="keyword">range</span> view.entries &#123;</span><br><span class="line">		...</span><br><span class="line">        <span class="comment">// No need to update the database if the entry was not modified.</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// Remove the utxo entry if it is spent.</span></span><br><span class="line">		...</span><br><span class="line">        <span class="comment">// Serialize and store the utxo entry.</span></span><br><span class="line">...</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> The key is intentionally not recycled here since the</span></span><br><span class="line">		<span class="comment">// database interface contract prohibits modifications.  It will</span></span><br><span class="line">		<span class="comment">// be garbage collected normally when the database is done with</span></span><br><span class="line">		<span class="comment">// it.</span></span><br></pre></td></tr></table></figure>

<p>dbPutUtxoView使用现有的数据库的交易，根据提供的utxo视图内容和状态，更新数据库中的utxo集。特别是，只有标记为修改的条目才会写入数据库。</p>
<p>这个地方比较重要，基本上就是根据tx把把utxo集一顿修改，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *BlockChain)</span> <span class="title">createChainState</span><span class="params">()</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>建立创世区块，初始化各种数据库Bucket，在这个过程中调用了dbPutVersion(dbTx,utxoSetVersionKeyName,latestUtxoSetBucketVersion)函数和CreateBucket(utxoSetBucketName)存储utxo集的元数据和utxo集数据库Bucket</p>
<h5 id="func-upgradeUtxoSetToV2"><a href="#func-upgradeUtxoSetToV2" class="headerlink" title="func upgradeUtxoSetToV2"></a>func upgradeUtxoSetToV2</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upgradeUtxoSetToV2</span><span class="params">(db database.DB, interrupt &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>批量将utxo集条目从版本1迁移到2。</p>
<h5 id="func-b-BlockChain-maybeUpgradeDbBuckets"><a href="#func-b-BlockChain-maybeUpgradeDbBuckets" class="headerlink" title="func (b *BlockChain) maybeUpgradeDbBuckets"></a>func (b *BlockChain) maybeUpgradeDbBuckets</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *BlockChain) maybeUpgradeDbBuckets(interrupt &lt;-chan struct&#123;&#125;) error</span><br></pre></td></tr></table></figure>

<p>检查此包里buckets的database是否为最新，并升级到最新</p>
<h5 id="func-b-BlockChain-checkConnectBlock"><a href="#func-b-BlockChain-checkConnectBlock" class="headerlink" title="func (b *BlockChain) checkConnectBlock"></a>func (b *BlockChain) checkConnectBlock</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (b *BlockChain) checkConnectBlock(node *blockNode, block *btcutil.Block, view *UtxoViewpoint, stxos *[]SpentTxOut) error</span><br></pre></td></tr></table></figure>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2020/02/25/btcoin%E4%B8%AD%E7%9A%84utxo%E5%AD%98%E5%82%A8/" data-id="ckqol3oax0005nwu70smcclwd" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bitcoin/" rel="tag">Bitcoin</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-trie代码分析" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/trie%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">以太坊中的MPT树代码分析</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/02/25/trie%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date"><time datetime="2020-02-25T15:54:34.000Z" itemprop="datePublished">2020-02-25</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>MPT树在我的一个笔记中已经将过了（<a href="./%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">以太坊中的数据结构</a>）</p>
<p>在/trie目录下，geth给出了通用的MPT树的具体实现，下面分析一下代码。</p>
<p> 可以将 Trie 看做一个黑盒，分析下它暴露了什么接口。</p>
<p>[TOC]</p>
<!--more-->

<h2 id="1-各个模块的大概作用"><a href="#1-各个模块的大概作用" class="headerlink" title="1.各个模块的大概作用"></a>1.各个模块的大概作用</h2><p>database.go：数据库是在trie数据结构和磁盘数据库之间的中间写入层。 目的是在内存中积累trie写操作，并且仅定期刷新一对尝试写入磁盘的内容，垃圾收集剩余的内容。</p>
<p>encoding.go：和hex编码有关</p>
<p>iterator.go：迭代器</p>
<p>node.go：定义了trie的四种节点和对节点的编码，数值类型操作，错误处理等。</p>
<p>proof.go：默克尔证明</p>
<p>secure_trie.go：SecureTrie使用密钥散列来包装Trie。 在安全的尝试下，所有访问操作使用keccak256对密钥进行哈希处理。 这样可以防止通过创建较长的节点链来调用代码，这会增加访问时间。与常规树相反，SecureTrie只能使用新建，并且必须具有附加的数据库。 该数据库还存储每个键的原像。不能并发使用。</p>
<p>sync.go：同步是主要的状态Trie同步调度程序，它提供了要检索的未知trie哈希，接受与所述哈希关联的节点数据并逐步重建trie，直到全部完成。</p>
<p>sync_bloom.go：快速同步过程中使用的Bloom筛选器，用于快速确定磁盘上是否已经存在Trie节点。 </p>
<p>trie.go：主要的定义</p>
<h2 id="2-一些比较重要的接口"><a href="#2-一些比较重要的接口" class="headerlink" title="2.一些比较重要的接口"></a>2.一些比较重要的接口</h2><h3 id="定义trie的结构："><a href="#定义trie的结构：" class="headerlink" title="定义trie的结构："></a>定义trie的结构：</h3><p>trie/go:树的结构，empty定义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// emptyRoot is the known root hash of an empty trie.</span></span><br><span class="line">	emptyRoot = common.HexToHash(<span class="string">&quot;56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// emptyState is the known hash of an empty state trie entry.</span></span><br><span class="line">	emptyState = crypto.Keccak256Hash(<span class="literal">nil</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">	db   *Database</span><br><span class="line">	root node</span><br><span class="line">	<span class="comment">// Keep track of the number leafs which have been inserted since the last</span></span><br><span class="line">	<span class="comment">// hashing operation. This number will not directly map to the number of</span></span><br><span class="line">	<span class="comment">// actually unhashed nodes</span></span><br><span class="line">	unhashed <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>node.go:定义规范化mpt树的叶子节点</p>
<p><img src="picture/4.png" alt="4"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">interface</span> &#123;</span><br><span class="line">	fstring(<span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">	cache() (hashNode, <span class="keyword">bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	fullNode <span class="keyword">struct</span> &#123; <span class="comment">//可以携带多个子节点的节点</span></span><br><span class="line">		Children [<span class="number">17</span>]node <span class="comment">// Actual trie node data to encode/decode (needs custom encoder)</span></span><br><span class="line">		flags    nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	shortNode <span class="keyword">struct</span> &#123; <span class="comment">//只带一个子节点的节点</span></span><br><span class="line">		Key   []<span class="keyword">byte</span></span><br><span class="line">		Val   node</span><br><span class="line">		flags nodeFlag</span><br><span class="line">	&#125;</span><br><span class="line">	hashNode  []<span class="keyword">byte</span> <span class="comment">//hashNode 是 fullNode 或 shortNode 对象的 RLP 编码的32 byte 的哈希值，表明该节点还没有载入内存</span></span><br><span class="line">	valueNode []<span class="keyword">byte</span> <span class="comment">//表示真正带有值的节点</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>trie.go：与mpt树有关的基本操作</p>
<h3 id="新建MPT树"><a href="#新建MPT树" class="headerlink" title="新建MPT树"></a>新建MPT树</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(root common.Hash, db *Database)</span> <span class="params">(*Trie, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> db == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;trie.New called without a database&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	trie := &amp;Trie&#123;</span><br><span class="line">		db: db,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root != (common.Hash&#123;&#125;) &amp;&amp; root != emptyRoot &#123;</span><br><span class="line">		rootnode, err := trie.resolveHash(root[:], <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		trie.root = rootnode</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> trie, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">tryGet</span><span class="params">(origNode node, key []<span class="keyword">byte</span>, pos <span class="keyword">int</span>)</span> <span class="params">(value []<span class="keyword">byte</span>, newnode node, didResolve <span class="keyword">bool</span>, err error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">TryUpdate</span><span class="params">(key, value []<span class="keyword">byte</span>)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">insert</span><span class="params">(n node, prefix, key []<span class="keyword">byte</span>, value node)</span> <span class="params">(<span class="keyword">bool</span>, node, error)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">delete</span><span class="params">(n node, prefix, key []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">bool</span>, node, error)</span></span> </span><br></pre></td></tr></table></figure>

<h3 id="解析哈希"><a href="#解析哈希" class="headerlink" title="解析哈希"></a>解析哈希</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">resolveHash</span><span class="params">(n hashNode, prefix []<span class="keyword">byte</span>)</span></span></span><br><span class="line">-&gt;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *Database)</span> <span class="title">node</span><span class="params">(hash common.Hash)</span> <span class="title">node</span></span></span><br><span class="line">-&gt;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mustDecodeNode</span><span class="params">(hash, buf []<span class="keyword">byte</span>)</span> <span class="title">node</span></span> </span><br><span class="line">-&gt;</span><br><span class="line"><span class="comment">// decodeNode parses the RLP encoding of a trie node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeNode</span><span class="params">(hash, buf []<span class="keyword">byte</span>)</span> <span class="params">(node, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(buf) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, io.ErrUnexpectedEOF</span><br><span class="line">	&#125;</span><br><span class="line">	elems, _, err := rlp.SplitList(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;decode error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> c, _ := rlp.CountValues(elems); c &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		n, err := decodeShort(hash, elems)</span><br><span class="line">		<span class="keyword">return</span> n, wrapError(err, <span class="string">&quot;short&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">17</span>:</span><br><span class="line">		n, err := decodeFull(hash, elems)</span><br><span class="line">		<span class="keyword">return</span> n, wrapError(err, <span class="string">&quot;full&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;invalid number of list elements: %v&quot;</span>, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将mpt树写入内存"><a href="#将mpt树写入内存" class="headerlink" title="将mpt树写入内存"></a>将mpt树写入内存</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Commit</span><span class="params">(onleaf LeafCallback)</span> <span class="params">(root common.Hash, err error)</span></span> </span><br></pre></td></tr></table></figure>

<h3 id="获取根哈希"><a href="#获取根哈希" class="headerlink" title="获取根哈希"></a>获取根哈希</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">hashRoot</span><span class="params">(db *Database)</span> <span class="params">(node, node, error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="rlp编码"><a href="#rlp编码" class="headerlink" title="rlp编码"></a>rlp编码</h3><p>database.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *cachedNode)</span> <span class="title">rlp</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> node, ok := n.node.(rawNode); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">	&#125;</span><br><span class="line">	blob, err := rlp.EncodeToBytes(n.node)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> blob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默克尔证明"><a href="#默克尔证明" class="headerlink" title="默克尔证明"></a>默克尔证明</h3><p>proof.go: prove方法用来获取指定 key 的默克尔证明。这个方法会遍历整个 MPT，获取从根节点到叶子节点这条路径上的所有节点的 hash 值列表。对于 key 不匹配的情况，则会返回一个最长匹配的列表。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SecureTrie)</span> <span class="title">Prove</span><span class="params">(key []<span class="keyword">byte</span>, fromLevel <span class="keyword">uint</span>, proofDb ethdb.KeyValueWriter)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> t.trie.Prove(key, fromLevel, proofDb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Trie)</span> <span class="title">Prove</span><span class="params">(key []<span class="keyword">byte</span>, fromLevel <span class="keyword">uint</span>, proofDb ethdb.KeyValueWriter)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Collect all nodes on the path to key.</span></span><br><span class="line">	key = keybytesToHex(key)</span><br><span class="line">	<span class="keyword">var</span> nodes []node</span><br><span class="line">	tn := t.root</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(key) &gt; <span class="number">0</span> &amp;&amp; tn != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> n := tn.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *shortNode:</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(key) &lt; <span class="built_in">len</span>(n.Key) || !bytes.Equal(n.Key, key[:<span class="built_in">len</span>(n.Key)]) &#123;</span><br><span class="line">				<span class="comment">// The trie doesn&#x27;t contain the key.</span></span><br><span class="line">				tn = <span class="literal">nil</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				tn = n.Val</span><br><span class="line">				key = key[<span class="built_in">len</span>(n.Key):]</span><br><span class="line">			&#125;</span><br><span class="line">			nodes = <span class="built_in">append</span>(nodes, n)</span><br><span class="line">		<span class="keyword">case</span> *fullNode:</span><br><span class="line">			tn = n.Children[key[<span class="number">0</span>]]</span><br><span class="line">			key = key[<span class="number">1</span>:]</span><br><span class="line">			nodes = <span class="built_in">append</span>(nodes, n)</span><br><span class="line">		<span class="keyword">case</span> hashNode:</span><br><span class="line">			<span class="keyword">var</span> err error</span><br><span class="line">			tn, err = t.resolveHash(n, <span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Error(fmt.Sprintf(<span class="string">&quot;Unhandled trie error: %v&quot;</span>, err))</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%T: invalid node: %v&quot;</span>, tn, tn))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	hasher := newHasher(<span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">defer</span> returnHasherToPool(hasher)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, n := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">		<span class="keyword">if</span> fromLevel &gt; <span class="number">0</span> &#123;</span><br><span class="line">			fromLevel--</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> hn node</span><br><span class="line">		n, hn = hasher.proofHash(n)</span><br><span class="line">		<span class="keyword">if</span> hash, ok := hn.(hashNode); ok || i == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// If the node&#x27;s database encoding is a hash (or is the</span></span><br><span class="line">			<span class="comment">// root node), it becomes a proof element.</span></span><br><span class="line">			enc, _ := rlp.EncodeToBytes(n)</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				hash = hasher.hashData(enc)</span><br><span class="line">			&#125;</span><br><span class="line">			proofDb.Put(hash, enc)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> VerifyProof 方法以 roothash，key，proof 证明为参数，验证 key 是否存在于 MPT 的某条路径里，如果 key 确实存在，返回这个节点的索引 i，err 字段是 nil，否则返回 error。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifyProof</span><span class="params">(rootHash common.Hash, key []<span class="keyword">byte</span>, proofDb ethdb.KeyValueReader)</span> <span class="params">(value []<span class="keyword">byte</span>, nodes <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">	key = keybytesToHex(key)</span><br><span class="line">	wantHash := rootHash</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">		buf, _ := proofDb.Get(wantHash[:])</span><br><span class="line">		<span class="keyword">if</span> buf == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, i, fmt.Errorf(<span class="string">&quot;proof node %d (hash %064x) missing&quot;</span>, i, wantHash)</span><br><span class="line">		&#125;</span><br><span class="line">		n, err := decodeNode(wantHash[:], buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, i, fmt.Errorf(<span class="string">&quot;bad proof node %d: %v&quot;</span>, i, err)</span><br><span class="line">		&#125;</span><br><span class="line">		keyrest, cld := get(n, key)</span><br><span class="line">		<span class="keyword">switch</span> cld := cld.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">// The trie doesn&#x27;t contain the key.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, i, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> hashNode:</span><br><span class="line">			key = keyrest</span><br><span class="line">			<span class="built_in">copy</span>(wantHash[:], cld)</span><br><span class="line">		<span class="keyword">case</span> valueNode:</span><br><span class="line">			<span class="keyword">return</span> cld, i + <span class="number">1</span>, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h6><p> MPT 的 key 值实际上有三种编码方法，Raw 编码，Hex 编码，HP 编码，Raw 编码即原始的字节数组，这种方式的问题是它的一个字节的范围很大，fullNode 的子树这么多会影响检索效率，当树节点需要存储到数据库时，会根据16进制来进行编码，Hex 编码和 HP 编码没本质区别，可以理解为 Hex 编码是存在于内存的中间形式，在以太坊的黄皮书了介绍的是 Hex Prefix Encoding，即 HP 编码。 </p>
<h3 id="RAW编码"><a href="#RAW编码" class="headerlink" title="RAW编码"></a><strong>RAW编码</strong></h3><p> 原生的 key 字节数组，不做修改，这种方式是 MPT 对外提供 API 的默认方式，如果数据需要插入到树里，Raw 编码需要转换为 Hex 编码。 </p>
<h3 id="Hex编码"><a href="#Hex编码" class="headerlink" title="Hex编码"></a><strong>Hex编码</strong></h3><p>Hex 编码用于对内存里的树节点 key 进行编码，当树节点需要持久化到数据库时，Hex 编码被转换为 HP 编码。</p>
<p>具体来说，这个编码的每个字节包含 key 的半个字节，尾部加一个 byte 的『终结符』16，表示这是 hex 格式。节点被加载到内存时 key 使用的是这种编码，因为方便访问。</p>
<p>encoding.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keybytesToHex</span><span class="params">(str []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(str)*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> nibbles = <span class="built_in">make</span>([]<span class="keyword">byte</span>, l)</span><br><span class="line">	<span class="keyword">for</span> i, b := <span class="keyword">range</span> str &#123;</span><br><span class="line">		nibbles[i*<span class="number">2</span>] = b / <span class="number">16</span></span><br><span class="line">		nibbles[i*<span class="number">2</span>+<span class="number">1</span>] = b % <span class="number">16</span></span><br><span class="line">	&#125;</span><br><span class="line">	nibbles[l<span class="number">-1</span>] = <span class="number">16</span></span><br><span class="line">	<span class="keyword">return</span> nibbles</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HP编码"><a href="#HP编码" class="headerlink" title="HP编码"></a><strong>HP编码</strong></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToCompact</span><span class="params">(hex []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	terminator := <span class="keyword">byte</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> hasTerm(hex) &#123;</span><br><span class="line">		terminator = <span class="number">1</span></span><br><span class="line">		hex = hex[:<span class="built_in">len</span>(hex)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(hex)/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">	buf[<span class="number">0</span>] = terminator &lt;&lt; <span class="number">5</span> <span class="comment">// the flag byte</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(hex)&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">		buf[<span class="number">0</span>] |= <span class="number">1</span> &lt;&lt; <span class="number">4</span> <span class="comment">// odd flag</span></span><br><span class="line">		buf[<span class="number">0</span>] |= hex[<span class="number">0</span>] <span class="comment">// first nibble is contained in the first byte</span></span><br><span class="line">		hex = hex[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	decodeNibbles(hex, buf[<span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">return</span> buf</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>全称是 Hex Prefix 编码，hex 编码解决了 key 是 keybytes 形式的数据插入 MPT 的问题，但这种方式有数据冗余的问题，对于 shortNode，目前 hex 格式下的 key，长度会是原来 keybytes 格式下的两倍，这一点对于节点的哈希计算影响很大，compact 编码用于对 hex 格式进行优化。compact encoding 的主要思路是将 Hex 格式字符串先恢复到 keybytes 格式，同时加入当前编码的标记位，表示奇偶不同长度的 hex 格式。</p>
<p>具体来说，compact 编码首先会将 hex 尾部标记的 byte 去掉，然后将原来 hex 编码的包含的 key 的半个字节（称为 nibble）一一合并为1 byte，最后如果 hex 格式编码有效长度为奇数，在头部增加 0011xxxx，其中 xxxx 为第一个 nibble，否则在头部增加 00100000。节点在写入数据库时使用的是 compact 编码，因为可以节约磁盘。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2020/02/25/trie%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ckqol3obg000ynwu7eo8h6zcb" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-以太坊Ghost协议" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/%E4%BB%A5%E5%A4%AA%E5%9D%8AGhost%E5%8D%8F%E8%AE%AE/">以太坊中的GHOST协议</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/02/25/%E4%BB%A5%E5%A4%AA%E5%9D%8AGhost%E5%8D%8F%E8%AE%AE/" class="article-date"><time datetime="2020-02-25T15:54:34.000Z" itemprop="datePublished">2020-02-25</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>前提条件：</p>
<p>比特币选用最长的链作为有效链。出块时间大概为10分钟，orphan block的出现较少。然而以太坊出块已经缩短为十几秒一个块，如果也只选用最长的链作为有效链，那么会大大地影响矿工的积极性。而且比特币的这种方式很可能会造成算力与奖励的不对等。</p>
<p>核心思想：对挖到无效的区块矿工给予奖励</p>
<p>挖到叔父区块根据离主区块的距离，得到7/8 6/8 …… 2/8 的区块奖励</p>
<p>包括一个叔父区块得到1/32的区块奖励</p>
<p><img src="./picture/5.png"></p>
<p>GHOST协议只给七代以内奖励： 鼓励分叉尽快合并</p>
<p>GHOST协议只给分叉后第一个区块奖励：防止分叉攻击</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2020/02/25/%E4%BB%A5%E5%A4%AA%E5%9D%8AGhost%E5%8D%8F%E8%AE%AE/" data-id="ckqol3obi0013nwu7dt8q4r1r" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-以太坊中的数据结构" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">以太坊中的主要数据结构</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/02/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date"><time datetime="2020-02-25T15:54:34.000Z" itemprop="datePublished">2020-02-25</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h3 id="1-区块"><a href="#1-区块" class="headerlink" title="1.区块"></a>1.区块</h3><p>区块主要由三部分组成：区块头（Block Header），叔块（Uncle），区块体（body）</p>
<h4 id="区块头"><a href="#区块头" class="headerlink" title="区块头"></a>区块头</h4><p>区块头的结构体定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123; </span><br><span class="line">    ParentHash  common.Hash    <span class="string">`json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</span>  </span><br><span class="line">    UncleHash   common.Hash    <span class="string">`json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</span>  </span><br><span class="line">    Coinbase    common.Address <span class="string">`json:&quot;miner&quot;            gencodec:&quot;required&quot;`</span>  </span><br><span class="line">    Root        common.Hash    <span class="string">`json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</span> </span><br><span class="line">    TxHash      common.Hash    <span class="string">`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</span>              ReceiptHash common.Hash    <span class="string">`json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</span></span><br><span class="line">    Bloom       Bloom          <span class="string">`json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</span> </span><br><span class="line">    Difficulty  *big.Int       <span class="string">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">    Number      *big.Int       <span class="string">`json:&quot;number&quot;           gencodec:&quot;required&quot;`</span> </span><br><span class="line">    GasLimit    <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</span> </span><br><span class="line">    GasUsed     <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</span></span><br><span class="line">    Time        <span class="keyword">uint64</span>         <span class="string">`json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</span> </span><br><span class="line">    Extra       []<span class="keyword">byte</span>         <span class="string">`json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</span>  </span><br><span class="line">    MixDigest   common.Hash    <span class="string">`json:&quot;mixHash&quot;`</span> </span><br><span class="line">    Nonce       BlockNonce     <span class="string">`json:&quot;nonce&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>释义如下：</p>
<p>ParentHash  common.Hash   父区块的哈希值<br>UncleHash    common.Hash    叔父区块列表的哈希值<br>Coinbase    common.Address    打包该区块的矿工的地址，用于接收矿工费<br>Root    common.Hash    状态树的根哈希值<br>TxHash    common.Hash    交易树的根哈希值<br>ReceiptHash    common.Hash    收据树的根哈希值<br>Bloom    Bloom    交易收据日志组成的Bloom过滤器<br>Difficulty    *Big.Int    本区块的难度<br>Number    *Big.Int    本区块块号，区块号从0号开始算起<br>GasLimit    uint64    本区块中所有交易消耗的Gas上限，这个数值不等于所有交易的中Gas limit字段的和<br>GasUsed    uint64    本区块中所有交易使用的Gas之和<br>Time    *big.Int    区块产生的unix时间戳，一般是打包区块的时间，这个字段不是出块的时间戳<br>Extra    []byte    区块的附加数据<br>MixDigest    common.Hash    哈希值，与Nonce的组合用于工作量计算<br>Nonce    BlockNonce    区块产生时的随机值</p>
<p>与比特币一样，以太坊中区块和区块之间用哈希指针向连，通过哈希可以追溯到最初的区块。</p>
<p>轻节点只保存区块头。</p>
<h4 id="叔块"><a href="#叔块" class="headerlink" title="叔块"></a>叔块</h4><h5 id="孤块-orphan-block"><a href="#孤块-orphan-block" class="headerlink" title="孤块(orphan block)"></a>孤块(orphan block)</h5><p>在比特币协议中，最长的链被认为是绝对的正确。如果一个块不是最长链的一部分，那么它被称为是“孤块”。一个孤立的块是一个块，它也是合法的，但是发现的稍晚，或者是网络传输稍慢，而没有能成为最长的链的一部分。在比特币中，孤块没有意义，随后将被抛弃，发现这个孤块的矿工也拿不到采矿相关的奖励。</p>
<h5 id="最重的链-heaviest"><a href="#最重的链-heaviest" class="headerlink" title="最重的链(heaviest)"></a>最重的链(heaviest)</h5><p>Ethereum的GHOST协议，不认为孤块没有价值，而是会给与发现孤块的矿工以回报。在以太坊中，孤块被称为“叔块”(uncle block)，它们可以为主链的安全作出贡献。</p>
<p>相对来说，比特币有很长的块间隔时间。在比特币区块中，平均约10分钟可以得到一个确认(也就是发现一个新的后续区块)。但是自从比特币成立以来，大量关于块链技术的研究已经发展起来。这些研究表明，更短的块间隔确实是可能的，而且在很多应用场景下是需要的。然而，随着拥有更快的出块速度，孤块的增加而带来的昂贵的成本和浪费也随之增加。</p>
<p>GHOST协议支付报酬给叔块，这激励了矿工在新发现的块中去引用叔块。引用叔块使主链更重。在比特币，最长的链是主链。在以太坊中，主链是指最重的链。</p>
<h5 id="叔块的好处"><a href="#叔块的好处" class="headerlink" title="叔块的好处"></a>叔块的好处</h5><p>解决了两个问题：</p>
<ol>
<li>以太坊十几秒的出块间隔，大大增加了孤块的产生，并且降低了安全性。通过鼓励引用叔块，使引用主链获得更多的安全保证(因为孤块本身也是合法的)</li>
<li>比特币中，采矿中心化(大量的集中矿池)成为一个问题。给与叔块报酬，可以一定程度上缓解这个问题。</li>
</ol>
<h5 id="叔块的引用"><a href="#叔块的引用" class="headerlink" title="叔块的引用"></a>叔块的引用</h5><p>区块可以不引用，或者最多引用两个叔块<br>叔块必须是区块的前2层~前7层的祖先的直接的子块<br>被引用过的叔块不能重复引用<br>引用叔块的区块，可以获得挖矿报酬的1/32，也就是5<em>1/32=0.15625 Ether。最多获得2</em>0.15625=0.3125 Ether<br>被引用的叔块，其矿工的报酬和叔块与区块之间的间隔层数有关系。</p>
<table>
<thead>
<tr>
<th>间隔层数</th>
<th>报酬比例</th>
<th>报酬</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>7/8</td>
<td>4.375</td>
</tr>
<tr>
<td>2</td>
<td>6/8</td>
<td>3.75</td>
</tr>
<tr>
<td>3</td>
<td>5/8</td>
<td>3.125</td>
</tr>
<tr>
<td>4</td>
<td>4/8</td>
<td>2.5</td>
</tr>
<tr>
<td>5</td>
<td>3/8</td>
<td>1.875</td>
</tr>
<tr>
<td>6</td>
<td>2/8</td>
<td>1.25</td>
</tr>
</tbody></table>
<h4 id="区块体"><a href="#区块体" class="headerlink" title="区块体"></a>区块体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Body <span class="keyword">struct</span> &#123;</span><br><span class="line">    Transactions []*Transaction  </span><br><span class="line">    Uncles       []*Header</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Body是一个简单的（可变的、非安全的）数据容器，用于存储和移动块的数据内容（事务和uncles）。</p>
<h4 id="完整的区块定义"><a href="#完整的区块定义" class="headerlink" title="完整的区块定义"></a>完整的区块定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;   </span><br><span class="line">    header       *Header  </span><br><span class="line">    uncles       []*Header </span><br><span class="line">    transactions Transactions </span><br><span class="line">    <span class="comment">// caches   hash atomic.Value   size atomic.Value  </span></span><br><span class="line">    <span class="comment">// Td is used by package core to store the total difficulty   </span></span><br><span class="line">    <span class="comment">// of the chain up to and including the block.   td *big.Int  </span></span><br><span class="line">    <span class="comment">// These fields are used by package eth to track  </span></span><br><span class="line">    <span class="comment">// inter-peer block relay.   ReceivedAt   time.</span></span><br><span class="line">    Time   ReceivedFrom <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-MPT树"><a href="#2-MPT树" class="headerlink" title="2.MPT树"></a>2.MPT树</h3><h4 id="trie"><a href="#trie" class="headerlink" title="trie"></a>trie</h4><p>trie也叫字典树，前缀树，因为它的搜索快捷的特性被单词搜索系统使用，故又称单词查找树。它是一种树形结构的数据结构。之所以快速，是因为它用空间代替了速度。</p>
<p>如给出字符串”abc”,”ab”,”bd”,”dda”，根据该字符串序列构建一棵Trie树。则构建的树如下: </p>
<p><img src="./1.jpg"></p>
<h4 id="Patricia-Trie"><a href="#Patricia-Trie" class="headerlink" title="Patricia Trie"></a>Patricia Trie</h4><p>又叫做基数树，压缩前缀树或紧凑前缀树（compact prefix tree)，是一种更节省空间的前缀树。它与 Trie 的区别是，如果某个节点只有一个子树，那么这个子树跟父节点合并，这样可以缩短 Trie 里不必要的深度，节约存储空间，加快搜索节点的速度。 </p>
<p><img src="./2.png"></p>
<p> 以太坊中每个用户地址是160位存储，如果使用不压缩的trie会造成非常大的存储浪费，维护状态树会变得异常困难。所以使用压缩前缀树。 </p>
<h4 id="Merkle-Tree"><a href="#Merkle-Tree" class="headerlink" title="Merkle Tree"></a>Merkle Tree</h4><p>比特币中，交易列表使用非排序的默克尔树存储，其和二叉树的区别主要是使用哈希指针代替了二叉树中的指针。</p>
<p><img src="./3.png"></p>
<h4 id="Merkle-Patricia-Tree-Trie"><a href="#Merkle-Patricia-Tree-Trie" class="headerlink" title="Merkle Patricia Tree (Trie)"></a>Merkle Patricia Tree (Trie)</h4><p>Merkle Patricia Tree 默克尔-帕特里夏树是一种融合了默克尔树和前缀树两种结构优点的，经过改良的数据结构，在以太坊中用来组织交易信息、账户状态及其变更、收据相关的数据。</p>
<p>以太坊中的MPT树是经过改良的，模范化的MPT树。</p>
<p><img src="./4.png"></p>
<p>树中的节点分类：</p>
<p>空节点 </p>
<p>分支节点 </p>
<p>叶子节点 </p>
<p>扩展节点 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">interface</span> &#123;	</span><br><span class="line">    fstring(<span class="keyword">string</span>) <span class="keyword">string</span>	</span><br><span class="line">    cache() (hashNode, <span class="keyword">bool</span>)	</span><br><span class="line">    canUnload(cachegen, cachelimit <span class="keyword">uint16</span>) <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (	</span><br><span class="line">    </span><br><span class="line">    fullNode <span class="keyword">struct</span> &#123;	</span><br><span class="line">        Children [<span class="number">17</span>]node		</span><br><span class="line">        flags    nodeFlag	</span><br><span class="line">    &#125;	</span><br><span class="line">    shortNode <span class="keyword">struct</span> &#123;	</span><br><span class="line">        Key   []<span class="keyword">byte</span>		Val   node		flags nodeFlag	</span><br><span class="line">    &#125;	</span><br><span class="line">    hashNode  []<span class="keyword">byte</span></span><br><span class="line">    valueNode []<span class="keyword">byte</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> nodeFlag <span class="keyword">struct</span></span><br><span class="line">&#123;	</span><br><span class="line">    hash  hashNode	</span><br><span class="line">    gen   <span class="keyword">uint16</span>	</span><br><span class="line">    dirty <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="fullNode"><a href="#fullNode" class="headerlink" title="fullNode"></a>fullNode</h6><p>fullNode 是一个可以携带多个子节点的节点。它有一个 node 数组类型的成员变量 Children，数组的前16个空位分别对应十六进制的0-9a-f，对于每个子节点，根据其 key 值的十六进制表示一一对应，Children 数组的第17位，fullNode 用来存储数据。</p>
<p>对应黄皮书中的分支节点。</p>
<h6 id="shortNode"><a href="#shortNode" class="headerlink" title="shortNode"></a>shortNode</h6><p>shortNode 是一个仅有一个子节点的节点。成员变量 Val 指向一个子节点，成员变量 Key 是一个由任意长度的字符串，这体现了压缩前缀树的特点，通过合并只有一个子节点的父节点和其子节点来缩短 Trie 的深度。</p>
<p>对应黄皮书里的扩展节点和叶子节点，通过 <code>shortNode.Val</code> 的类型来对应。</p>
<h6 id="valueNode"><a href="#valueNode" class="headerlink" title="valueNode"></a>valueNode</h6><p>valueNode 在 MPT 结构中存储真正的数据。充当 MPT 的叶子节点，不带子节点。</p>
<p>valueNode 是一个字节数组，但是它实现了 <code>fstring(string) string</code>, <code>cache() (hashNode, bool)</code>, <code>canUnload(cachegen, cachelimit uint16) bool</code> 这三个接口（实际上 fullNode，shortNode，hashNode 也实现了这三个接口），因此可以作为 fullNode，shortNode 中的 <code>node</code> 使用。valueNode 可以承接数据，携带的的是数据的 RLP 哈希值，长度为 32 byte，RLP 编码的值存在 LevelDB 里。</p>
<h6 id="hashNode"><a href="#hashNode" class="headerlink" title="hashNode"></a>hashNode</h6><p>hashNode 是 fullNode 或 shortNode 对象的 RLP 编码的32 byte 的哈希值，表明该节点还没有载入内存。遍历 MPT 时有时会遇到一个 hashNode，表明原来的 node 需要动态加载，hashNode 以 nodeFlag 结构体的成员 hash 的形式存在，如果 fullNode 或 shortNode 的成员变量发生变化，那么就需要更新它的 hashNode，在增删改的过程结束了都会调用 <code>trie.Hash()</code>，整个 MPT 自底向上变量，对所有清空的 hashNode 重新赋值，最终得到根节点的 hashNode，也就是整个 MPT 结构的哈希值。</p>
<p>fullNode 体现了 Trie 的特点，shortNode 实现了 PatriciaTrie 的特性（当然也实现了 Trie 的特性），hashNode 既实现了 MPT 节点的动态加载，也实现了默克尔树的功能。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2020/02/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="ckqol3obk0016nwu708382hob" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-状态；状态树代码分析" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/%E7%8A%B6%E6%80%81%EF%BC%9B%E7%8A%B6%E6%80%81%E6%A0%91%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">以太坊中的状态树代码</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/02/25/%E7%8A%B6%E6%80%81%EF%BC%9B%E7%8A%B6%E6%80%81%E6%A0%91%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date"><time datetime="2020-02-25T15:54:34.000Z" itemprop="datePublished">2020-02-25</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>/core/state：状态树相关文件。对其中几个重要类型和函数解析。</p>
<p>/database.go：封装数据库访问的方法</p>
<p>定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Database <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// OpenTrie opens the main account trie.</span></span><br><span class="line">	OpenTrie(root common.Hash) (Trie, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// OpenStorageTrie opens the storage trie of an account.</span></span><br><span class="line">	OpenStorageTrie(addrHash, root common.Hash) (Trie, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CopyTrie returns an independent copy of the given trie.</span></span><br><span class="line">	CopyTrie(Trie) Trie</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ContractCode retrieves a particular contract&#x27;s code.</span></span><br><span class="line">	ContractCode(addrHash, codeHash common.Hash) ([]<span class="keyword">byte</span>, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ContractCodeSize retrieves a particular contracts code&#x27;s size.</span></span><br><span class="line">	ContractCodeSize(addrHash, codeHash common.Hash) (<span class="keyword">int</span>, error)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// TrieDB retrieves the low level trie database used for data storage.</span></span><br><span class="line">	TrieDB() *trie.Database</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabase</span><span class="params">(db ethdb.Database)</span> <span class="title">Database</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewDatabaseWithCache(db, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewDatabaseWithCache creates a backing store for state. The returned database</span></span><br><span class="line"><span class="comment">// is safe for concurrent use and retains a lot of collapsed RLP trie nodes in a</span></span><br><span class="line"><span class="comment">// large memory cache.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDatabaseWithCache</span><span class="params">(db ethdb.Database, cache <span class="keyword">int</span>)</span> <span class="title">Database</span></span> &#123;</span><br><span class="line">	csc, _ := lru.New(codeSizeCacheSize)</span><br><span class="line">	<span class="keyword">return</span> &amp;cachingDB&#123;</span><br><span class="line">		db:            trie.NewDatabaseWithCache(db, cache),</span><br><span class="line">		codeSizeCache: csc,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新建数据库对象返回的其实是trie.database类型+codeSizeCache</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenTrie opens the main account trie at a specific root hash.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *cachingDB)</span> <span class="title">OpenTrie</span><span class="params">(root common.Hash)</span> <span class="params">(Trie, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> trie.NewSecure(root, db.db)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用底层的trie包中的方法，对secure的说明如下：SecureTrie使用密钥散列来包装trie。在安全trie中，所有访问操作都使用keccak256散列密钥。这可以防止调用代码创建增加访问时间的长节点链。</span></span><br><span class="line"><span class="comment">//与常规trie相反，SecureTrie只能用New创建，并且必须有附加的数据库。数据库还存储每个密钥的预映像。</span></span><br><span class="line"><span class="comment">//SecureTrie对于并发使用是不安全的。</span></span><br></pre></td></tr></table></figure>

<p>state_object.go：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stateObject表示正在修改的以太坊帐户。</span></span><br><span class="line"><span class="comment">//使用模式如下：首先需要获得一个state对象。通过对象访问和修改帐户值。最后，调用CommitTrie将修改后的存储trie写入数据库。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//stateObject的定义如下：</span></span><br><span class="line"><span class="keyword">type</span> stateObject <span class="keyword">struct</span> &#123;</span><br><span class="line">	address  common.Address</span><br><span class="line">	addrHash common.Hash <span class="comment">// hash of ethereum address of the account</span></span><br><span class="line">	data     Account</span><br><span class="line">	db       *StateDB</span><br><span class="line"></span><br><span class="line">	<span class="comment">// DB error.</span></span><br><span class="line">	<span class="comment">// State objects are used by the consensus core and VM which are</span></span><br><span class="line">	<span class="comment">// unable to deal with database-level errors. Any error that occurs</span></span><br><span class="line">	<span class="comment">// during a database read is memoized here and will eventually be returned</span></span><br><span class="line">	<span class="comment">// by StateDB.Commit.</span></span><br><span class="line">	dbErr error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write caches.</span></span><br><span class="line">	trie Trie <span class="comment">// storage trie, which becomes non-nil on first access这个trie是智能合约的那个storagetree</span></span><br><span class="line">	code Code <span class="comment">// contract bytecode, which gets set when code is loaded</span></span><br><span class="line"></span><br><span class="line">	originStorage  Storage <span class="comment">// Storage cache of original entries to dedup rewrites, reset for every transaction对原始项的存储缓存进行重复数据消除重写，为每个事务重置</span></span><br><span class="line">	pendingStorage Storage <span class="comment">// Storage entries that need to be flushed to disk, at the end of an entire block</span></span><br><span class="line">	dirtyStorage   Storage <span class="comment">// Storage entries that have been modified in the current transaction execution</span></span><br><span class="line">	fakeStorage    Storage <span class="comment">// Fake storage which constructed by caller for debugging purpose.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Cache flags.</span></span><br><span class="line">	<span class="comment">// When an object is marked suicided it will be delete from the trie</span></span><br><span class="line">	<span class="comment">// during the &quot;update&quot; phase of the state transition.</span></span><br><span class="line">	dirtyCode <span class="keyword">bool</span> <span class="comment">// true if the code was updated</span></span><br><span class="line">	suicided  <span class="keyword">bool</span></span><br><span class="line">	deleted   <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newObject</span><span class="params">(db *StateDB, address common.Address, data Account)</span> *<span class="title">stateObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span> <span class="title">getTrie</span><span class="params">(db Database)</span> <span class="title">Trie</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Storage <span class="keyword">map</span>[common.Hash]common.Hash</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetState updates a value in account storage.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span> <span class="title">SetState</span><span class="params">(db Database, key, value common.Hash)</span></span> &#123;</span><br><span class="line">	<span class="comment">// If the fake storage is set, put the temporary state update here.</span></span><br><span class="line">	<span class="keyword">if</span> s.fakeStorage != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.fakeStorage[key] = value<span class="comment">//用于调试，如果fakeStorage不是空，则优先把用于调试的storage设为value</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If the new value is the same as old, don&#x27;t set</span></span><br><span class="line">	prev := s.GetState(db, key)</span><br><span class="line">	<span class="keyword">if</span> prev == value &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// New value is different, update and journal the change</span></span><br><span class="line">	s.db.journal.<span class="built_in">append</span>(storageChange&#123;</span><br><span class="line">		account:  &amp;s.address,</span><br><span class="line">		key:      key,</span><br><span class="line">		prevalue: prev,</span><br><span class="line">	&#125;)</span><br><span class="line">	s.setState(key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span> <span class="title">setState</span><span class="params">(key, value common.Hash)</span></span> &#123;</span><br><span class="line">	s.dirtyStorage[key] = value<span class="comment">//已修改的存储项</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// finalise moves all dirty storage slots into the pending area to be hashed or</span></span><br><span class="line"><span class="comment">// committed later. It is *invoked at the end of every transaction*.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span> <span class="title">finalise</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> s.dirtyStorage &#123;</span><br><span class="line">		s.pendingStorage[key] = value<span class="comment">//在整个块的末尾，需要刷新到磁盘的存储项</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.dirtyStorage) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		s.dirtyStorage = <span class="built_in">make</span>(Storage)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//updateTrie writes cached storage modifications into the object&#x27;s storage trie.</span></span><br><span class="line"><span class="comment">//It will return nil if the trie has not been loaded and no changes have been made</span></span><br><span class="line"><span class="comment">//updaterie将缓存的存储修改写入对象的存储trie。</span></span><br><span class="line"><span class="comment">//如果未加载trie且未做任何更改，则返回nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span> <span class="title">updateTrie</span><span class="params">(db Database)</span> <span class="title">Trie</span></span> &#123;</span><br><span class="line">	<span class="comment">// Make sure all dirty slots are finalized into the pending storage area</span></span><br><span class="line">	s.finalise()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.pendingStorage) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s.trie</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Track the amount of time wasted on updating the storge trie</span></span><br><span class="line">	<span class="keyword">if</span> metrics.EnabledExpensive &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(start time.Time)</span></span> &#123; s.db.StorageUpdates += time.Since(start) &#125;(time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Insert all the pending updates into the trie</span></span><br><span class="line">	tr := s.getTrie(db)</span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> s.pendingStorage &#123;</span><br><span class="line">		<span class="comment">// Skip noop changes, persist actual changes</span></span><br><span class="line">		<span class="keyword">if</span> value == s.originStorage[key] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		s.originStorage[key] = value</span><br><span class="line"><span class="comment">//对原始项的存储缓存进行重复数据消除重写</span></span><br><span class="line">		<span class="keyword">if</span> (value == common.Hash&#123;&#125;) &#123;</span><br><span class="line">			s.setError(tr.TryDelete(key[:]))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Encoding []byte cannot fail, ok to ignore the error.</span></span><br><span class="line">		v, _ := rlp.EncodeToBytes(common.TrimLeftZeroes(value[:]))</span><br><span class="line">		s.setError(tr.TryUpdate(key[:], v))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.pendingStorage) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		s.pendingStorage = <span class="built_in">make</span>(Storage)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommitTrie the storage trie of the object to db.</span></span><br><span class="line"><span class="comment">// This updates the trie root.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *stateObject)</span> <span class="title">CommitTrie</span><span class="params">(db Database)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// If nothing changed, don&#x27;t bother with hashing anything</span></span><br><span class="line">	<span class="keyword">if</span> s.updateTrie(db) == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s.dbErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> s.dbErr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Track the amount of time wasted on committing the storge trie</span></span><br><span class="line">	<span class="keyword">if</span> metrics.EnabledExpensive &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(start time.Time)</span></span> &#123; s.db.StorageCommits += time.Since(start) &#125;(time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	root, err := s.trie.Commit(<span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// Commit writes all nodes to the trie&#x27;s memory database, tracking the internal</span></span><br><span class="line">	<span class="comment">// and external (for account tries) references.</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.data.Root = root</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>statedb.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StateDBs within the ethereum protocol are used to store anything</span></span><br><span class="line"><span class="comment">//within the merkle trie. StateDBs take care of caching and storing</span></span><br><span class="line"><span class="comment">//nested states. It&#x27;s the general query interface to retrieve:</span></span><br><span class="line"><span class="comment">//* Contracts</span></span><br><span class="line"><span class="comment">//* Accounts</span></span><br><span class="line"><span class="keyword">type</span> StateDB <span class="keyword">struct</span> &#123;</span><br><span class="line">	db   Database</span><br><span class="line">	trie Trie</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This map holds &#x27;live&#x27; objects, which will get modified while processing a state transition.</span></span><br><span class="line">	stateObjects        <span class="keyword">map</span>[common.Address]*stateObject</span><br><span class="line">	stateObjectsPending <span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// State objects finalized but not yet written to the trie</span></span><br><span class="line">	stateObjectsDirty   <span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// State objects modified in the current execution</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// DB error.</span></span><br><span class="line">	<span class="comment">// State objects are used by the consensus core and VM which are</span></span><br><span class="line">	<span class="comment">// unable to deal with database-level errors. Any error that occurs</span></span><br><span class="line">	<span class="comment">// during a database read is memoized here and will eventually be returned</span></span><br><span class="line">	<span class="comment">// by StateDB.Commit.</span></span><br><span class="line">	dbErr error</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The refund counter, also used by state transitioning.</span></span><br><span class="line">	refund <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	thash, bhash common.Hash</span><br><span class="line">	txIndex      <span class="keyword">int</span></span><br><span class="line">	logs         <span class="keyword">map</span>[common.Hash][]*types.Log</span><br><span class="line">	logSize      <span class="keyword">uint</span></span><br><span class="line"></span><br><span class="line">	preimages <span class="keyword">map</span>[common.Hash][]<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Journal of state modifications. This is the backbone of</span></span><br><span class="line">	<span class="comment">// Snapshot and RevertToSnapshot.</span></span><br><span class="line">	journal        *journal</span><br><span class="line">	validRevisions []revision</span><br><span class="line">	nextRevisionId <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Measurements gathered during execution for debugging purposes</span></span><br><span class="line">	AccountReads   time.Duration</span><br><span class="line">	AccountHashes  time.Duration</span><br><span class="line">	AccountUpdates time.Duration</span><br><span class="line">	AccountCommits time.Duration</span><br><span class="line">	StorageReads   time.Duration</span><br><span class="line">	StorageHashes  time.Duration</span><br><span class="line">	StorageUpdates time.Duration</span><br><span class="line">	StorageCommits time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span> <span class="title">updateStateObject</span><span class="params">(obj *stateObject)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Track the amount of time wasted on updating the account from the trie</span></span><br><span class="line">	<span class="keyword">if</span> metrics.EnabledExpensive &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(start time.Time)</span></span> &#123; s.AccountUpdates += time.Since(start) &#125;(time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Encode the account and update the account trie</span></span><br><span class="line">	addr := obj.Address()</span><br><span class="line"></span><br><span class="line">	data, err := rlp.EncodeToBytes(obj)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;can&#x27;t encode object at %x: %v&quot;</span>, addr[:], err))</span><br><span class="line">	&#125;</span><br><span class="line">	s.setError(s.trie.TryUpdate(addr[:], data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span> <span class="title">getStateObject</span><span class="params">(addr common.Address)</span> *<span class="title">stateObject</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> obj := s.getDeletedStateObject(addr); obj != <span class="literal">nil</span> &amp;&amp; !obj.deleted &#123;</span><br><span class="line">		<span class="keyword">return</span> obj</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateAccount explicitly creates a state object. If a state object with the address</span></span><br><span class="line"><span class="comment">// already exists the balance is carried over to the new account.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span> <span class="title">createObject</span><span class="params">(addr common.Address)</span> <span class="params">(newobj, prev *stateObject)</span></span> &#123;</span><br><span class="line">	prev = s.getDeletedStateObject(addr) <span class="comment">// Note, prev might have been deleted, we need that!</span></span><br><span class="line"></span><br><span class="line">	newobj = newObject(s, addr, Account&#123;&#125;)</span><br><span class="line">	newobj.setNonce(<span class="number">0</span>) <span class="comment">// sets the object to dirty</span></span><br><span class="line">	<span class="keyword">if</span> prev == <span class="literal">nil</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(createObjectChange&#123;account: &amp;addr&#125;)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		s.journal.<span class="built_in">append</span>(resetObjectChange&#123;prev: prev&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	s.setStateObject(newobj)</span><br><span class="line">	<span class="keyword">return</span> newobj, prev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit writes the state to the underlying in-memory trie database.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StateDB)</span> <span class="title">Commit</span><span class="params">(deleteEmptyObjects <span class="keyword">bool</span>)</span> <span class="params">(common.Hash, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Finalize any pending changes and merge everything into the tries</span></span><br><span class="line">	s.IntermediateRoot(deleteEmptyObjects)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Commit objects to the trie, measuring the elapsed time</span></span><br><span class="line">	<span class="keyword">for</span> addr := <span class="keyword">range</span> s.stateObjectsDirty &#123;</span><br><span class="line">		<span class="keyword">if</span> obj := s.stateObjects[addr]; !obj.deleted &#123;</span><br><span class="line">			<span class="comment">// Write any contract code associated with the state object</span></span><br><span class="line">			<span class="keyword">if</span> obj.code != <span class="literal">nil</span> &amp;&amp; obj.dirtyCode &#123;</span><br><span class="line">				s.db.TrieDB().InsertBlob(common.BytesToHash(obj.CodeHash()), obj.code)</span><br><span class="line">				obj.dirtyCode = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Write any storage changes in the state object to its storage trie</span></span><br><span class="line">			<span class="keyword">if</span> err := obj.CommitTrie(s.db); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> common.Hash&#123;&#125;, err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s.stateObjectsDirty) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		s.stateObjectsDirty = <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Write the account trie changes, measuing the amount of wasted time</span></span><br><span class="line">	<span class="keyword">if</span> metrics.EnabledExpensive &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(start time.Time)</span></span> &#123; s.AccountCommits += time.Since(start) &#125;(time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// The onleaf func is called _serially_, so we can reuse the same account</span></span><br><span class="line">	<span class="comment">// for unmarshalling every time.</span></span><br><span class="line">	<span class="keyword">var</span> account Account</span><br><span class="line">	<span class="keyword">return</span> s.trie.Commit(<span class="function"><span class="keyword">func</span><span class="params">(leaf []<span class="keyword">byte</span>, parent common.Hash)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := rlp.DecodeBytes(leaf, &amp;account); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> account.Root != emptyRoot &#123;</span><br><span class="line">			s.db.TrieDB().Reference(account.Root, parent)</span><br><span class="line">		&#125;</span><br><span class="line">		code := common.BytesToHash(account.CodeHash)</span><br><span class="line">		<span class="keyword">if</span> code != emptyCode &#123;</span><br><span class="line">			s.db.TrieDB().Reference(code, parent)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2020/02/25/%E7%8A%B6%E6%80%81%EF%BC%9B%E7%8A%B6%E6%80%81%E6%A0%91%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ckqol3obv001vnwu752lf5gg0" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-以太坊RPC通信" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/25/%E4%BB%A5%E5%A4%AA%E5%9D%8ARPC%E9%80%9A%E4%BF%A1/">以太坊中的RPC通信代码</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/02/25/%E4%BB%A5%E5%A4%AA%E5%9D%8ARPC%E9%80%9A%E4%BF%A1/" class="article-date"><time datetime="2020-02-25T15:54:34.000Z" itemprop="datePublished">2020-02-25</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p>启动geth</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">geth</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> args := ctx.Args(); <span class="built_in">len</span>(args) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid command: %q&quot;</span>, args[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	prepare(ctx)</span><br><span class="line">	node := makeFullNode(ctx)</span><br><span class="line">	<span class="keyword">defer</span> node.Close()</span><br><span class="line">	startNode(ctx, node)</span><br><span class="line">	node.Wait()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--more-->

<p>启动node</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start create a live P2P node and starts running it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	n.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> n.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Short circuit if the node&#x27;s already running</span></span><br><span class="line">	<span class="keyword">if</span> n.server != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrNodeRunning</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := n.openDataDir(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the p2p server. This creates the node key and</span></span><br><span class="line">	<span class="comment">// discovery databases.</span></span><br><span class="line">	n.serverConfig = n.config.P2P</span><br><span class="line">	n.serverConfig.PrivateKey = n.config.NodeKey()</span><br><span class="line">	n.serverConfig.Name = n.config.NodeName()</span><br><span class="line">	n.serverConfig.Logger = n.log</span><br><span class="line">	<span class="keyword">if</span> n.serverConfig.StaticNodes == <span class="literal">nil</span> &#123;</span><br><span class="line">		n.serverConfig.StaticNodes = n.config.StaticNodes()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.serverConfig.TrustedNodes == <span class="literal">nil</span> &#123;</span><br><span class="line">		n.serverConfig.TrustedNodes = n.config.TrustedNodes()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.serverConfig.NodeDatabase == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		n.serverConfig.NodeDatabase = n.config.NodeDB()</span><br><span class="line">	&#125;</span><br><span class="line">	running := &amp;p2p.Server&#123;Config: n.serverConfig&#125;</span><br><span class="line">	n.log.Info(<span class="string">&quot;Starting peer-to-peer node&quot;</span>, <span class="string">&quot;instance&quot;</span>, n.serverConfig.Name)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Otherwise copy and specialize the P2P configuration</span></span><br><span class="line">	services := <span class="built_in">make</span>(<span class="keyword">map</span>[reflect.Type]Service)</span><br><span class="line">	<span class="keyword">for</span> _, constructor := <span class="keyword">range</span> n.serviceFuncs &#123;</span><br><span class="line">		<span class="comment">// Create a new context for the particular service</span></span><br><span class="line">		ctx := &amp;ServiceContext&#123;</span><br><span class="line">			config:         n.config,</span><br><span class="line">			services:       <span class="built_in">make</span>(<span class="keyword">map</span>[reflect.Type]Service),</span><br><span class="line">			EventMux:       n.eventmux,</span><br><span class="line">			AccountManager: n.accman,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> kind, s := <span class="keyword">range</span> services &#123; <span class="comment">// copy needed for threaded access</span></span><br><span class="line">			ctx.services[kind] = s</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Construct and save the service</span></span><br><span class="line">		service, err := constructor(ctx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		kind := reflect.TypeOf(service)</span><br><span class="line">		<span class="keyword">if</span> _, exists := services[kind]; exists &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;DuplicateServiceError&#123;Kind: kind&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		services[kind] = service</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Gather the protocols and start the freshly assembled P2P server</span></span><br><span class="line">	<span class="keyword">for</span> _, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">		running.Protocols = <span class="built_in">append</span>(running.Protocols, service.Protocols()...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := running.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> convertFileLockError(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Start each of the services</span></span><br><span class="line">	<span class="keyword">var</span> started []reflect.Type</span><br><span class="line">	<span class="keyword">for</span> kind, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">		<span class="comment">// Start the next service, stopping all previous upon failure</span></span><br><span class="line">		<span class="keyword">if</span> err := service.Start(running); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> _, kind := <span class="keyword">range</span> started &#123;</span><br><span class="line">				services[kind].Stop()</span><br><span class="line">			&#125;</span><br><span class="line">			running.Stop()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Mark the service started for potential cleanup</span></span><br><span class="line">		started = <span class="built_in">append</span>(started, kind)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Lastly start the configured RPC interfaces</span></span><br><span class="line">	<span class="keyword">if</span> err := n.startRPC(services); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">			service.Stop()</span><br><span class="line">		&#125;</span><br><span class="line">		running.Stop()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Finish initializing the startup</span></span><br><span class="line">	n.services = services</span><br><span class="line">	n.server = running</span><br><span class="line">	n.stop = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startRPC</p>
<p>以太坊rpc有4种实现方式分别是<strong>inproc</strong>，<strong>ipc</strong>，<strong>http</strong>，<strong>ws</strong>。inproc是进程内部调用，为console使用；http是以http接口方式提供访问；ws是以websocket的方式提供访问。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startRPC is a helper method to start all the various RPC endpoint during node</span></span><br><span class="line"><span class="comment">// startup. It&#x27;s not meant to be called at any time afterwards as it makes certain</span></span><br><span class="line"><span class="comment">// assumptions about the state of the node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">startRPC</span><span class="params">(services <span class="keyword">map</span>[reflect.Type]Service)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Gather all the possible APIs to surface</span></span><br><span class="line">    <span class="comment">// 先添加所有的api</span></span><br><span class="line">	apis := n.apis()</span><br><span class="line">	<span class="keyword">for</span> _, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">		apis = <span class="built_in">append</span>(apis, service.APIs()...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Start the various API endpoints, terminating all in case of errors</span></span><br><span class="line">    <span class="comment">// 分别启动InProc IPC HTTP WS</span></span><br><span class="line">	<span class="keyword">if</span> err := n.startInProc(apis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := n.startIPC(apis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.stopInProc()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := n.startHTTP(n.httpEndpoint, apis, n.config.HTTPModules, n.config.HTTPCors, n.config.HTTPVirtualHosts, n.config.HTTPTimeouts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.stopIPC()</span><br><span class="line">		n.stopInProc()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := n.startWS(n.wsEndpoint, apis, n.config.WSModules, n.config.WSOrigins, n.config.WSExposeAll); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.stopHTTP()</span><br><span class="line">		n.stopIPC()</span><br><span class="line">		n.stopInProc()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All API endpoints started successfully</span></span><br><span class="line">	n.rpcAPIs = apis</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以startHTTP为例进行追踪</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startHTTP initializes and starts the HTTP RPC endpoint.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">startHTTP</span><span class="params">(endpoint <span class="keyword">string</span>, apis []rpc.API, modules []<span class="keyword">string</span>, cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts rpc.HTTPTimeouts)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Short circuit if the HTTP endpoint isn&#x27;t being exposed</span></span><br><span class="line">	<span class="keyword">if</span> endpoint == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	listener, handler, err := rpc.StartHTTPEndpoint(endpoint, apis, modules, cors, vhosts, timeouts)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	n.log.Info(<span class="string">&quot;HTTP endpoint opened&quot;</span>, <span class="string">&quot;url&quot;</span>, fmt.Sprintf(<span class="string">&quot;http://%s&quot;</span>, endpoint), <span class="string">&quot;cors&quot;</span>, strings.Join(cors, <span class="string">&quot;,&quot;</span>), <span class="string">&quot;vhosts&quot;</span>, strings.Join(vhosts, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">	<span class="comment">// All listeners booted successfully</span></span><br><span class="line">	n.httpEndpoint = endpoint</span><br><span class="line">	n.httpListener = listener</span><br><span class="line">	n.httpHandler = handler</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HTTP相关的有3个字段：</p>
<p>httpEndpoint：这是一个字符串，表示IP和端口号，默认是localhost:8545<br>httpListener：这是一个接口，调用net.Listen()时返回，包含了Accept()/Close()/Addr()这3个函数，可以用来接受和关闭连接<br>httpHandler：这是一个需要重点分析的结构，定义位于rpc/types.go：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	services serviceRegistry</span><br><span class="line">	idgen    <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">ID</span></span></span><br><span class="line">	run      <span class="keyword">int32</span></span><br><span class="line">	codecs   mapset.Set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type serviceRegistry map[string]*service // collection of services<br>可以看到，其中有一个services字段，是一个map，key是Namespace，value是一个service实例。注意这个service类型首字母是小写的，所以是不对外暴露的，定义位于rpc/types.go：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	name          <span class="keyword">string</span>               <span class="comment">// name for service</span></span><br><span class="line">	callbacks     <span class="keyword">map</span>[<span class="keyword">string</span>]*callback <span class="comment">// registered handlers</span></span><br><span class="line">	subscriptions <span class="keyword">map</span>[<span class="keyword">string</span>]*callback <span class="comment">// available subscriptions/notifications</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service中包含了两个字段callbacks和subscriptions</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> callbacks <span class="keyword">map</span>[<span class="keyword">string</span>]*callback      <span class="comment">// collection of RPC callbacks</span></span><br><span class="line"><span class="keyword">type</span> subscriptions <span class="keyword">map</span>[<span class="keyword">string</span>]*callback  <span class="comment">// collection of subscription callbacks</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> callback <span class="keyword">struct</span> &#123;</span><br><span class="line">    rcvr        reflect.Value  <span class="comment">// receiver of method</span></span><br><span class="line">    method      reflect.Method <span class="comment">// callback</span></span><br><span class="line">    argTypes    []reflect.Type <span class="comment">// input argument types</span></span><br><span class="line">    hasCtx      <span class="keyword">bool</span>           <span class="comment">// method&#x27;s first argument is a context (not included in argTypes)</span></span><br><span class="line">    errPos      <span class="keyword">int</span>            <span class="comment">// err return idx, of -1 when method cannot return error</span></span><br><span class="line">    isSubscribe <span class="keyword">bool</span>           <span class="comment">// indication if the callback is a subscription</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>subscription是一种特殊的callback，而callback结构中包含了RPC API所需要的所有信息：</p>
<p>rcvr：方法的接收者，这是一个反射值类型，其实就是指向了之前的NewPublicEthereumAPI<br>method：对应rcvr中的函数<br>argTypes：函数参数的类型列表<br>hasCtx：标识函数的第一个参数是否是context.Context类型<br>isSubscribe：是否是subscription类型（因为它们共用一个结构定义）</p>
<p>注册流程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartHTTPEndpoint starts the HTTP RPC endpoint, configured with cors/vhosts/modules.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartHTTPEndpoint</span><span class="params">(endpoint <span class="keyword">string</span>, apis []API, modules []<span class="keyword">string</span>, cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts HTTPTimeouts)</span> <span class="params">(net.Listener, *Server, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := checkModuleAvailability(modules, apis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Generate the whitelist based on the allowed modules</span></span><br><span class="line">	whitelist := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, module := <span class="keyword">range</span> modules &#123;</span><br><span class="line">		whitelist[module] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Register all the APIs exposed by the services</span></span><br><span class="line">	handler := NewServer()</span><br><span class="line">	<span class="keyword">for</span> _, api := <span class="keyword">range</span> apis &#123;</span><br><span class="line">		<span class="keyword">if</span> whitelist[api.Namespace] || (<span class="built_in">len</span>(whitelist) == <span class="number">0</span> &amp;&amp; api.Public) &#123;</span><br><span class="line">			<span class="keyword">if</span> err := handler.RegisterName(api.Namespace, api.Service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			log.Debug(<span class="string">&quot;HTTP registered&quot;</span>, <span class="string">&quot;namespace&quot;</span>, api.Namespace)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All APIs registered, start the HTTP listener</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		listener net.Listener</span><br><span class="line">		err      error</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> listener, err = net.Listen(<span class="string">&quot;tcp&quot;</span>, endpoint); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> NewHTTPServer(cors, vhosts, timeouts, handler).Serve(listener)</span><br><span class="line">	<span class="keyword">return</span> listener, handler, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>registertname函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">RegisterName</span><span class="params">(name <span class="keyword">string</span>, receiver <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.services.registerName(name, receiver)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *serviceRegistry)</span> <span class="title">registerName</span><span class="params">(name <span class="keyword">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	rcvrVal := reflect.ValueOf(rcvr)</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;no service name for type %s&quot;</span>, rcvrVal.Type().String())</span><br><span class="line">	&#125;</span><br><span class="line">	callbacks := suitableCallbacks(rcvrVal)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(callbacks) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;service %T doesn&#x27;t have any suitable methods/subscriptions to expose&quot;</span>, rcvr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> r.services == <span class="literal">nil</span> &#123;</span><br><span class="line">		r.services = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]service)</span><br><span class="line">	&#125;</span><br><span class="line">	svc, ok := r.services[name]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		svc = service&#123;</span><br><span class="line">			name:          name,</span><br><span class="line">			callbacks:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*callback),</span><br><span class="line">			subscriptions: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*callback),</span><br><span class="line">		&#125;</span><br><span class="line">		r.services[name] = svc</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> name, cb := <span class="keyword">range</span> callbacks &#123;</span><br><span class="line">		<span class="keyword">if</span> cb.isSubscribe &#123;</span><br><span class="line">			svc.subscriptions[name] = cb</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			svc.callbacks[name] = cb</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是先创建一个service实例，然后填充它的callbacks和subscriptions字段。其中suitableCallbacks()函数会检查API定义是否符合标准，然后创建callback实例放入map中。</p>
<h3 id="创建服务："><a href="#创建服务：" class="headerlink" title="创建服务："></a>创建服务：</h3><p>在开启RPC服务的时候 开启http rpc请求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := n.startHTTP(n.httpEndpoint, apis, n.config.HTTPModules, n.config.HTTPCors, n.config.HTTPVirtualHosts, n.config.HTTPTimeouts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	n.stopIPC()</span><br><span class="line">	n.stopInProc()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startHTTP initializes and starts the HTTP RPC endpoint.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">startHTTP</span><span class="params">(endpoint <span class="keyword">string</span>, apis []rpc.API, modules []<span class="keyword">string</span>, cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts rpc.HTTPTimeouts)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Short circuit if the HTTP endpoint isn&#x27;t being exposed</span></span><br><span class="line">	<span class="keyword">if</span> endpoint == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	listener, handler, err := rpc.StartHTTPEndpoint(endpoint, apis, modules, cors, vhosts, timeouts)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	n.log.Info(<span class="string">&quot;HTTP endpoint opened&quot;</span>, <span class="string">&quot;url&quot;</span>, fmt.Sprintf(<span class="string">&quot;http://%s&quot;</span>, endpoint), <span class="string">&quot;cors&quot;</span>, strings.Join(cors, <span class="string">&quot;,&quot;</span>), <span class="string">&quot;vhosts&quot;</span>, strings.Join(vhosts, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">	<span class="comment">// All listeners booted successfully</span></span><br><span class="line">	n.httpEndpoint = endpoint</span><br><span class="line">	n.httpListener = listener</span><br><span class="line">	n.httpHandler = handler</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StartHTTPEndpoint   启动一个线程开启serve服务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartHTTPEndpoint starts the HTTP RPC endpoint, configured with cors/vhosts/modules.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartHTTPEndpoint</span><span class="params">(endpoint <span class="keyword">string</span>, apis []API, modules []<span class="keyword">string</span>, cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts HTTPTimeouts)</span> <span class="params">(net.Listener, *Server, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := checkModuleAvailability(modules, apis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Generate the whitelist based on the allowed modules</span></span><br><span class="line">	whitelist := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, module := <span class="keyword">range</span> modules &#123;</span><br><span class="line">		whitelist[module] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Register all the APIs exposed by the services</span></span><br><span class="line">	handler := NewServer()</span><br><span class="line">	<span class="keyword">for</span> _, api := <span class="keyword">range</span> apis &#123;</span><br><span class="line">		<span class="keyword">if</span> whitelist[api.Namespace] || (<span class="built_in">len</span>(whitelist) == <span class="number">0</span> &amp;&amp; api.Public) &#123;</span><br><span class="line">			<span class="keyword">if</span> err := handler.RegisterName(api.Namespace, api.Service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			log.Debug(<span class="string">&quot;HTTP registered&quot;</span>, <span class="string">&quot;namespace&quot;</span>, api.Namespace)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All APIs registered, start the HTTP listener</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		listener net.Listener</span><br><span class="line">		err      error</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> listener, err = net.Listen(<span class="string">&quot;tcp&quot;</span>, endpoint); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">go</span> NewHTTPServer(cors, vhosts, timeouts, handler).Serve(listener)</span><br><span class="line">	<span class="keyword">return</span> listener, handler, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用NewHTTPServer创建server</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPServer</span><span class="params">(cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts HTTPTimeouts, srv http.Handler)</span> *<span class="title">http</span>.<span class="title">Server</span></span> &#123;</span><br><span class="line">	<span class="comment">// Wrap the CORS-handler within a host-handler</span></span><br><span class="line">	handler := newCorsHandler(srv, cors)</span><br><span class="line">	handler = newVHostHandler(vhosts, handler)</span><br><span class="line">	handler = newGzipHandler(handler)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure timeout values are meaningful</span></span><br><span class="line">	<span class="keyword">if</span> timeouts.ReadTimeout &lt; time.Second &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Sanitizing invalid HTTP read timeout&quot;</span>, <span class="string">&quot;provided&quot;</span>, timeouts.ReadTimeout, <span class="string">&quot;updated&quot;</span>, DefaultHTTPTimeouts.ReadTimeout)</span><br><span class="line">		timeouts.ReadTimeout = DefaultHTTPTimeouts.ReadTimeout</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> timeouts.WriteTimeout &lt; time.Second &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Sanitizing invalid HTTP write timeout&quot;</span>, <span class="string">&quot;provided&quot;</span>, timeouts.WriteTimeout, <span class="string">&quot;updated&quot;</span>, DefaultHTTPTimeouts.WriteTimeout)</span><br><span class="line">		timeouts.WriteTimeout = DefaultHTTPTimeouts.WriteTimeout</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> timeouts.IdleTimeout &lt; time.Second &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Sanitizing invalid HTTP idle timeout&quot;</span>, <span class="string">&quot;provided&quot;</span>, timeouts.IdleTimeout, <span class="string">&quot;updated&quot;</span>, DefaultHTTPTimeouts.IdleTimeout)</span><br><span class="line">		timeouts.IdleTimeout = DefaultHTTPTimeouts.IdleTimeout</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Bundle and start the HTTP server</span></span><br><span class="line">	<span class="keyword">return</span> &amp;http.Server&#123;</span><br><span class="line">		Handler:      handler,</span><br><span class="line">		ReadTimeout:  timeouts.ReadTimeout,</span><br><span class="line">		WriteTimeout: timeouts.WriteTimeout,</span><br><span class="line">		IdleTimeout:  timeouts.IdleTimeout,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这里，handler是源码包中http.Server的一个组成部分，但是定义为一个接口，以太坊通过重载方法，将其自定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	Addr    <span class="keyword">string</span>  <span class="comment">// TCP address to listen on, &quot;:http&quot; if empty</span></span><br><span class="line">	Handler Handler <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line">。。。&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>处理http rpc请求的逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP serves JSON-RPC requests over HTTP.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Permit dumb empty requests for remote health-checks (AWS)</span></span><br><span class="line">	<span class="keyword">if</span> r.Method == http.MethodGet &amp;&amp; r.ContentLength == <span class="number">0</span> &amp;&amp; r.URL.RawQuery == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> code, err := validateRequest(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), code)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All checks passed, create a codec that reads direct from the request body</span></span><br><span class="line">	<span class="comment">// untilEOF and writes the response to w and order the server to process a</span></span><br><span class="line">	<span class="comment">// single request.</span></span><br><span class="line">	ctx := r.Context()</span><br><span class="line">	ctx = context.WithValue(ctx, <span class="string">&quot;remote&quot;</span>, r.RemoteAddr)</span><br><span class="line">	ctx = context.WithValue(ctx, <span class="string">&quot;scheme&quot;</span>, r.Proto)</span><br><span class="line">	ctx = context.WithValue(ctx, <span class="string">&quot;local&quot;</span>, r.Host)</span><br><span class="line">	<span class="keyword">if</span> ua := r.Header.Get(<span class="string">&quot;User-Agent&quot;</span>); ua != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		ctx = context.WithValue(ctx, <span class="string">&quot;User-Agent&quot;</span>, ua)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> origin := r.Header.Get(<span class="string">&quot;Origin&quot;</span>); origin != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		ctx = context.WithValue(ctx, <span class="string">&quot;Origin&quot;</span>, origin)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	w.Header().Set(<span class="string">&quot;content-type&quot;</span>, contentType)</span><br><span class="line">	codec := newHTTPServerConn(r, w)</span><br><span class="line">	<span class="keyword">defer</span> codec.<span class="built_in">close</span>()</span><br><span class="line">	s.serveSingleRequest(ctx, codec)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serveSingleRequest reads and processes a single RPC request from the given codec. This</span></span><br><span class="line"><span class="comment">// is used to serve HTTP connections. Subscriptions and reverse calls are not allowed in</span></span><br><span class="line"><span class="comment">// this mode.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">serveSingleRequest</span><span class="params">(ctx context.Context, codec ServerCodec)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Don&#x27;t serve if server is stopped.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.LoadInt32(&amp;s.run) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	h := newHandler(ctx, codec, s.idgen, &amp;s.services)</span><br><span class="line">	h.allowSubscribe = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">defer</span> h.<span class="built_in">close</span>(io.EOF, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	reqs, batch, err := codec.readBatch()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">			codec.writeJSON(ctx, errorMessage(&amp;invalidMessageError&#123;<span class="string">&quot;parse error&quot;</span>&#125;))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> batch &#123;</span><br><span class="line">		h.handleBatch(reqs)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		h.handleMsg(reqs[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">handleMsg</span><span class="params">(msg *jsonrpcMessage)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ok := h.handleImmediate(msg); ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h.startCallProc(<span class="function"><span class="keyword">func</span><span class="params">(cp *callProc)</span></span> &#123;</span><br><span class="line">		answer := h.handleCallMsg(cp, msg)</span><br><span class="line">		h.addSubscriptions(cp.notifiers)</span><br><span class="line">		<span class="keyword">if</span> answer != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.conn.writeJSON(cp.ctx, answer)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, n := <span class="keyword">range</span> cp.notifiers &#123;</span><br><span class="line">			n.activate()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleCallMsg executes a call message and returns the answer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">handleCallMsg</span><span class="params">(ctx *callProc, msg *jsonrpcMessage)</span> *<span class="title">jsonrpcMessage</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> msg.isNotification():</span><br><span class="line">		h.handleCall(ctx, msg)</span><br><span class="line">		h.log.Debug(<span class="string">&quot;Served &quot;</span>+msg.Method, <span class="string">&quot;t&quot;</span>, time.Since(start))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> msg.isCall():</span><br><span class="line">		resp := h.handleCall(ctx, msg)</span><br><span class="line">		<span class="keyword">if</span> resp.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.log.Warn(<span class="string">&quot;Served &quot;</span>+msg.Method, <span class="string">&quot;reqid&quot;</span>, idForLog&#123;msg.ID&#125;, <span class="string">&quot;t&quot;</span>, time.Since(start), <span class="string">&quot;err&quot;</span>, resp.Error.Message)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			h.log.Debug(<span class="string">&quot;Served &quot;</span>+msg.Method, <span class="string">&quot;reqid&quot;</span>, idForLog&#123;msg.ID&#125;, <span class="string">&quot;t&quot;</span>, time.Since(start))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resp</span><br><span class="line">	<span class="keyword">case</span> msg.hasValidID():</span><br><span class="line">		<span class="keyword">return</span> msg.errorResponse(&amp;invalidRequestError&#123;<span class="string">&quot;invalid request&quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> errorMessage(&amp;invalidRequestError&#123;<span class="string">&quot;invalid request&quot;</span>&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleCall processes method calls.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">handleCall</span><span class="params">(cp *callProc, msg *jsonrpcMessage)</span> *<span class="title">jsonrpcMessage</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> msg.isSubscribe() &#123;</span><br><span class="line">		<span class="keyword">return</span> h.handleSubscribe(cp, msg)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//新建callback对象</span></span><br><span class="line">	<span class="keyword">var</span> callb *callback</span><br><span class="line">	<span class="keyword">if</span> msg.isUnsubscribe() &#123;</span><br><span class="line">		callb = h.unsubscribeCb</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		callb = h.reg.callback(msg.Method)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> callb == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> msg.errorResponse(&amp;methodNotFoundError&#123;method: msg.Method&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//解析出参数</span></span><br><span class="line">	args, err := parsePositionalArguments(msg.Params, callb.argTypes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> msg.errorResponse(&amp;invalidParamsError&#123;err.Error()&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h.runMethod(cp.ctx, msg, callb, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runMethod runs the Go callback for an RPC method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">runMethod</span><span class="params">(ctx context.Context, msg *jsonrpcMessage, callb *callback, args []reflect.Value)</span> *<span class="title">jsonrpcMessage</span></span> &#123;</span><br><span class="line">    <span class="comment">//传入method args得到结果</span></span><br><span class="line">	result, err := callb.call(ctx, msg.Method, args)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> msg.errorResponse(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msg.response(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call invokes the callback.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *callback)</span> <span class="title">call</span><span class="params">(ctx context.Context, method <span class="keyword">string</span>, args []reflect.Value)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;, errRes error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Create the argument slice.</span></span><br><span class="line">	fullargs := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>, <span class="number">2</span>+<span class="built_in">len</span>(args))</span><br><span class="line">	<span class="keyword">if</span> c.rcvr.IsValid() &#123;</span><br><span class="line">		fullargs = <span class="built_in">append</span>(fullargs, c.rcvr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.hasCtx &#123;</span><br><span class="line">		fullargs = <span class="built_in">append</span>(fullargs, reflect.ValueOf(ctx))</span><br><span class="line">	&#125;</span><br><span class="line">	fullargs = <span class="built_in">append</span>(fullargs, args...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Catch panic while running the callback.</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">			buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">			buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">			log.Error(<span class="string">&quot;RPC method &quot;</span> + method + <span class="string">&quot; crashed: &quot;</span> + fmt.Sprintf(<span class="string">&quot;%v\n%s&quot;</span>, err, buf))</span><br><span class="line">			errRes = errors.New(<span class="string">&quot;method handler crashed&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// Run the callback.</span></span><br><span class="line">    <span class="comment">// 主要执行这一步</span></span><br><span class="line">	results := c.fn.Call(fullargs)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(results) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.errPos &gt;= <span class="number">0</span> &amp;&amp; !results[c.errPos].IsNil() &#123;</span><br><span class="line">		<span class="comment">// Method has returned non-nil error value.</span></span><br><span class="line">		err := results[c.errPos].Interface().(error)</span><br><span class="line">		<span class="keyword">return</span> reflect.Value&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results[<span class="number">0</span>].Interface(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里留一个坑。现已知go调用rpc是通过反射reflect实现的，reflect反射是指一类应用，它们能够自描述和自控制。具体实现还未完全掌握。</p>
<h3 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h3><p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST --data &#x27;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getBlockByHash&quot;,&quot;params&quot;:[&quot;0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331&quot;, true],&quot;id&quot;:1&#125;&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;jsonrpc&quot;</span>:<span class="string">&quot;2.0&quot;</span>,</span><br><span class="line"><span class="attr">&quot;result&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;number&quot;</span>: <span class="string">&quot;0x1b4&quot;</span>, <span class="comment">// 436</span></span><br><span class="line">    <span class="attr">&quot;hash&quot;</span>: <span class="string">&quot;0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;parentHash&quot;</span>: <span class="string">&quot;0x9646252be9520f6e71339a8df9c55e4d7619deeb018d2a3f2d21fc165dde5eb5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;nonce&quot;</span>: <span class="string">&quot;0xe04d296d2460cfb8472af2c5fd05b5a214109c25688d3704aed5484f9a7792f2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sha3Uncles&quot;</span>: <span class="string">&quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;logsBloom&quot;</span>: <span class="string">&quot;0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;transactionsRoot&quot;</span>: <span class="string">&quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;stateRoot&quot;</span>: <span class="string">&quot;0xd5855eb08b3387c0af375e9cdb6acfc05eb8f519e419b874b6ff2ffda7ed1dff&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;miner&quot;</span>: <span class="string">&quot;0x4e65fda2159562a496f9f3522f89122a3088497a&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;difficulty&quot;</span>: <span class="string">&quot;0x027f07&quot;</span>, <span class="comment">// 163591</span></span><br><span class="line">    <span class="attr">&quot;totalDifficulty&quot;</span>:  <span class="string">&quot;0x027f07&quot;</span>, <span class="comment">// 163591</span></span><br><span class="line">    <span class="attr">&quot;extraData&quot;</span>: <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>:  <span class="string">&quot;0x027f07&quot;</span>, <span class="comment">// 163591</span></span><br><span class="line">    <span class="attr">&quot;gasLimit&quot;</span>: <span class="string">&quot;0x9f759&quot;</span>, <span class="comment">// 653145</span></span><br><span class="line">    <span class="attr">&quot;gasUsed&quot;</span>: <span class="string">&quot;0x9f759&quot;</span>, <span class="comment">// 653145</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;0x54e34e8e&quot;</span> <span class="comment">// 1424182926</span></span><br><span class="line">    <span class="string">&quot;transactions&quot;</span>: [&#123;...&#125;,&#123; ... &#125;] </span><br><span class="line">    <span class="string">&quot;uncles&quot;</span>: [<span class="string">&quot;0x1606e5...&quot;</span>, <span class="string">&quot;0xd5145a9...&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>请求对象需要包括下面4个字段：</p>
<ul>
<li>jsonrpc：协议版本号，固定是2.0</li>
<li>method：请求调用的函数名，可以看到是Namespace_Method这种命名方式</li>
<li>params： 函数参数列表，一般是一个数组</li>
<li>id：客户端和服务器之前通信的一个标识，服务器返回响应时必须返回相同的id。可以是数字或者字符串，不建议设为NULL</li>
</ul>
<p>返回的响应需要包含以下字段：</p>
<ul>
<li>jsonrpc：协议版本号，固定是2.0</li>
<li>result/error：返回的结果或者错误，二选一</li>
<li>id：客户端和服务器之前通信的一个标识，服务器返回响应时必须返回相同的id。可以是数字或者字符串，不建议设为NULL</li>
</ul>
<p>当收到调用rpc请求时一般会调用Dial函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dial creates a new client for the given URL.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The currently supported URL schemes are &quot;http&quot;, &quot;https&quot;, &quot;ws&quot; and &quot;wss&quot;. If rawurl is a</span></span><br><span class="line"><span class="comment">// file name with no URL scheme, a local socket connection is established using UNIX</span></span><br><span class="line"><span class="comment">// domain sockets on supported platforms and named pipes on Windows. If you want to</span></span><br><span class="line"><span class="comment">// configure transport options, use DialHTTP, DialWebsocket or DialIPC instead.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For websocket connections, the origin is set to the local host name.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The client reconnects automatically if the connection is lost.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(rawurl <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> DialContext(context.Background(), rawurl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DialContext creates a new RPC client, just like Dial.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The context is used to cancel or time out the initial connection establishment. It does</span></span><br><span class="line"><span class="comment">// not affect subsequent interactions with the client.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, rawurl <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span> &#123;</span><br><span class="line">	u, err := url.Parse(rawurl)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> u.Scheme &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;http&quot;</span>, <span class="string">&quot;https&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> DialHTTP(rawurl)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;ws&quot;</span>, <span class="string">&quot;wss&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> DialWebsocket(ctx, rawurl, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;stdio&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> DialStdIO(ctx)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> DialIPC(ctx, rawurl)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;no known transport for URL scheme %q&quot;</span>, u.Scheme)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在console/bridge.go控制台处理时也会调用到</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Send implements the web3 provider &quot;send&quot; method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bridge)</span> <span class="title">Send</span><span class="params">(call jsre.Call)</span> <span class="params">(goja.Value, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">// Remarshal the request into a Go value.</span></span><br><span class="line">	<span class="comment">// Execute the requests.</span></span><br><span class="line">	<span class="keyword">var</span> resps []*goja.Object</span><br><span class="line">	<span class="keyword">for</span> _, req := <span class="keyword">range</span> reqs &#123;</span><br><span class="line">		resp := call.VM.NewObject()</span><br><span class="line">		resp.Set(<span class="string">&quot;jsonrpc&quot;</span>, <span class="string">&quot;2.0&quot;</span>)</span><br><span class="line">		resp.Set(<span class="string">&quot;id&quot;</span>, req.ID)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> result json.RawMessage</span><br><span class="line">		err = b.client.Call(&amp;result, req.Method, req.Params...)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后还是调用到rpc/client.go 的call方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Call</span><span class="params">(result <span class="keyword">interface</span>&#123;&#125;, method <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	<span class="keyword">return</span> c.CallContext(ctx, result, method, args...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">CallContext</span><span class="params">(ctx context.Context, result <span class="keyword">interface</span>&#123;&#125;, method <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	msg, err := c.newMessage(method, args...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	op := &amp;requestOp&#123;ids: []json.RawMessage&#123;msg.ID&#125;, resp: <span class="built_in">make</span>(<span class="keyword">chan</span> *jsonrpcMessage, <span class="number">1</span>)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.isHTTP &#123;</span><br><span class="line">		err = c.sendHTTP(ctx, op, msg)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = c.send(ctx, op, msg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dispatch has accepted the request and will close the channel when it quits.</span></span><br><span class="line">	<span class="keyword">switch</span> resp, err := op.wait(ctx, c); &#123;</span><br><span class="line">	<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	<span class="keyword">case</span> resp.Error != <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> resp.Error</span><br><span class="line">	<span class="keyword">case</span> <span class="built_in">len</span>(resp.Result) == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> ErrNoResult</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> json.Unmarshal(resp.Result, &amp;result)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">sendHTTP</span><span class="params">(ctx context.Context, op *requestOp, msg <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	hc := c.writeConn.(*httpConn)</span><br><span class="line">	respBody, err := hc.doRequest(ctx, msg)</span><br><span class="line">	<span class="keyword">if</span> respBody != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> respBody.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> respBody != <span class="literal">nil</span> &#123;</span><br><span class="line">			buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">			<span class="keyword">if</span> _, err2 := buf.ReadFrom(respBody); err2 == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%v %v&quot;</span>, err, buf.String())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> respmsg jsonrpcMessage</span><br><span class="line">	<span class="keyword">if</span> err := json.NewDecoder(respBody).Decode(&amp;respmsg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	op.resp &lt;- &amp;respmsg</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rpc/http.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hc *httpConn)</span> <span class="title">doRequest</span><span class="params">(ctx context.Context, msg <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(io.ReadCloser, error)</span></span> &#123;</span><br><span class="line">	body, err := json.Marshal(msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	req := hc.req.WithContext(ctx)</span><br><span class="line">	req.Body = ioutil.NopCloser(bytes.NewReader(body))</span><br><span class="line">	req.ContentLength = <span class="keyword">int64</span>(<span class="built_in">len</span>(body))</span><br><span class="line"></span><br><span class="line">	resp, err := hc.client.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resp.StatusCode &lt; <span class="number">200</span> || resp.StatusCode &gt;= <span class="number">300</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> resp.Body, errors.New(resp.Status)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resp.Body, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往下调用就是源码包的http/client.go的方法了</p>
<p>eth/api.go和internal/ethapi/api.go的关系：internal包中的api是对jsonrpc的拓展</p>
<h3 id="关键命令"><a href="#关键命令" class="headerlink" title="关键命令"></a>关键命令</h3><p><strong>命令1</strong>: personal.newAccount(password) - 新建账户</p>
<p>api: internal/ethapi.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PrivateAccountAPI)</span> <span class="title">NewAccount</span><span class="params">(password <span class="keyword">string</span>)</span> <span class="params">(common.Address, error)</span>`</span></span><br></pre></td></tr></table></figure>

<p><strong>命令2</strong>：miner.start(threadNum) - 开始挖矿，默认<code>eth.accounts</code>第一个用户</p>
<p>api: eth/api.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PrivateMinerAPI)</span> <span class="title">Start</span><span class="params">(threads *<span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p><strong>命令3</strong>：miner.stop() - 停止挖矿</p>
<p>api: eth/api.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PrivateMinerAPI)</span> <span class="title">Stop</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>命令4</strong>：personal.unlockAccount(address, password) - 转账前解锁账户</p>
<p>api:  internal/ethapi.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PrivateAccountAPI)</span> <span class="title">UnlockAccount</span><span class="params">(addr common.Address, password <span class="keyword">string</span>, duration *<span class="keyword">uint64</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>命令5</strong>：eth.sendTransaction({from: _, to: _, value: _}) - 转账</p>
<p>api: ethapi/api.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PrivateAccountAPI)</span> <span class="title">SendTransaction</span><span class="params">(ctx context.Context, args SendTxArgs, passwd <span class="keyword">string</span>)</span> <span class="params">(common.Hash,error)</span></span></span><br></pre></td></tr></table></figure>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2020/02/25/%E4%BB%A5%E5%A4%AA%E5%9D%8ARPC%E9%80%9A%E4%BF%A1/" data-id="ckqol3oby0021nwu7hfy7gtmk" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li class="active"><span class="page-number">2</span></li><li><a class="page-number" href="/page/3/">3</a></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-next" rel="next" href="/page/3/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p> Nice papers collected in the field of <em>AI</em>, <em>Apllied Cryptography</em> and <em>Blockchain</em>, records of some computer technologies, and personal thoughts.  If you are inteseted in my field, feel free to contact me. (Wechat: mzliu_xdu) </p>

</div>


  


  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list" itemprop="keywords"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Bitcoin/" rel="tag">Bitcoin</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/go/" rel="tag">go</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/golang/" rel="tag">golang</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/hyperledger-fabric/" rel="tag">hyperledger fabric</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/java/" rel="tag">java</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/paper-notes/" rel="tag">paper notes</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a><span class="sidebar-module-list-count">18</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/Bitcoin/" style="font-size: 10px;">Bitcoin</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/golang/" style="font-size: 17.5px;">golang</a> <a href="/tags/hyperledger-fabric/" style="font-size: 12.5px;">hyperledger fabric</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/paper-notes/" style="font-size: 15px;">paper notes</a> <a href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" style="font-size: 20px;">以太坊</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/07/">July 2021</a><span class="sidebar-module-list-count">13</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">February 2020</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">August 2019</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2021/07/02/DoERS_note/">BlockChain Papers in Top Security Conferences</a>
        </li>
      
        <li>
          <a href="/2021/07/02/ML-Papers-in-Top-Security-Conferences/">ML Papers in Top Security Conferences</a>
        </li>
      
        <li>
          <a href="/2021/07/02/%E4%BA%A4%E6%98%93%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/">以太坊签名相关代码</a>
        </li>
      
        <li>
          <a href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81/">以太坊中的各种编码</a>
        </li>
      
        <li>
          <a href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%B1%A0%EF%BC%882%EF%BC%89/">以太坊交易池代码分析 part2(共2部分)</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2021 Mingzhe Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>




<script src="/js/script.js"></script>


</body>
</html>
