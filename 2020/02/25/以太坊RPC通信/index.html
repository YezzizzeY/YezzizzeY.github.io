<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>以太坊中的RPC通信代码 | Yezzi Tech</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="以太坊中的RPC通信代码，整理了很多，开始一段整理的还算比较清楚，到后面比较混乱，有时间再完善。">
<meta property="og:type" content="article">
<meta property="og:title" content="以太坊中的RPC通信代码">
<meta property="og:url" content="https://yezzi.tech/2020/02/25/%E4%BB%A5%E5%A4%AA%E5%9D%8ARPC%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="Yezzi Tech">
<meta property="og:description" content="以太坊中的RPC通信代码，整理了很多，开始一段整理的还算比较清楚，到后面比较混乱，有时间再完善。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-02-25T15:54:34.000Z">
<meta property="article:modified_time" content="2021-07-04T02:45:25.418Z">
<meta property="article:author" content="Mingzhe Liu">
<meta property="article:tag" content="以太坊">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Yezzi Tech" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="/css/styles.css">

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">Yezzi Tech</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="post-以太坊RPC通信" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      以太坊中的RPC通信代码
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2020/02/25/%E4%BB%A5%E5%A4%AA%E5%9D%8ARPC%E9%80%9A%E4%BF%A1/" class="article-date"><time datetime="2020-02-25T15:54:34.000Z" itemprop="datePublished">2020-02-25</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>以太坊中的RPC通信代码，整理了很多，开始一段整理的还算比较清楚，到后面比较混乱，有时间再完善。</p>
<span id="more"></span>

<h3 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h3><p>启动geth</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">geth</span><span class="params">(ctx *cli.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> args := ctx.Args(); <span class="built_in">len</span>(args) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid command: %q&quot;</span>, args[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	prepare(ctx)</span><br><span class="line">	node := makeFullNode(ctx)</span><br><span class="line">	<span class="keyword">defer</span> node.Close()</span><br><span class="line">	startNode(ctx, node)</span><br><span class="line">	node.Wait()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--more-->

<p>启动node</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start create a live P2P node and starts running it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	n.lock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> n.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Short circuit if the node&#x27;s already running</span></span><br><span class="line">	<span class="keyword">if</span> n.server != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrNodeRunning</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := n.openDataDir(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the p2p server. This creates the node key and</span></span><br><span class="line">	<span class="comment">// discovery databases.</span></span><br><span class="line">	n.serverConfig = n.config.P2P</span><br><span class="line">	n.serverConfig.PrivateKey = n.config.NodeKey()</span><br><span class="line">	n.serverConfig.Name = n.config.NodeName()</span><br><span class="line">	n.serverConfig.Logger = n.log</span><br><span class="line">	<span class="keyword">if</span> n.serverConfig.StaticNodes == <span class="literal">nil</span> &#123;</span><br><span class="line">		n.serverConfig.StaticNodes = n.config.StaticNodes()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.serverConfig.TrustedNodes == <span class="literal">nil</span> &#123;</span><br><span class="line">		n.serverConfig.TrustedNodes = n.config.TrustedNodes()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n.serverConfig.NodeDatabase == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		n.serverConfig.NodeDatabase = n.config.NodeDB()</span><br><span class="line">	&#125;</span><br><span class="line">	running := &amp;p2p.Server&#123;Config: n.serverConfig&#125;</span><br><span class="line">	n.log.Info(<span class="string">&quot;Starting peer-to-peer node&quot;</span>, <span class="string">&quot;instance&quot;</span>, n.serverConfig.Name)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Otherwise copy and specialize the P2P configuration</span></span><br><span class="line">	services := <span class="built_in">make</span>(<span class="keyword">map</span>[reflect.Type]Service)</span><br><span class="line">	<span class="keyword">for</span> _, constructor := <span class="keyword">range</span> n.serviceFuncs &#123;</span><br><span class="line">		<span class="comment">// Create a new context for the particular service</span></span><br><span class="line">		ctx := &amp;ServiceContext&#123;</span><br><span class="line">			config:         n.config,</span><br><span class="line">			services:       <span class="built_in">make</span>(<span class="keyword">map</span>[reflect.Type]Service),</span><br><span class="line">			EventMux:       n.eventmux,</span><br><span class="line">			AccountManager: n.accman,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> kind, s := <span class="keyword">range</span> services &#123; <span class="comment">// copy needed for threaded access</span></span><br><span class="line">			ctx.services[kind] = s</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Construct and save the service</span></span><br><span class="line">		service, err := constructor(ctx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		kind := reflect.TypeOf(service)</span><br><span class="line">		<span class="keyword">if</span> _, exists := services[kind]; exists &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;DuplicateServiceError&#123;Kind: kind&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		services[kind] = service</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Gather the protocols and start the freshly assembled P2P server</span></span><br><span class="line">	<span class="keyword">for</span> _, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">		running.Protocols = <span class="built_in">append</span>(running.Protocols, service.Protocols()...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := running.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> convertFileLockError(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Start each of the services</span></span><br><span class="line">	<span class="keyword">var</span> started []reflect.Type</span><br><span class="line">	<span class="keyword">for</span> kind, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">		<span class="comment">// Start the next service, stopping all previous upon failure</span></span><br><span class="line">		<span class="keyword">if</span> err := service.Start(running); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> _, kind := <span class="keyword">range</span> started &#123;</span><br><span class="line">				services[kind].Stop()</span><br><span class="line">			&#125;</span><br><span class="line">			running.Stop()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Mark the service started for potential cleanup</span></span><br><span class="line">		started = <span class="built_in">append</span>(started, kind)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Lastly start the configured RPC interfaces</span></span><br><span class="line">	<span class="keyword">if</span> err := n.startRPC(services); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">			service.Stop()</span><br><span class="line">		&#125;</span><br><span class="line">		running.Stop()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Finish initializing the startup</span></span><br><span class="line">	n.services = services</span><br><span class="line">	n.server = running</span><br><span class="line">	n.stop = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startRPC</p>
<p>以太坊rpc有4种实现方式分别是<strong>inproc</strong>，<strong>ipc</strong>，<strong>http</strong>，<strong>ws</strong>。inproc是进程内部调用，为console使用；http是以http接口方式提供访问；ws是以websocket的方式提供访问。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startRPC is a helper method to start all the various RPC endpoint during node</span></span><br><span class="line"><span class="comment">// startup. It&#x27;s not meant to be called at any time afterwards as it makes certain</span></span><br><span class="line"><span class="comment">// assumptions about the state of the node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">startRPC</span><span class="params">(services <span class="keyword">map</span>[reflect.Type]Service)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Gather all the possible APIs to surface</span></span><br><span class="line">    <span class="comment">// 先添加所有的api</span></span><br><span class="line">	apis := n.apis()</span><br><span class="line">	<span class="keyword">for</span> _, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">		apis = <span class="built_in">append</span>(apis, service.APIs()...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Start the various API endpoints, terminating all in case of errors</span></span><br><span class="line">    <span class="comment">// 分别启动InProc IPC HTTP WS</span></span><br><span class="line">	<span class="keyword">if</span> err := n.startInProc(apis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := n.startIPC(apis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.stopInProc()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := n.startHTTP(n.httpEndpoint, apis, n.config.HTTPModules, n.config.HTTPCors, n.config.HTTPVirtualHosts, n.config.HTTPTimeouts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.stopIPC()</span><br><span class="line">		n.stopInProc()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := n.startWS(n.wsEndpoint, apis, n.config.WSModules, n.config.WSOrigins, n.config.WSExposeAll); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		n.stopHTTP()</span><br><span class="line">		n.stopIPC()</span><br><span class="line">		n.stopInProc()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All API endpoints started successfully</span></span><br><span class="line">	n.rpcAPIs = apis</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以startHTTP为例进行追踪</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startHTTP initializes and starts the HTTP RPC endpoint.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">startHTTP</span><span class="params">(endpoint <span class="keyword">string</span>, apis []rpc.API, modules []<span class="keyword">string</span>, cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts rpc.HTTPTimeouts)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Short circuit if the HTTP endpoint isn&#x27;t being exposed</span></span><br><span class="line">	<span class="keyword">if</span> endpoint == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	listener, handler, err := rpc.StartHTTPEndpoint(endpoint, apis, modules, cors, vhosts, timeouts)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	n.log.Info(<span class="string">&quot;HTTP endpoint opened&quot;</span>, <span class="string">&quot;url&quot;</span>, fmt.Sprintf(<span class="string">&quot;http://%s&quot;</span>, endpoint), <span class="string">&quot;cors&quot;</span>, strings.Join(cors, <span class="string">&quot;,&quot;</span>), <span class="string">&quot;vhosts&quot;</span>, strings.Join(vhosts, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">	<span class="comment">// All listeners booted successfully</span></span><br><span class="line">	n.httpEndpoint = endpoint</span><br><span class="line">	n.httpListener = listener</span><br><span class="line">	n.httpHandler = handler</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HTTP相关的有3个字段：</p>
<p>httpEndpoint：这是一个字符串，表示IP和端口号，默认是localhost:8545<br>httpListener：这是一个接口，调用net.Listen()时返回，包含了Accept()/Close()/Addr()这3个函数，可以用来接受和关闭连接<br>httpHandler：这是一个需要重点分析的结构，定义位于rpc/types.go：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	services serviceRegistry</span><br><span class="line">	idgen    <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">ID</span></span></span><br><span class="line">	run      <span class="keyword">int32</span></span><br><span class="line">	codecs   mapset.Set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type serviceRegistry map[string]*service // collection of services<br>可以看到，其中有一个services字段，是一个map，key是Namespace，value是一个service实例。注意这个service类型首字母是小写的，所以是不对外暴露的，定义位于rpc/types.go：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	name          <span class="keyword">string</span>               <span class="comment">// name for service</span></span><br><span class="line">	callbacks     <span class="keyword">map</span>[<span class="keyword">string</span>]*callback <span class="comment">// registered handlers</span></span><br><span class="line">	subscriptions <span class="keyword">map</span>[<span class="keyword">string</span>]*callback <span class="comment">// available subscriptions/notifications</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service中包含了两个字段callbacks和subscriptions</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> callbacks <span class="keyword">map</span>[<span class="keyword">string</span>]*callback      <span class="comment">// collection of RPC callbacks</span></span><br><span class="line"><span class="keyword">type</span> subscriptions <span class="keyword">map</span>[<span class="keyword">string</span>]*callback  <span class="comment">// collection of subscription callbacks</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> callback <span class="keyword">struct</span> &#123;</span><br><span class="line">    rcvr        reflect.Value  <span class="comment">// receiver of method</span></span><br><span class="line">    method      reflect.Method <span class="comment">// callback</span></span><br><span class="line">    argTypes    []reflect.Type <span class="comment">// input argument types</span></span><br><span class="line">    hasCtx      <span class="keyword">bool</span>           <span class="comment">// method&#x27;s first argument is a context (not included in argTypes)</span></span><br><span class="line">    errPos      <span class="keyword">int</span>            <span class="comment">// err return idx, of -1 when method cannot return error</span></span><br><span class="line">    isSubscribe <span class="keyword">bool</span>           <span class="comment">// indication if the callback is a subscription</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>subscription是一种特殊的callback，而callback结构中包含了RPC API所需要的所有信息：</p>
<p>rcvr：方法的接收者，这是一个反射值类型，其实就是指向了之前的NewPublicEthereumAPI<br>method：对应rcvr中的函数<br>argTypes：函数参数的类型列表<br>hasCtx：标识函数的第一个参数是否是context.Context类型<br>isSubscribe：是否是subscription类型（因为它们共用一个结构定义）</p>
<p>注册流程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartHTTPEndpoint starts the HTTP RPC endpoint, configured with cors/vhosts/modules.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartHTTPEndpoint</span><span class="params">(endpoint <span class="keyword">string</span>, apis []API, modules []<span class="keyword">string</span>, cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts HTTPTimeouts)</span> <span class="params">(net.Listener, *Server, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := checkModuleAvailability(modules, apis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Generate the whitelist based on the allowed modules</span></span><br><span class="line">	whitelist := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, module := <span class="keyword">range</span> modules &#123;</span><br><span class="line">		whitelist[module] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Register all the APIs exposed by the services</span></span><br><span class="line">	handler := NewServer()</span><br><span class="line">	<span class="keyword">for</span> _, api := <span class="keyword">range</span> apis &#123;</span><br><span class="line">		<span class="keyword">if</span> whitelist[api.Namespace] || (<span class="built_in">len</span>(whitelist) == <span class="number">0</span> &amp;&amp; api.Public) &#123;</span><br><span class="line">			<span class="keyword">if</span> err := handler.RegisterName(api.Namespace, api.Service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			log.Debug(<span class="string">&quot;HTTP registered&quot;</span>, <span class="string">&quot;namespace&quot;</span>, api.Namespace)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All APIs registered, start the HTTP listener</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		listener net.Listener</span><br><span class="line">		err      error</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> listener, err = net.Listen(<span class="string">&quot;tcp&quot;</span>, endpoint); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> NewHTTPServer(cors, vhosts, timeouts, handler).Serve(listener)</span><br><span class="line">	<span class="keyword">return</span> listener, handler, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>registertname函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">RegisterName</span><span class="params">(name <span class="keyword">string</span>, receiver <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.services.registerName(name, receiver)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *serviceRegistry)</span> <span class="title">registerName</span><span class="params">(name <span class="keyword">string</span>, rcvr <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	rcvrVal := reflect.ValueOf(rcvr)</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;no service name for type %s&quot;</span>, rcvrVal.Type().String())</span><br><span class="line">	&#125;</span><br><span class="line">	callbacks := suitableCallbacks(rcvrVal)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(callbacks) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;service %T doesn&#x27;t have any suitable methods/subscriptions to expose&quot;</span>, rcvr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	r.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> r.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> r.services == <span class="literal">nil</span> &#123;</span><br><span class="line">		r.services = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]service)</span><br><span class="line">	&#125;</span><br><span class="line">	svc, ok := r.services[name]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		svc = service&#123;</span><br><span class="line">			name:          name,</span><br><span class="line">			callbacks:     <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*callback),</span><br><span class="line">			subscriptions: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*callback),</span><br><span class="line">		&#125;</span><br><span class="line">		r.services[name] = svc</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> name, cb := <span class="keyword">range</span> callbacks &#123;</span><br><span class="line">		<span class="keyword">if</span> cb.isSubscribe &#123;</span><br><span class="line">			svc.subscriptions[name] = cb</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			svc.callbacks[name] = cb</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是先创建一个service实例，然后填充它的callbacks和subscriptions字段。其中suitableCallbacks()函数会检查API定义是否符合标准，然后创建callback实例放入map中。</p>
<h3 id="创建服务："><a href="#创建服务：" class="headerlink" title="创建服务："></a>创建服务：</h3><p>在开启RPC服务的时候 开启http rpc请求</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := n.startHTTP(n.httpEndpoint, apis, n.config.HTTPModules, n.config.HTTPCors, n.config.HTTPVirtualHosts, n.config.HTTPTimeouts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	n.stopIPC()</span><br><span class="line">	n.stopInProc()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startHTTP initializes and starts the HTTP RPC endpoint.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">startHTTP</span><span class="params">(endpoint <span class="keyword">string</span>, apis []rpc.API, modules []<span class="keyword">string</span>, cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts rpc.HTTPTimeouts)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Short circuit if the HTTP endpoint isn&#x27;t being exposed</span></span><br><span class="line">	<span class="keyword">if</span> endpoint == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	listener, handler, err := rpc.StartHTTPEndpoint(endpoint, apis, modules, cors, vhosts, timeouts)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	n.log.Info(<span class="string">&quot;HTTP endpoint opened&quot;</span>, <span class="string">&quot;url&quot;</span>, fmt.Sprintf(<span class="string">&quot;http://%s&quot;</span>, endpoint), <span class="string">&quot;cors&quot;</span>, strings.Join(cors, <span class="string">&quot;,&quot;</span>), <span class="string">&quot;vhosts&quot;</span>, strings.Join(vhosts, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">	<span class="comment">// All listeners booted successfully</span></span><br><span class="line">	n.httpEndpoint = endpoint</span><br><span class="line">	n.httpListener = listener</span><br><span class="line">	n.httpHandler = handler</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StartHTTPEndpoint   启动一个线程开启serve服务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartHTTPEndpoint starts the HTTP RPC endpoint, configured with cors/vhosts/modules.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartHTTPEndpoint</span><span class="params">(endpoint <span class="keyword">string</span>, apis []API, modules []<span class="keyword">string</span>, cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts HTTPTimeouts)</span> <span class="params">(net.Listener, *Server, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := checkModuleAvailability(modules, apis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Generate the whitelist based on the allowed modules</span></span><br><span class="line">	whitelist := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> _, module := <span class="keyword">range</span> modules &#123;</span><br><span class="line">		whitelist[module] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Register all the APIs exposed by the services</span></span><br><span class="line">	handler := NewServer()</span><br><span class="line">	<span class="keyword">for</span> _, api := <span class="keyword">range</span> apis &#123;</span><br><span class="line">		<span class="keyword">if</span> whitelist[api.Namespace] || (<span class="built_in">len</span>(whitelist) == <span class="number">0</span> &amp;&amp; api.Public) &#123;</span><br><span class="line">			<span class="keyword">if</span> err := handler.RegisterName(api.Namespace, api.Service); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			log.Debug(<span class="string">&quot;HTTP registered&quot;</span>, <span class="string">&quot;namespace&quot;</span>, api.Namespace)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All APIs registered, start the HTTP listener</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		listener net.Listener</span><br><span class="line">		err      error</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> listener, err = net.Listen(<span class="string">&quot;tcp&quot;</span>, endpoint); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">go</span> NewHTTPServer(cors, vhosts, timeouts, handler).Serve(listener)</span><br><span class="line">	<span class="keyword">return</span> listener, handler, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用NewHTTPServer创建server</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHTTPServer</span><span class="params">(cors []<span class="keyword">string</span>, vhosts []<span class="keyword">string</span>, timeouts HTTPTimeouts, srv http.Handler)</span> *<span class="title">http</span>.<span class="title">Server</span></span> &#123;</span><br><span class="line">	<span class="comment">// Wrap the CORS-handler within a host-handler</span></span><br><span class="line">	handler := newCorsHandler(srv, cors)</span><br><span class="line">	handler = newVHostHandler(vhosts, handler)</span><br><span class="line">	handler = newGzipHandler(handler)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure timeout values are meaningful</span></span><br><span class="line">	<span class="keyword">if</span> timeouts.ReadTimeout &lt; time.Second &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Sanitizing invalid HTTP read timeout&quot;</span>, <span class="string">&quot;provided&quot;</span>, timeouts.ReadTimeout, <span class="string">&quot;updated&quot;</span>, DefaultHTTPTimeouts.ReadTimeout)</span><br><span class="line">		timeouts.ReadTimeout = DefaultHTTPTimeouts.ReadTimeout</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> timeouts.WriteTimeout &lt; time.Second &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Sanitizing invalid HTTP write timeout&quot;</span>, <span class="string">&quot;provided&quot;</span>, timeouts.WriteTimeout, <span class="string">&quot;updated&quot;</span>, DefaultHTTPTimeouts.WriteTimeout)</span><br><span class="line">		timeouts.WriteTimeout = DefaultHTTPTimeouts.WriteTimeout</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> timeouts.IdleTimeout &lt; time.Second &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Sanitizing invalid HTTP idle timeout&quot;</span>, <span class="string">&quot;provided&quot;</span>, timeouts.IdleTimeout, <span class="string">&quot;updated&quot;</span>, DefaultHTTPTimeouts.IdleTimeout)</span><br><span class="line">		timeouts.IdleTimeout = DefaultHTTPTimeouts.IdleTimeout</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Bundle and start the HTTP server</span></span><br><span class="line">	<span class="keyword">return</span> &amp;http.Server&#123;</span><br><span class="line">		Handler:      handler,</span><br><span class="line">		ReadTimeout:  timeouts.ReadTimeout,</span><br><span class="line">		WriteTimeout: timeouts.WriteTimeout,</span><br><span class="line">		IdleTimeout:  timeouts.IdleTimeout,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这里，handler是源码包中http.Server的一个组成部分，但是定义为一个接口，以太坊通过重载方法，将其自定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	Addr    <span class="keyword">string</span>  <span class="comment">// TCP address to listen on, &quot;:http&quot; if empty</span></span><br><span class="line">	Handler Handler <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line">。。。&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>处理http rpc请求的逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP serves JSON-RPC requests over HTTP.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Permit dumb empty requests for remote health-checks (AWS)</span></span><br><span class="line">	<span class="keyword">if</span> r.Method == http.MethodGet &amp;&amp; r.ContentLength == <span class="number">0</span> &amp;&amp; r.URL.RawQuery == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> code, err := validateRequest(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), code)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// All checks passed, create a codec that reads direct from the request body</span></span><br><span class="line">	<span class="comment">// untilEOF and writes the response to w and order the server to process a</span></span><br><span class="line">	<span class="comment">// single request.</span></span><br><span class="line">	ctx := r.Context()</span><br><span class="line">	ctx = context.WithValue(ctx, <span class="string">&quot;remote&quot;</span>, r.RemoteAddr)</span><br><span class="line">	ctx = context.WithValue(ctx, <span class="string">&quot;scheme&quot;</span>, r.Proto)</span><br><span class="line">	ctx = context.WithValue(ctx, <span class="string">&quot;local&quot;</span>, r.Host)</span><br><span class="line">	<span class="keyword">if</span> ua := r.Header.Get(<span class="string">&quot;User-Agent&quot;</span>); ua != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		ctx = context.WithValue(ctx, <span class="string">&quot;User-Agent&quot;</span>, ua)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> origin := r.Header.Get(<span class="string">&quot;Origin&quot;</span>); origin != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		ctx = context.WithValue(ctx, <span class="string">&quot;Origin&quot;</span>, origin)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	w.Header().Set(<span class="string">&quot;content-type&quot;</span>, contentType)</span><br><span class="line">	codec := newHTTPServerConn(r, w)</span><br><span class="line">	<span class="keyword">defer</span> codec.<span class="built_in">close</span>()</span><br><span class="line">	s.serveSingleRequest(ctx, codec)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serveSingleRequest reads and processes a single RPC request from the given codec. This</span></span><br><span class="line"><span class="comment">// is used to serve HTTP connections. Subscriptions and reverse calls are not allowed in</span></span><br><span class="line"><span class="comment">// this mode.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">serveSingleRequest</span><span class="params">(ctx context.Context, codec ServerCodec)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Don&#x27;t serve if server is stopped.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.LoadInt32(&amp;s.run) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	h := newHandler(ctx, codec, s.idgen, &amp;s.services)</span><br><span class="line">	h.allowSubscribe = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">defer</span> h.<span class="built_in">close</span>(io.EOF, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	reqs, batch, err := codec.readBatch()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">			codec.writeJSON(ctx, errorMessage(&amp;invalidMessageError&#123;<span class="string">&quot;parse error&quot;</span>&#125;))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> batch &#123;</span><br><span class="line">		h.handleBatch(reqs)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		h.handleMsg(reqs[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">handleMsg</span><span class="params">(msg *jsonrpcMessage)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ok := h.handleImmediate(msg); ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h.startCallProc(<span class="function"><span class="keyword">func</span><span class="params">(cp *callProc)</span></span> &#123;</span><br><span class="line">		answer := h.handleCallMsg(cp, msg)</span><br><span class="line">		h.addSubscriptions(cp.notifiers)</span><br><span class="line">		<span class="keyword">if</span> answer != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.conn.writeJSON(cp.ctx, answer)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, n := <span class="keyword">range</span> cp.notifiers &#123;</span><br><span class="line">			n.activate()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleCallMsg executes a call message and returns the answer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">handleCallMsg</span><span class="params">(ctx *callProc, msg *jsonrpcMessage)</span> *<span class="title">jsonrpcMessage</span></span> &#123;</span><br><span class="line">	start := time.Now()</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> msg.isNotification():</span><br><span class="line">		h.handleCall(ctx, msg)</span><br><span class="line">		h.log.Debug(<span class="string">&quot;Served &quot;</span>+msg.Method, <span class="string">&quot;t&quot;</span>, time.Since(start))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> msg.isCall():</span><br><span class="line">		resp := h.handleCall(ctx, msg)</span><br><span class="line">		<span class="keyword">if</span> resp.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.log.Warn(<span class="string">&quot;Served &quot;</span>+msg.Method, <span class="string">&quot;reqid&quot;</span>, idForLog&#123;msg.ID&#125;, <span class="string">&quot;t&quot;</span>, time.Since(start), <span class="string">&quot;err&quot;</span>, resp.Error.Message)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			h.log.Debug(<span class="string">&quot;Served &quot;</span>+msg.Method, <span class="string">&quot;reqid&quot;</span>, idForLog&#123;msg.ID&#125;, <span class="string">&quot;t&quot;</span>, time.Since(start))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resp</span><br><span class="line">	<span class="keyword">case</span> msg.hasValidID():</span><br><span class="line">		<span class="keyword">return</span> msg.errorResponse(&amp;invalidRequestError&#123;<span class="string">&quot;invalid request&quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> errorMessage(&amp;invalidRequestError&#123;<span class="string">&quot;invalid request&quot;</span>&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleCall processes method calls.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">handleCall</span><span class="params">(cp *callProc, msg *jsonrpcMessage)</span> *<span class="title">jsonrpcMessage</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> msg.isSubscribe() &#123;</span><br><span class="line">		<span class="keyword">return</span> h.handleSubscribe(cp, msg)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//新建callback对象</span></span><br><span class="line">	<span class="keyword">var</span> callb *callback</span><br><span class="line">	<span class="keyword">if</span> msg.isUnsubscribe() &#123;</span><br><span class="line">		callb = h.unsubscribeCb</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		callb = h.reg.callback(msg.Method)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> callb == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> msg.errorResponse(&amp;methodNotFoundError&#123;method: msg.Method&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//解析出参数</span></span><br><span class="line">	args, err := parsePositionalArguments(msg.Params, callb.argTypes)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> msg.errorResponse(&amp;invalidParamsError&#123;err.Error()&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> h.runMethod(cp.ctx, msg, callb, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runMethod runs the Go callback for an RPC method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">runMethod</span><span class="params">(ctx context.Context, msg *jsonrpcMessage, callb *callback, args []reflect.Value)</span> *<span class="title">jsonrpcMessage</span></span> &#123;</span><br><span class="line">    <span class="comment">//传入method args得到结果</span></span><br><span class="line">	result, err := callb.call(ctx, msg.Method, args)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> msg.errorResponse(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msg.response(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call invokes the callback.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *callback)</span> <span class="title">call</span><span class="params">(ctx context.Context, method <span class="keyword">string</span>, args []reflect.Value)</span> <span class="params">(res <span class="keyword">interface</span>&#123;&#125;, errRes error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Create the argument slice.</span></span><br><span class="line">	fullargs := <span class="built_in">make</span>([]reflect.Value, <span class="number">0</span>, <span class="number">2</span>+<span class="built_in">len</span>(args))</span><br><span class="line">	<span class="keyword">if</span> c.rcvr.IsValid() &#123;</span><br><span class="line">		fullargs = <span class="built_in">append</span>(fullargs, c.rcvr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.hasCtx &#123;</span><br><span class="line">		fullargs = <span class="built_in">append</span>(fullargs, reflect.ValueOf(ctx))</span><br><span class="line">	&#125;</span><br><span class="line">	fullargs = <span class="built_in">append</span>(fullargs, args...)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Catch panic while running the callback.</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">			buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">			buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">			log.Error(<span class="string">&quot;RPC method &quot;</span> + method + <span class="string">&quot; crashed: &quot;</span> + fmt.Sprintf(<span class="string">&quot;%v\n%s&quot;</span>, err, buf))</span><br><span class="line">			errRes = errors.New(<span class="string">&quot;method handler crashed&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// Run the callback.</span></span><br><span class="line">    <span class="comment">// 主要执行这一步</span></span><br><span class="line">	results := c.fn.Call(fullargs)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(results) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> c.errPos &gt;= <span class="number">0</span> &amp;&amp; !results[c.errPos].IsNil() &#123;</span><br><span class="line">		<span class="comment">// Method has returned non-nil error value.</span></span><br><span class="line">		err := results[c.errPos].Interface().(error)</span><br><span class="line">		<span class="keyword">return</span> reflect.Value&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results[<span class="number">0</span>].Interface(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里留一个坑。现已知go调用rpc是通过反射reflect实现的，reflect反射是指一类应用，它们能够自描述和自控制。具体实现还未完全掌握。</p>
<h3 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h3><p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST --data &#x27;&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_getBlockByHash&quot;,&quot;params&quot;:[&quot;0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331&quot;, true],&quot;id&quot;:1&#125;&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line"><span class="attr">&quot;jsonrpc&quot;</span>:<span class="string">&quot;2.0&quot;</span>,</span><br><span class="line"><span class="attr">&quot;result&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;number&quot;</span>: <span class="string">&quot;0x1b4&quot;</span>, <span class="comment">// 436</span></span><br><span class="line">    <span class="attr">&quot;hash&quot;</span>: <span class="string">&quot;0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;parentHash&quot;</span>: <span class="string">&quot;0x9646252be9520f6e71339a8df9c55e4d7619deeb018d2a3f2d21fc165dde5eb5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;nonce&quot;</span>: <span class="string">&quot;0xe04d296d2460cfb8472af2c5fd05b5a214109c25688d3704aed5484f9a7792f2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sha3Uncles&quot;</span>: <span class="string">&quot;0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;logsBloom&quot;</span>: <span class="string">&quot;0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;transactionsRoot&quot;</span>: <span class="string">&quot;0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;stateRoot&quot;</span>: <span class="string">&quot;0xd5855eb08b3387c0af375e9cdb6acfc05eb8f519e419b874b6ff2ffda7ed1dff&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;miner&quot;</span>: <span class="string">&quot;0x4e65fda2159562a496f9f3522f89122a3088497a&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;difficulty&quot;</span>: <span class="string">&quot;0x027f07&quot;</span>, <span class="comment">// 163591</span></span><br><span class="line">    <span class="attr">&quot;totalDifficulty&quot;</span>:  <span class="string">&quot;0x027f07&quot;</span>, <span class="comment">// 163591</span></span><br><span class="line">    <span class="attr">&quot;extraData&quot;</span>: <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>:  <span class="string">&quot;0x027f07&quot;</span>, <span class="comment">// 163591</span></span><br><span class="line">    <span class="attr">&quot;gasLimit&quot;</span>: <span class="string">&quot;0x9f759&quot;</span>, <span class="comment">// 653145</span></span><br><span class="line">    <span class="attr">&quot;gasUsed&quot;</span>: <span class="string">&quot;0x9f759&quot;</span>, <span class="comment">// 653145</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;0x54e34e8e&quot;</span> <span class="comment">// 1424182926</span></span><br><span class="line">    <span class="string">&quot;transactions&quot;</span>: [&#123;...&#125;,&#123; ... &#125;] </span><br><span class="line">    <span class="string">&quot;uncles&quot;</span>: [<span class="string">&quot;0x1606e5...&quot;</span>, <span class="string">&quot;0xd5145a9...&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>请求对象需要包括下面4个字段：</p>
<ul>
<li>jsonrpc：协议版本号，固定是2.0</li>
<li>method：请求调用的函数名，可以看到是Namespace_Method这种命名方式</li>
<li>params： 函数参数列表，一般是一个数组</li>
<li>id：客户端和服务器之前通信的一个标识，服务器返回响应时必须返回相同的id。可以是数字或者字符串，不建议设为NULL</li>
</ul>
<p>返回的响应需要包含以下字段：</p>
<ul>
<li>jsonrpc：协议版本号，固定是2.0</li>
<li>result/error：返回的结果或者错误，二选一</li>
<li>id：客户端和服务器之前通信的一个标识，服务器返回响应时必须返回相同的id。可以是数字或者字符串，不建议设为NULL</li>
</ul>
<p>当收到调用rpc请求时一般会调用Dial函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dial creates a new client for the given URL.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The currently supported URL schemes are &quot;http&quot;, &quot;https&quot;, &quot;ws&quot; and &quot;wss&quot;. If rawurl is a</span></span><br><span class="line"><span class="comment">// file name with no URL scheme, a local socket connection is established using UNIX</span></span><br><span class="line"><span class="comment">// domain sockets on supported platforms and named pipes on Windows. If you want to</span></span><br><span class="line"><span class="comment">// configure transport options, use DialHTTP, DialWebsocket or DialIPC instead.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For websocket connections, the origin is set to the local host name.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The client reconnects automatically if the connection is lost.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(rawurl <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> DialContext(context.Background(), rawurl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DialContext creates a new RPC client, just like Dial.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The context is used to cancel or time out the initial connection establishment. It does</span></span><br><span class="line"><span class="comment">// not affect subsequent interactions with the client.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, rawurl <span class="keyword">string</span>)</span> <span class="params">(*Client, error)</span></span> &#123;</span><br><span class="line">	u, err := url.Parse(rawurl)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> u.Scheme &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;http&quot;</span>, <span class="string">&quot;https&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> DialHTTP(rawurl)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;ws&quot;</span>, <span class="string">&quot;wss&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> DialWebsocket(ctx, rawurl, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;stdio&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> DialStdIO(ctx)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> DialIPC(ctx, rawurl)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;no known transport for URL scheme %q&quot;</span>, u.Scheme)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在console/bridge.go控制台处理时也会调用到</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Send implements the web3 provider &quot;send&quot; method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bridge)</span> <span class="title">Send</span><span class="params">(call jsre.Call)</span> <span class="params">(goja.Value, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">	<span class="comment">// Remarshal the request into a Go value.</span></span><br><span class="line">	<span class="comment">// Execute the requests.</span></span><br><span class="line">	<span class="keyword">var</span> resps []*goja.Object</span><br><span class="line">	<span class="keyword">for</span> _, req := <span class="keyword">range</span> reqs &#123;</span><br><span class="line">		resp := call.VM.NewObject()</span><br><span class="line">		resp.Set(<span class="string">&quot;jsonrpc&quot;</span>, <span class="string">&quot;2.0&quot;</span>)</span><br><span class="line">		resp.Set(<span class="string">&quot;id&quot;</span>, req.ID)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> result json.RawMessage</span><br><span class="line">		err = b.client.Call(&amp;result, req.Method, req.Params...)</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后还是调用到rpc/client.go 的call方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Call</span><span class="params">(result <span class="keyword">interface</span>&#123;&#125;, method <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	<span class="keyword">return</span> c.CallContext(ctx, result, method, args...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">CallContext</span><span class="params">(ctx context.Context, result <span class="keyword">interface</span>&#123;&#125;, method <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	msg, err := c.newMessage(method, args...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	op := &amp;requestOp&#123;ids: []json.RawMessage&#123;msg.ID&#125;, resp: <span class="built_in">make</span>(<span class="keyword">chan</span> *jsonrpcMessage, <span class="number">1</span>)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> c.isHTTP &#123;</span><br><span class="line">		err = c.sendHTTP(ctx, op, msg)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = c.send(ctx, op, msg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dispatch has accepted the request and will close the channel when it quits.</span></span><br><span class="line">	<span class="keyword">switch</span> resp, err := op.wait(ctx, c); &#123;</span><br><span class="line">	<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	<span class="keyword">case</span> resp.Error != <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">return</span> resp.Error</span><br><span class="line">	<span class="keyword">case</span> <span class="built_in">len</span>(resp.Result) == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> ErrNoResult</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> json.Unmarshal(resp.Result, &amp;result)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">sendHTTP</span><span class="params">(ctx context.Context, op *requestOp, msg <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	hc := c.writeConn.(*httpConn)</span><br><span class="line">	respBody, err := hc.doRequest(ctx, msg)</span><br><span class="line">	<span class="keyword">if</span> respBody != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> respBody.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> respBody != <span class="literal">nil</span> &#123;</span><br><span class="line">			buf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">			<span class="keyword">if</span> _, err2 := buf.ReadFrom(respBody); err2 == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%v %v&quot;</span>, err, buf.String())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> respmsg jsonrpcMessage</span><br><span class="line">	<span class="keyword">if</span> err := json.NewDecoder(respBody).Decode(&amp;respmsg); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	op.resp &lt;- &amp;respmsg</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rpc/http.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(hc *httpConn)</span> <span class="title">doRequest</span><span class="params">(ctx context.Context, msg <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(io.ReadCloser, error)</span></span> &#123;</span><br><span class="line">	body, err := json.Marshal(msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	req := hc.req.WithContext(ctx)</span><br><span class="line">	req.Body = ioutil.NopCloser(bytes.NewReader(body))</span><br><span class="line">	req.ContentLength = <span class="keyword">int64</span>(<span class="built_in">len</span>(body))</span><br><span class="line"></span><br><span class="line">	resp, err := hc.client.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> resp.StatusCode &lt; <span class="number">200</span> || resp.StatusCode &gt;= <span class="number">300</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> resp.Body, errors.New(resp.Status)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resp.Body, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往下调用就是源码包的http/client.go的方法了</p>
<p>eth/api.go和internal/ethapi/api.go的关系：internal包中的api是对jsonrpc的拓展</p>
<h3 id="关键命令"><a href="#关键命令" class="headerlink" title="关键命令"></a>关键命令</h3><p><strong>命令1</strong>: personal.newAccount(password) - 新建账户</p>
<p>api: internal/ethapi.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PrivateAccountAPI)</span> <span class="title">NewAccount</span><span class="params">(password <span class="keyword">string</span>)</span> <span class="params">(common.Address, error)</span>`</span></span><br></pre></td></tr></table></figure>

<p><strong>命令2</strong>：miner.start(threadNum) - 开始挖矿，默认<code>eth.accounts</code>第一个用户</p>
<p>api: eth/api.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PrivateMinerAPI)</span> <span class="title">Start</span><span class="params">(threads *<span class="keyword">int</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p><strong>命令3</strong>：miner.stop() - 停止挖矿</p>
<p>api: eth/api.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *PrivateMinerAPI)</span> <span class="title">Stop</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><strong>命令4</strong>：personal.unlockAccount(address, password) - 转账前解锁账户</p>
<p>api:  internal/ethapi.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PrivateAccountAPI)</span> <span class="title">UnlockAccount</span><span class="params">(addr common.Address, password <span class="keyword">string</span>, duration *<span class="keyword">uint64</span>)</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>命令5</strong>：eth.sendTransaction({from: _, to: _, value: _}) - 转账</p>
<p>api: ethapi/api.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PrivateAccountAPI)</span> <span class="title">SendTransaction</span><span class="params">(ctx context.Context, args SendTxArgs, passwd <span class="keyword">string</span>)</span> <span class="params">(common.Hash,error)</span></span></span><br></pre></td></tr></table></figure>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2020/02/25/%E4%BB%A5%E5%A4%AA%E5%9D%8ARPC%E9%80%9A%E4%BF%A1/" data-id="ckqoyya4y0029xcu732fbhzt7" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  <li role="presentation">
    <a href="/2020/02/14/go-ethreum%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left pull-left"></i>
      <span class="article-nav-link-title">go-ethreum源码目录结构</span>
    </a>
  </li>
  
  
  <li role="presentation">
    <a href="/2020/02/25/%E7%8A%B6%E6%80%81%EF%BC%9B%E7%8A%B6%E6%80%81%E6%A0%91%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" id="article-nav-newer" class="article-nav-link-wrap">
      <span class="article-nav-link-title">以太坊中的状态树代码</span>
      <i class="fa fa-chevron-right pull-right"></i>
    </a>
  </li>
  
</ul>


  
</article>




        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p> Nice papers collected in the field of <em>AI</em>, <em>Apllied Cryptography</em> and <em>Blockchain</em>, records of some computer technologies, and personal thoughts.  If you are inteseted in my field, feel free to contact me. (Wechat: mzliu_xdu) </p>

</div>


  


  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list" itemprop="keywords"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Bitcoin/" rel="tag">Bitcoin</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Projects/" rel="tag">Projects</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/golang/" rel="tag">golang</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/hyperledger-fabric/" rel="tag">hyperledger fabric</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/java/" rel="tag">java</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/paper-notes/" rel="tag">paper notes</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a><span class="sidebar-module-list-count">18</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/Bitcoin/" style="font-size: 10px;">Bitcoin</a> <a href="/tags/Projects/" style="font-size: 16px;">Projects</a> <a href="/tags/golang/" style="font-size: 18px;">golang</a> <a href="/tags/hyperledger-fabric/" style="font-size: 12px;">hyperledger fabric</a> <a href="/tags/java/" style="font-size: 12px;">java</a> <a href="/tags/paper-notes/" style="font-size: 14px;">paper notes</a> <a href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" style="font-size: 20px;">以太坊</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/07/">July 2021</a><span class="sidebar-module-list-count">16</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">February 2020</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">August 2019</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2021/07/04/shuffle/">shuffle</a>
        </li>
      
        <li>
          <a href="/2021/07/04/%E8%9E%8D%E4%BF%A1%E9%93%BE/">融信链</a>
        </li>
      
        <li>
          <a href="/2021/07/04/MaskChain/">MaskChain隐私计算链</a>
        </li>
      
        <li>
          <a href="/2021/07/02/DoERS_note/">DoERS notes</a>
        </li>
      
        <li>
          <a href="/2021/07/02/ML-Papers-in-Top-Security-Conferences/">ML Papers in Top Security Conferences</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2021 Mingzhe Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>




<script src="/js/script.js"></script>


</body>
</html>
