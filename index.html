<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Yezzi Tech</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Nice paper collection, computer tech records, and personal thoughts">
<meta property="og:type" content="website">
<meta property="og:title" content="Yezzi Tech">
<meta property="og:url" content="https://yezzi.tech/index.html">
<meta property="og:site_name" content="Yezzi Tech">
<meta property="og:description" content="Nice paper collection, computer tech records, and personal thoughts">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Mingzhe Liu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Yezzi Tech" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="/css/styles.css">

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class="active"
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">Yezzi Tech</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-DoERS_note" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/DoERS_note/">BlockChain Papers in Top Security Conferences</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/DoERS_note/" class="article-date"><time datetime="2021-07-02T10:37:40.000Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Summarize the paper <strong>As Strong As Its Weakest Link: How to Break Blockchain DApps at RPC Service</strong>（NDSS 2021）in detail</p>
        
          <p class="article-more-link">
            <a class="btn btn-primary" href="/2021/07/02/DoERS_note/#more">Read More</a>
          </p>
        
      
    </div>

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/DoERS_note/" data-id="ckqma5nqu00010wu7a4f79ty0" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/paper-notes/" rel="tag">paper notes</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-交易签名和验签" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E4%BA%A4%E6%98%93%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/">以太坊签名相关代码</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E4%BA%A4%E6%98%93%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/" class="article-date"><time datetime="2021-07-02T10:37:40.000Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h6 id="以太坊中交易的结构有-r-s-v-字段"><a href="#以太坊中交易的结构有-r-s-v-字段" class="headerlink" title="以太坊中交易的结构有 r s v 字段"></a>以太坊中交易的结构有 r s v 字段</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">	AccountNonce <span class="keyword">uint64</span>          <span class="string">`json:&quot;nonce&quot;    gencodec:&quot;required&quot;`</span><span class="comment">//由交易发送者发出的的交易的数量，由 Tn 表示</span></span><br><span class="line">	Price        *big.Int        <span class="string">`json:&quot;gasPrice&quot; gencodec:&quot;required&quot;`</span><span class="comment">//为执行这个交易所需要进行的计算步骤消 耗的每单位 gas 的价格，以 Wei 为单位，由 Tp 表 示。</span></span><br><span class="line">	GasLimit     <span class="keyword">uint64</span>          <span class="string">`json:&quot;gas&quot;      gencodec:&quot;required&quot;`</span><span class="comment">//用于执行这个交易的最大 gas 数量。这个值须在交易开始前设置，且设定后不能再增加，由Tg 表示。</span></span><br><span class="line">	Recipient    *common.Address <span class="string">`json:&quot;to&quot;       rlp:&quot;nil&quot;`</span> <span class="comment">// nil means contract creation 160 位的消息调用接收者地址；对与合约创建交易，用 ∅ 表示 B0 的唯一成员。此字段由 Tt 表示</span></span><br><span class="line">	Amount       *big.Int        <span class="string">`json:&quot;value&quot;    gencodec:&quot;required&quot;`</span><span class="comment">//转移到接收者账户的 Wei 的数量；对于合约 创建，则代表给新建合约地址的初始捐款。由 Tv 表示。</span></span><br><span class="line">	Payload      []<span class="keyword">byte</span>          <span class="string">`json:&quot;input&quot;    gencodec:&quot;required&quot;`</span><span class="comment">//如果目标账户包含代码，该代码会执行，payload就是输入数据。</span></span><br><span class="line">																	  <span class="comment">//如果目标账户是零账户（账户地址是0），交易将创建一个新合约。</span></span><br><span class="line">																	  <span class="comment">//这个合约地址不是零地址，而是由合约创建者的地址和该地址发出过的交易数量（被称为nonce）计算得到。</span></span><br><span class="line">																	  <span class="comment">//创建合约交易的payload被当作EVM字节码执行。执行的输出做为合约代码被永久存储。这意味着，为了创建一个合约，</span></span><br><span class="line">																	  <span class="comment">//你不需要向合约发送真正的合约代码，而是发送能够返回真正代码的代码。</span></span><br><span class="line">	                                                                  <span class="comment">//</span></span><br><span class="line">	<span class="comment">// Signature values											      //</span></span><br><span class="line">	V *big.Int <span class="string">`json:&quot;v&quot; gencodec:&quot;required&quot;`</span><span class="comment">//v, r, s: 与交易签名相符的若干数值，用于确定交易的发送者，由 Tw，Tr 和 Ts 表示。</span></span><br><span class="line">	R *big.Int <span class="string">`json:&quot;r&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">	S *big.Int <span class="string">`json:&quot;s&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// This is only used when marshaling to JSON.</span></span><br><span class="line">	Hash *common.Hash <span class="string">`json:&quot;hash&quot; rlp:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="签名的函数"><a href="#签名的函数" class="headerlink" title="签名的函数"></a>签名的函数</h6><p>其实还是用secp256k1进行的签名，只是把比特币中签名的数据格式稍作改变</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//crypto/signature_nocgo.go:60</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sign</span><span class="params">(hash []<span class="keyword">byte</span>, prv *ecdsa.PrivateKey)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//检查哈希的长度是否为32字节</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(hash) != <span class="number">32</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;hash is required to be exactly 32 bytes (%d)&quot;</span>, <span class="built_in">len</span>(hash))</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//检查私钥的曲线符合secp256k1</span></span><br><span class="line">	<span class="keyword">if</span> prv.Curve != btcec.S256() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;private key curve is not secp256k1&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//传入私钥，签名的内容，私钥选项为非压缩，签名的返回为[27 + recid] [R] [S]</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	sig, err := btcec.SignCompact(btcec.S256(), (*btcec.PrivateKey)(prv), hash, <span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//比特币中第一个字节的值等于27+recid，因此 recid= sig[0]-27</span></span><br><span class="line">	v := sig[<span class="number">0</span>] - <span class="number">27</span> </span><br><span class="line">    <span class="comment">//调整顺序为r s v</span></span><br><span class="line">	<span class="built_in">copy</span>(sig, sig[<span class="number">1</span>:])</span><br><span class="line">	sig[<span class="number">64</span>] = v</span><br><span class="line">	<span class="keyword">return</span> sig, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="./picture/11.png!de"></p>
<p>简单地说，就是传入要签名的数据和私钥对结果进行签名，得到r s v 格式的签名结果，签名结果是65字节的字节数组。一个字节是8位，一个字符是4位，所以转化为字符串时长度为130.</p>
<p><strong>在交易签名时，V 值不再是recid, 而是 recid+ chainID*2+ 35(老版签名是recud+27)</strong></p>
<h6 id="验签的函数"><a href="#验签的函数" class="headerlink" title="验签的函数"></a>验签的函数</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	decodeHex:= <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">		b,err:=hex.DecodeString(s)</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	dataHash := sha256.Sum256([]<span class="keyword">byte</span>(<span class="string">&quot;ethereum&quot;</span>))</span><br><span class="line">	sig:=decodeHex(</span><br><span class="line"><span class="string">&quot;7912f50819764de81ab7791ab3d62f8dabe84c2fdb2f17d76465d28f8a968f7355fbb6cd8dfc7545b6258d4b032753b2074232b07f3911822b37f024cd10116600&quot;</span>)</span><br><span class="line">	pubkey:=decodeHex(</span><br><span class="line">	<span class="string">&quot;037db227d7094ce215c3a0f57e1bcc732551fe351f94249471934567e0f5dc1bf7&quot;</span>)</span><br><span class="line"></span><br><span class="line">	ok:=crypto.VerifySignature(pubkey,dataHash[:],sig[:<span class="built_in">len</span>(sig)<span class="number">-1</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;verify pass?&quot;</span>,ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入公钥，签名数据，验证是否验签通过。</p>
<p>关键点在于调用校验签名函数时，第三个参数sig 送入的是 <code>sig[:len(sig)-1]</code> 去掉了末尾的一个字节。这是因为函数<code>VerifySignature</code>要求 <code>sig</code>参数必须是<code>[R] [S]</code>格式，因此需要去除末尾的<code>[V]</code>。</p>
<p>实际在区块链中，为了安全性签名中加入了特性数据，比如签名类型(环签、单私钥签名等)、链标识符等。</p>
<h6 id="以太坊中区块中的交易的签名和验签"><a href="#以太坊中区块中的交易的签名和验签" class="headerlink" title="以太坊中区块中的交易的签名和验签"></a>以太坊中区块中的交易的签名和验签</h6><p>签名解析</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//core/types/transaction_signing.go</span></span><br><span class="line"><span class="comment">//tx是交易 s是签名器，根据区块高度不同有两个版本的签名器， prv是私匙</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignTx</span><span class="params">(tx *Transaction, s Signer, prv *ecdsa.PrivateKey)</span> <span class="params">(*Transaction, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//先对交易数据取哈希</span></span><br><span class="line">   h := s.Hash(tx)</span><br><span class="line">    <span class="comment">//用私钥对交易签名</span></span><br><span class="line">   sig, err := crypto.Sign(h[:], prv)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//将签名信息赋给交易</span></span><br><span class="line">   <span class="keyword">return</span> tx.WithSignature(s, sig)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将签名信息赋给交易</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">WithSignature</span><span class="params">(signer Signer, sig []<span class="keyword">byte</span>)</span> <span class="params">(*Transaction, error)</span></span> &#123;</span><br><span class="line"> r, s, v, err := signer.SignatureValues(tx, sig)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line"> &#125;</span><br><span class="line"> cpy := &amp;Transaction&#123;data: tx.data&#125;</span><br><span class="line"> <span class="comment">//分别赋值给rsv   </span></span><br><span class="line"> cpy.data.R, cpy.data.S, cpy.data.V = r, s, v</span><br><span class="line"> <span class="keyword">return</span> cpy, <span class="literal">nil</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>验签解析</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//core/types/transaction_signing.go:127</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s EIP155Signer)</span> <span class="title">Sender</span><span class="params">(tx *Transaction)</span> <span class="params">(common.Address, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//看是不是老版交易</span></span><br><span class="line">   <span class="keyword">if</span> !tx.Protected() &#123; </span><br><span class="line">      <span class="keyword">return</span> HomesteadSigner&#123;&#125;.Sender(tx)</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//看chainid是否和签名器所指示的链id一致</span></span><br><span class="line">   <span class="keyword">if</span> tx.ChainId().Cmp(s.chainId) != <span class="number">0</span> &#123; </span><br><span class="line">      <span class="keyword">return</span> common.Address&#123;&#125;, ErrInvalidChainId</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">   V := <span class="built_in">new</span>(big.Int).Sub(tx.data.V, s.chainIdMul)</span><br><span class="line">   V.Sub(V, big8)</span><br><span class="line">   <span class="keyword">return</span> recoverPlain(s.Hash(tx), tx.data.R, tx.data.S, V, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverPlain</span><span class="params">(sighash common.Hash, R, S, Vb *big.Int, homestead <span class="keyword">bool</span>)</span> <span class="params">(common.Address, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> Vb.BitLen() &gt; <span class="number">8</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> common.Address&#123;&#125;, ErrInvalidSig</span><br><span class="line">	&#125;</span><br><span class="line">	V := <span class="keyword">byte</span>(Vb.Uint64() - <span class="number">27</span>)</span><br><span class="line">	<span class="keyword">if</span> !crypto.ValidateSignatureValues(V, R, S, homestead) &#123;</span><br><span class="line">		<span class="keyword">return</span> common.Address&#123;&#125;, ErrInvalidSig</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// encode the signature in uncompressed format</span></span><br><span class="line">	r, s := R.Bytes(), S.Bytes()</span><br><span class="line">	sig := <span class="built_in">make</span>([]<span class="keyword">byte</span>, crypto.SignatureLength)</span><br><span class="line">	<span class="built_in">copy</span>(sig[<span class="number">32</span>-<span class="built_in">len</span>(r):<span class="number">32</span>], r)</span><br><span class="line">	<span class="built_in">copy</span>(sig[<span class="number">64</span>-<span class="built_in">len</span>(s):<span class="number">64</span>], s)</span><br><span class="line">	sig[<span class="number">64</span>] = V</span><br><span class="line">	<span class="comment">// recover the public key from the signature</span></span><br><span class="line">	pub, err := crypto.Ecrecover(sighash[:], sig)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> common.Address&#123;&#125;, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(pub) == <span class="number">0</span> || pub[<span class="number">0</span>] != <span class="number">4</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> common.Address&#123;&#125;, errors.New(<span class="string">&quot;invalid public key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> addr common.Address</span><br><span class="line">	<span class="built_in">copy</span>(addr[:], crypto.Keccak256(pub[<span class="number">1</span>:])[<span class="number">12</span>:])</span><br><span class="line">	<span class="keyword">return</span> addr, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E4%BA%A4%E6%98%93%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/" data-id="ckqma5nrz000x0wu7b5oh7zet" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-以太坊中的编码" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81/">以太坊中的各种编码</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81/" class="article-date"><time datetime="2021-07-02T10:37:40.000Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h2 id="RLP编码"><a href="#RLP编码" class="headerlink" title="RLP编码"></a>RLP编码</h2><p>RLP (递归长度前缀)提供了一种适用于任意二进制数据数组的编码，RLP已经成为以太坊中对对象进行序列化的主要编码方式。 RLP的唯一目标就是解决结构体的编码问题；对原子数据类型（比如，字符串，整数型，浮点型）的编码则交给更高层的协议；以太坊中要求数字必须是一个大端字节序的、没有零占位的存储的格式（也就是说，一个整数0和一个空数组是等同的）。</p>
<h4 id="RLP编码规则"><a href="#RLP编码规则" class="headerlink" title="RLP编码规则"></a>RLP编码规则</h4><p>总体可以概括为: <code>内容</code> (单字节) , <code>前缀+内容</code> (总长&lt;55) , 或 <code>前缀+长度+内容</code> (总长&gt;55)</p>
<ol>
<li><strong>规则1(内容).</strong> . [0x00, 0x7f] 范围内的 <code>单个字节</code> , RLP 编码内容就是字节内容本身。</li>
</ol>
<p>例子：</p>
<ul>
<li><code>‘a’ = 0x61</code></li>
<li>整数  <code>15(&#39;\x0f&#39;) = 0x0f</code></li>
</ul>
<ol>
<li><strong>规则2(前缀+内容).</strong> . 0-55字节长度的字符串，RLP编码是 <code>前缀（0x80+len(字符串)）+字符串内容</code></li>
</ol>
<p>例子：</p>
<ul>
<li>abc编码结果是0x83 0x61 0x62 0x63，其中0x83=0x80+len(“abc”)。</li>
<li>整数 1024(‘\x04\00’) = [0x82, 0x04, 0x00]</li>
<li>空字符串 “” = 0x80</li>
<li>字符串  <code>&quot;dog&quot; = [0x83, &#39;d&#39;, &#39;o&#39;, &#39;g&#39; ]</code></li>
</ul>
<ol>
<li><strong>规则3(前缀+长度+内容)</strong> . &gt;55字节长度字符串, RLP编码是 <code>前缀（0xb7＋len(len(字符串)))+len(字符串)+字符串内容</code></li>
</ol>
<p>例子:</p>
<ul>
<li>字符串 “Lorem ipsum dolor sit amet, consectetur adipisicing elit” = [0xb8, 0x38, ‘L’, ‘o’, ‘r’, ‘e’, ‘m’, ‘ ‘, … , ‘e’, ‘l’, ‘i’, ‘t’]</li>
</ul>
<ol>
<li><strong>规则4(前缀+内容).</strong> . 列表的总长度（列表的总长度指的是它包含的项的数量加它包含的各项的长度之和）是0-55字节，它的RLP编码是 <code>前缀(0xc0+len(列表总))+列表中各元素项的RLP编码</code> ，前缀取值范围是 <code>[0xc0, 0xf7]</code> 。</li>
</ol>
<p>例子:</p>
<ul>
<li><p>列表  <code>[&quot;cate&quot;,&quot;dog&quot;] = [0xc9, 0x84, &#39;c&#39;, &#39;a&#39;, &#39;t&#39;, &#39;e&#39;,0x83, &#39;d&#39;, &#39;o&#39;, &#39;g&#39; ]</code></p>
<p><code>0xc9</code> = 0xc0+ 1+4+1+3 (1:字符串长度的长度, 4:字符串长度, 1:字符串长度的长度,3:字符串长度)</p>
</li>
<li><p>列表  <code>[ [], [[]], [ [], [[]] ] ] = [0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0]</code></p>
</li>
<li><p><strong>规则5(前缀+长度+内容).</strong> ** ** 列表的总长度大于55字节，它的RLP编码是 <code>前缀(0xf7+len(len(列表总)))+len(列表总)+列表中各元素项的RLP编码</code> ，前缀取值范围是 <code>[0xf8, 0xff]</code> 。</p>
<p>例子:</p>
<ul>
<li><p>列表 <code>[&quot;The length of this sentence is more than 55 bytes, &quot;, &quot;I know it because I pre-designed it&quot;] = [0xf8 0x58 0xb3 &#39;T&#39;,&#39;h&#39;,&#39;e&#39;,...</code></p>
<p>0xf8=0xf7+1 (1:列表总长度的长度)</p>
<p>0x58=0x56+1+1 (0x56:列表总长度 1+1: 2个字符串长度的长度)</p>
<p>0xb3=0x80+0x33 (33: 字符串长度)</p>
</li>
</ul>
</li>
</ul>
<p>综合编码的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&quot;abc&quot;,[&quot;The length of this sentence is more than 55 bytes, &quot;, &quot;I know it because I pre-designed it&quot;]]</span><br><span class="line">= [0xf8 0x5e 0x83 0x61 98 99 248 88 179 84 104 101 32 108 101 110 103 116 104 32 111 102 32 116 104 105 115 32 115 101 110 116 101 110 99 101 32 105 115 32 109 111 114 101 32 116 104 97 110 32 53 53 32 98 121 116 101 115 44 32 163 73 32 107 110 111 119 32 105 116 32 98 101 99 97 117 115 101 32 73 32 112 114 101 45 100 101 115 105 103 110 101 100 32 105 116]</span><br></pre></td></tr></table></figure>

<p>0xf8=0xf7+1 (1:列表总长度的长度)</p>
<p>0x5e=90 + 1 +2 +1 (90:字符串总长度 1:第一个字符串前缀长度 2: 第二个字符串前缀+长度 1: 第三个字符串前缀)</p>
<h4 id="RLP解码规则"><a href="#RLP解码规则" class="headerlink" title="RLP解码规则"></a>RLP解码规则</h4><ol>
<li>如果f∈ [0,128),　那么它是一个字节本身。</li>
</ol>
<p>2.　如果f∈[128,184)，那么它是一个长度不超过55的byte数组，数组的长度为  <code>l=f-128</code></p>
<p>3.　如果f∈[184,192)，那么它是一个长度超过55的数组，长度本身的编码长度 <code>ll=f-183</code> ,然后从第二个字节开始读取长度为ll的bytes，按照BigEndian编码成整数l，l即为数组的长度。</p>
<p>4.　如果f∈(192,247]，那么它是一个编码后总长度不超过55的列表，列表长度为 <code>l=f-192</code> 。递归使用规则1~4进行解码。</p>
<p>5.　如果f∈(247,256]，那么它是编码后长度大于55的列表，其长度本身的编码长度 <code>ll=f-247</code> ,然后从第二个字节读取长度为ll的bytes,按BigEndian编码成整数l，l即为子列表长度。然后递归根据解码规则进行解码。</p>
<h4 id="RLP在以太坊中的使用"><a href="#RLP在以太坊中的使用" class="headerlink" title="RLP在以太坊中的使用"></a>RLP在以太坊中的使用</h4><p>以构成交易树/状态树为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeriveSha</span><span class="params">(list DerivableList)</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">	keybuf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	trie := <span class="built_in">new</span>(trie.Trie)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; list.Len(); i++ &#123;</span><br><span class="line">		keybuf.Reset()</span><br><span class="line">        <span class="comment">//编码序号</span></span><br><span class="line">		rlp.Encode(keybuf, <span class="keyword">uint</span>(i))</span><br><span class="line">        <span class="comment">//编码list[i]并存入mpt树中</span></span><br><span class="line">		trie.Update(keybuf.Bytes(), list.GetRlp(i))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> trie.Hash()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构成最底层mpt树的时候，将 序号rlp编码，交易内容的rlp编码 构成一个键值对 放入mpt树中存储</p>
<h4 id="MPT中的编码"><a href="#MPT中的编码" class="headerlink" title="MPT中的编码"></a>MPT中的编码</h4><p>在以太坊协议中，不管是地址还是hash，都是一个16进制串，如”0x5b3edbcf7d0a97e95e57a4554a29ea66601b71ad”，数据最小的表示单位为一位16进制，如1、a等，但在编程实现中，数据的最小表示单位往往是byte（8bit，2位16进制数），这样在用byte来表示一串奇数长度的16进制串时会出现问题，如”5b3”和”5b30”，直接转成byte都是5b30。还有一种简单直观的转换方式，”5b3”-&gt;”050b03”，这种方式虽然简单，但是数据量会翻倍，不利于大量hash的计算，同时也会增加tree的大小，降低同步性能。Hex-Prefix Encoding能解决这些问题。</p>
<h6 id="hex编码"><a href="#hex编码" class="headerlink" title="hex编码"></a>hex编码</h6><p>用于树路径中，是将数据 key 进行半字节拆解而成。即依次将 key[0],key[1],…,key[n] 分别进行半字节拆分成两个数，再依次存放在长度为 len(key)+1 的数组中。 并在数组末尾写入终止符 <code>16</code>。算法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trie/encoding.go:65</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keybytesToHex</span><span class="params">(str []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	l := <span class="built_in">len</span>(str)*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> nibbles = <span class="built_in">make</span>([]<span class="keyword">byte</span>, l)</span><br><span class="line">	<span class="keyword">for</span> i, b := <span class="keyword">range</span> str &#123;</span><br><span class="line">		nibbles[i*<span class="number">2</span>] = b / <span class="number">16</span></span><br><span class="line">		nibbles[i*<span class="number">2</span>+<span class="number">1</span>] = b % <span class="number">16</span></span><br><span class="line">	&#125;</span><br><span class="line">	nibbles[l<span class="number">-1</span>] = <span class="number">16</span></span><br><span class="line">	<span class="keyword">return</span> nibbles</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例如：字符串 “romane” 的 bytes 是 <code>[114 111 109 97 110 101]</code>，在 HEX 编码时将其依次处理：</p>
<table>
<thead>
<tr>
<th align="left">i</th>
<th align="left">key[i]</th>
<th align="left">key[i]二进制</th>
<th align="left">nibbles[i*2]=高四位</th>
<th align="left">nibbles[i*2+1]=低四位</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">114</td>
<td align="left">011100102</td>
<td align="left">01112= 7</td>
<td align="left">00102= 2</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">111</td>
<td align="left">011011112</td>
<td align="left">01102=6</td>
<td align="left">11112=15</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">109</td>
<td align="left">011011012</td>
<td align="left">01102=6</td>
<td align="left">11012=13</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">97</td>
<td align="left">011000012</td>
<td align="left">01102=6</td>
<td align="left">00012=1</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">110</td>
<td align="left">011011102</td>
<td align="left">01102=6</td>
<td align="left">11102=14</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">101</td>
<td align="left">011001012</td>
<td align="left">01102=6</td>
<td align="left">01012=5</td>
</tr>
</tbody></table>
<h6 id="HP-Hex-Prefix-编码"><a href="#HP-Hex-Prefix-编码" class="headerlink" title="HP(Hex-Prefix) 编码"></a>HP(Hex-Prefix) 编码</h6><p>输入 key 结尾为 0x10，则去掉这个终止符。</p>
<p>key 之前补一个二进制flag四元组(Nibble)， 这个四元组第 0 位区分奇偶信息，第 1 位区分节点类型。</p>
<p>如果输入 key 的长度是偶数，则再添加一个四元组 0x0 在 flag 四元组后。</p>
<p>将原来的 key 内容压缩，将分离的两个 hex(Nibble) 以高四位低四位进行合并成一个byte。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81/" data-id="ckqma5ns100110wu7bdgs4avk" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-以太坊交易池（2）" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%B1%A0%EF%BC%882%EF%BC%89/">以太坊交易池代码分析 part2(共2部分)</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%B1%A0%EF%BC%882%EF%BC%89/" class="article-date"><time datetime="2021-07-02T10:37:40.000Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h3 id="以太坊交易池构建"><a href="#以太坊交易池构建" class="headerlink" title="以太坊交易池构建"></a>以太坊交易池构建</h3><h4 id="初始化都做了哪些事情？"><a href="#初始化都做了哪些事情？" class="headerlink" title="初始化都做了哪些事情？"></a>初始化都做了哪些事情？</h4><!--more-->

<h6 id="1-基础设置和通道创建"><a href="#1-基础设置和通道创建" class="headerlink" title="1.基础设置和通道创建"></a>1.基础设置和通道创建</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pool := &amp;TxPool&#123;</span><br><span class="line"><span class="comment">//基础设置 config，signer签名器，链配置等</span></span><br><span class="line">	config:          config,</span><br><span class="line">	chainconfig:     chainconfig,</span><br><span class="line">	chain:           chain,</span><br><span class="line">	signer:          types.NewEIP155Signer(chainconfig.ChainID),</span><br><span class="line"><span class="comment">//创建pending queue 和all交易列表	</span></span><br><span class="line">	pending:         <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]*txList),</span><br><span class="line">	queue:           <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]*txList),</span><br><span class="line">	beats:           <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]time.Time),</span><br><span class="line">	all:             newTxLookup(),</span><br><span class="line"><span class="comment">//创建各种通道	</span></span><br><span class="line">	chainHeadCh:     <span class="built_in">make</span>(<span class="keyword">chan</span> ChainHeadEvent, chainHeadChanSize),</span><br><span class="line">	reqResetCh:      <span class="built_in">make</span>(<span class="keyword">chan</span> *txpoolResetRequest),</span><br><span class="line">	reqPromoteCh:    <span class="built_in">make</span>(<span class="keyword">chan</span> *accountSet),</span><br><span class="line">	queueTxEventCh:  <span class="built_in">make</span>(<span class="keyword">chan</span> *types.Transaction),</span><br><span class="line">	reorgDoneCh:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">	reorgShutdownCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line"><span class="comment">//gasPrice设置	</span></span><br><span class="line">	gasPrice:        <span class="built_in">new</span>(big.Int).SetUint64(config.PriceLimit),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-检查本地交易-将本地地址加载入交易池，按价格排序"><a href="#2-检查本地交易-将本地地址加载入交易池，按价格排序" class="headerlink" title="2.检查本地交易 将本地地址加载入交易池，按价格排序"></a>2.检查本地交易 将本地地址加载入交易池，按价格排序</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pool.locals = newAccountSet(pool.signer)</span><br><span class="line"><span class="keyword">for</span> _, addr := <span class="keyword">range</span> config.Locals &#123;</span><br><span class="line">	log.Info(<span class="string">&quot;Setting new local account&quot;</span>, <span class="string">&quot;address&quot;</span>, addr)</span><br><span class="line">	pool.locals.add(addr)</span><br><span class="line">&#125;</span><br><span class="line">pool.priced = newTxPricedList(pool.all)</span><br></pre></td></tr></table></figure>

<h6 id="3-进行一次重置操作"><a href="#3-进行一次重置操作" class="headerlink" title="3.进行一次重置操作"></a>3.进行一次重置操作</h6><p><code>pool.reset(nil, chain.CurrentBlock().Header())</code></p>
<h6 id="4-开启重置轮询"><a href="#4-开启重置轮询" class="headerlink" title="4.开启重置轮询"></a>4.开启重置轮询</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> pool.scheduleReorgLoop()</span><br></pre></td></tr></table></figure>

<h6 id="5-加载日志"><a href="#5-加载日志" class="headerlink" title="5.加载日志"></a>5.加载日志</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If local transactions and journaling is enabled, load from disk</span></span><br><span class="line"><span class="keyword">if</span> !config.NoLocals &amp;&amp; config.Journal != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">	pool.journal = newTxJournal(config.Journal)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := pool.journal.load(pool.AddLocals); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Failed to load transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := pool.journal.rotate(pool.local()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Warn(<span class="string">&quot;Failed to rotate transaction journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="6-从区块链订阅事件并启动主事件循环。"><a href="#6-从区块链订阅事件并启动主事件循环。" class="headerlink" title="6.从区块链订阅事件并启动主事件循环。"></a>6.从区块链订阅事件并启动主事件循环。</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pool.chainHeadSub = pool.chain.SubscribeChainHeadEvent(pool.chainHeadCh)</span><br><span class="line">pool.wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> pool.loop()</span><br></pre></td></tr></table></figure>

<h3 id="轮询事件"><a href="#轮询事件" class="headerlink" title="轮询事件"></a>轮询事件</h3><h5 id="主事件：不间断监听以下通道的事件并作出回应"><a href="#主事件：不间断监听以下通道的事件并作出回应" class="headerlink" title="主事件：不间断监听以下通道的事件并作出回应"></a>主事件：不间断监听以下通道的事件并作出回应</h5><p>pool.chainHeadCh</p>
<p>pool.chainHeadSub.Err()</p>
<p>report.C</p>
<p>evict.C</p>
<p>journal.C</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loop is the transaction pool&#x27;s main event loop, waiting for and reacting to</span></span><br><span class="line"><span class="comment">// outside blockchain events as well as for various reporting and transaction</span></span><br><span class="line"><span class="comment">// eviction events.循环是事务池的主事件循环，它等待和响应外部区块链事件以及各种报告和事务逐出事件。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">loop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> pool.wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		prevPending, prevQueued, prevStales <span class="keyword">int</span></span><br><span class="line">		<span class="comment">// Start the stats reporting and transaction eviction tickers</span></span><br><span class="line">		report  = time.NewTicker(statsReportInterval)</span><br><span class="line">		evict   = time.NewTicker(evictionInterval)</span><br><span class="line">		journal = time.NewTicker(pool.config.Rejournal)</span><br><span class="line">		<span class="comment">// Track the previous head headers for transaction reorgs</span></span><br><span class="line">		head = pool.chain.CurrentBlock()</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">defer</span> report.Stop()</span><br><span class="line">	<span class="keyword">defer</span> evict.Stop()</span><br><span class="line">	<span class="keyword">defer</span> journal.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// Handle ChainHeadEvent</span></span><br><span class="line">		<span class="keyword">case</span> ev := &lt;-pool.chainHeadCh:</span><br><span class="line">			<span class="keyword">if</span> ev.Block != <span class="literal">nil</span> &#123;</span><br><span class="line">				pool.requestReset(head.Header(), ev.Block.Header())</span><br><span class="line">				head = ev.Block</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// System shutdown.</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-pool.chainHeadSub.Err():</span><br><span class="line">			<span class="built_in">close</span>(pool.reorgShutdownCh)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Handle stats reporting ticks</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-report.C:</span><br><span class="line">			pool.mu.RLock()</span><br><span class="line">			pending, queued := pool.stats()</span><br><span class="line">			stales := pool.priced.stales</span><br><span class="line">			pool.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> pending != prevPending || queued != prevQueued || stales != prevStales &#123;</span><br><span class="line">				log.Debug(<span class="string">&quot;Transaction pool status report&quot;</span>, <span class="string">&quot;executable&quot;</span>, pending, <span class="string">&quot;queued&quot;</span>, queued, <span class="string">&quot;stales&quot;</span>, stales)</span><br><span class="line">				prevPending, prevQueued, prevStales = pending, queued, stales</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Handle inactive account transaction eviction</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-evict.C:</span><br><span class="line">			pool.mu.Lock()</span><br><span class="line">			<span class="keyword">for</span> addr := <span class="keyword">range</span> pool.queue &#123;</span><br><span class="line">				<span class="comment">// Skip local transactions from the eviction mechanism</span></span><br><span class="line">				<span class="keyword">if</span> pool.locals.contains(addr) &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Any non-locals old enough should be removed</span></span><br><span class="line">				<span class="keyword">if</span> time.Since(pool.beats[addr]) &gt; pool.config.Lifetime &#123;</span><br><span class="line">					<span class="keyword">for</span> _, tx := <span class="keyword">range</span> pool.queue[addr].Flatten() &#123;</span><br><span class="line">						pool.removeTx(tx.Hash(), <span class="literal">true</span>)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			pool.mu.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Handle local transaction journal rotation</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-journal.C:</span><br><span class="line">			<span class="keyword">if</span> pool.journal != <span class="literal">nil</span> &#123;</span><br><span class="line">				pool.mu.Lock()</span><br><span class="line">				<span class="keyword">if</span> err := pool.journal.rotate(pool.local()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					log.Warn(<span class="string">&quot;Failed to rotate local tx journal&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">				&#125;</span><br><span class="line">				pool.mu.Unlock()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="重置事件：scheduleReorgLoop调度reset和promoteExecutables的运行。上面的代码不应该直接调用这些方法，而是使用requestReset和requestPromoteExecutables请求它们运行。"><a href="#重置事件：scheduleReorgLoop调度reset和promoteExecutables的运行。上面的代码不应该直接调用这些方法，而是使用requestReset和requestPromoteExecutables请求它们运行。" class="headerlink" title="重置事件：scheduleReorgLoop调度reset和promoteExecutables的运行。上面的代码不应该直接调用这些方法，而是使用requestReset和requestPromoteExecutables请求它们运行。"></a>重置事件：scheduleReorgLoop调度reset和promoteExecutables的运行。上面的代码不应该直接调用这些方法，而是使用requestReset和requestPromoteExecutables请求它们运行。</h5><p>从以下通道接收信号，每次接受任意信号开始新的循环</p>
<p>pool.reqResetCh</p>
<p>pool.reqPromoteCh</p>
<p>pool.queueTxEventCh</p>
<p>curDone</p>
<p>pool.reorgShutdownCh</p>
<p>每次循环判断：</p>
<p>1.接收到了curDone</p>
<p>2.接受到了pool.reqResetCh信号</p>
<p>便执行reset重置操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scheduleReorgLoop schedules runs of reset and promoteExecutables. Code above should not</span></span><br><span class="line"><span class="comment">// call those methods directly, but request them being run using requestReset and</span></span><br><span class="line"><span class="comment">// requestPromoteExecutables instead.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pool *TxPool)</span> <span class="title">scheduleReorgLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> pool.wg.Done()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		curDone       <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// non-nil while runReorg is active</span></span><br><span class="line">		nextDone      = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		launchNextRun <span class="keyword">bool</span></span><br><span class="line">		reset         *txpoolResetRequest</span><br><span class="line">		dirtyAccounts *accountSet</span><br><span class="line">		queuedEvents  = <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]*txSortedMap)</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Launch next background reorg if needed</span></span><br><span class="line">		<span class="keyword">if</span> curDone == <span class="literal">nil</span> &amp;&amp; launchNextRun &#123;</span><br><span class="line">			<span class="comment">// Run the background reorg and announcements</span></span><br><span class="line">			<span class="keyword">go</span> pool.runReorg(nextDone, reset, dirtyAccounts, queuedEvents)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Prepare everything for the next round of reorg</span></span><br><span class="line">			curDone, nextDone = nextDone, <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			launchNextRun = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">			reset, dirtyAccounts = <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">			queuedEvents = <span class="built_in">make</span>(<span class="keyword">map</span>[common.Address]*txSortedMap)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> req := &lt;-pool.reqResetCh:</span><br><span class="line">			<span class="comment">// Reset request: update head if request is already pending.</span></span><br><span class="line">			<span class="keyword">if</span> reset == <span class="literal">nil</span> &#123;</span><br><span class="line">				reset = req</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				reset.newHead = req.newHead</span><br><span class="line">			&#125;</span><br><span class="line">			launchNextRun = <span class="literal">true</span></span><br><span class="line">			pool.reorgDoneCh &lt;- nextDone</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> req := &lt;-pool.reqPromoteCh:</span><br><span class="line">			<span class="comment">// Promote request: update address set if request is already pending.</span></span><br><span class="line">			<span class="keyword">if</span> dirtyAccounts == <span class="literal">nil</span> &#123;</span><br><span class="line">				dirtyAccounts = req</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dirtyAccounts.merge(req)</span><br><span class="line">			&#125;</span><br><span class="line">			launchNextRun = <span class="literal">true</span></span><br><span class="line">			pool.reorgDoneCh &lt;- nextDone</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> tx := &lt;-pool.queueTxEventCh:</span><br><span class="line">			<span class="comment">// Queue up the event, but don&#x27;t schedule a reorg. It&#x27;s up to the caller to</span></span><br><span class="line">			<span class="comment">// request one later if they want the events sent.</span></span><br><span class="line">			addr, _ := types.Sender(pool.signer, tx)</span><br><span class="line">			<span class="keyword">if</span> _, ok := queuedEvents[addr]; !ok &#123;</span><br><span class="line">				queuedEvents[addr] = newTxSortedMap()</span><br><span class="line">			&#125;</span><br><span class="line">			queuedEvents[addr].Put(tx)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-curDone:</span><br><span class="line">			curDone = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-pool.reorgShutdownCh:</span><br><span class="line">			<span class="comment">// Wait for current run to finish.</span></span><br><span class="line">			<span class="keyword">if</span> curDone != <span class="literal">nil</span> &#123;</span><br><span class="line">				&lt;-curDone</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(nextDone)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="交易池重置"><a href="#交易池重置" class="headerlink" title="交易池重置"></a>交易池重置</h3><p>reset函数的执行流程：</p>
<p><img src="./picture/12.png"></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%B1%A0%EF%BC%882%EF%BC%89/" data-id="ckqma5ns300140wu78j481fqv" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-以太坊账户" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7/">以太坊账户简单分析</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7/" class="article-date"><time datetime="2021-07-02T10:37:40.000Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>基于账户的模型：account-based ledger</p>
<p>避免双花攻击/双重攻击：nonce机制，指交易的次数</p>
<p>两种账户：</p>
<p>externally owned account : 外部账户</p>
<p>外部账户状态有：</p>
<p>balance</p>
<p>nonce</p>
<p>smart contract account : 合约账户</p>
<p>合约账户不能主动发起交易；但可以调用其他合约</p>
<p>合约账户状态还有：</p>
<p>code </p>
<p>storage  </p>
<h6 id="黄皮书中的说法："><a href="#黄皮书中的说法：" class="headerlink" title="黄皮书中的说法："></a>黄皮书中的说法：</h6><p>账户状态 <strong>σ</strong>[<em>a</em>] 包含以下四个字： </p>
<p><strong>nonce:</strong> 这个值等于由此账户地址发出的交易数量，或者由这个账户所创建的合约数量（当这个账户有关联代码时）。<strong>σ</strong>[<em>a</em>]<em>n</em> 即表示状态 <strong>σ</strong> 中的地址 <em>a</em> 的nonce 值。</p>
<p><strong>balance</strong>: <strong>σ</strong>[<em>a</em>]b，表示这个账户地址拥有多少 Wei（即账户余额，译者注）。</p>
<p><strong>storageRoot:</strong> 保存了账户的存储内容的 Merkle Patricia 树的根节点的 256 位哈希值，这个树中保存的是 256 位整数键值的 Keccak 256 位哈希值到256 位整数值的 RLP 编码的映射。这个哈希定义为 <strong>σ</strong>[<em>a</em>]<em>s</em>。</p>
<p><strong>codeHash</strong>: 这个账户的 EVM 代码哈希值——当这个地址接收到一个消息调用时，这些代码会被执行；它和其它字段不同，创建后不可更改。状态数据库中包含所有这样的代码片段哈希，以便后续使用。这个哈希可以定义为 <strong>σ</strong>[<em>a</em>]<em>c</em>，然后我们用 <strong>b</strong> 来表示代码，则有 KEC(<strong>b</strong>) = <strong>σ</strong>[<em>a</em>]<em>c</em>。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7/" data-id="ckqma5ns400150wu7gwaxdsnb" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-几种通信简介" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E5%87%A0%E7%A7%8D%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B/">以太坊的RPC涉及的通信方式简介</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E5%87%A0%E7%A7%8D%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B/" class="article-date"><time datetime="2021-07-02T10:37:40.000Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<h3 id="线程之间的通信inproc"><a href="#线程之间的通信inproc" class="headerlink" title="线程之间的通信inproc"></a>线程之间的通信inproc</h3><p><strong>一、为什么要线程通信？</strong></p>
<p>1.多个线程并发执行时, 在默认情况下CPU是<strong>随机切换线程</strong>的，当我们需要多个线程来<strong>共同完成</strong>一件任务，</p>
<p>　　 并且我们希望他们<strong>有规律</strong>的执行, 那么多线程之间需要一些<strong>协调通信</strong>，以此来帮我们达到<strong>多线程共同操作一份数据</strong>。</p>
<p>2.当然如果我们没有使用线程通信来使用多线程共同操作同一份数据的话，虽然可以实现，</p>
<p>　　但是在很大程度会造成多线程之间对同一共享变量的争夺，那样的话势必为造成很多错误和损失！</p>
<p>3.所以，我们才引出了线程之间的通信，<code>多线程之间的通信能够避免对同一共享变量的争夺。</code> </p>
<p><strong>二、什么是线程通信？</strong> </p>
<p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。</p>
<p>就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺</p>
<p>于是我们引出了等待唤醒机制：（wait()、notify()）</p>
<p>就是在一个线程进行了规定操作后，就进入等待状态（wait）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify）；</p>
<h6 id="（1）WAIT-方法："><a href="#（1）WAIT-方法：" class="headerlink" title="（1）WAIT()方法："></a>（1）WAIT()方法：</h6><p>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，<strong>导致当前线程等待</strong>。</p>
<p>线程调用wait()方法，<strong>释放</strong>它对锁的拥有权，然后<strong>等待另外的线程来通知它</strong>（通知的方式是notify()或者notifyAll()方法），这样它才能重新获得锁的拥有权和恢复执行。</p>
<p>要确保调用wait()方法的时候<strong>拥有锁</strong>，即，wait()方法的调用必须放在<strong>synchronized</strong>方法或<strong>synchronized</strong>块中。</p>
<h6 id="（2）notif-方法："><a href="#（2）notif-方法：" class="headerlink" title="（2）notif()方法："></a><strong>（2）notif()方法：</strong></h6><p>notify()方法会唤醒一个等待当前对象的锁的线程。唤醒在此对象监视器上等待的单个线程。</p>
<h6 id="（3）notifAll-方法："><a href="#（3）notifAll-方法：" class="headerlink" title="（3）notifAll()方法："></a>（3）notifAll()方法：</h6><p>notifyAll（）方法会唤醒在此对象监视器上等待的所有线程。<br> 如果多个线程在等待，它们中的一个将会选择被唤醒。这种选择是随意的，和具体实现有关。（线程等待一个对象的锁是由于调用了wait方法中的一个）</p>
<p>notify()方法应该是被拥有对象的锁的线程所调用。</p>
<p>一般而言,在一个应用程序中（即进程），一个线程往往不是孤立存在的，常常需要和其它线程通信，以执行特定的任务。如主线程和次线程，次线程与次线程，工作线程和用户界面线程等。这样,线程与线程间必定有一个信息传递的渠道。这种线程间的通信不但是难以避免的，而且在多线程编程中也是复杂和频繁的。</p>
<h3 id="进程间通信ipc"><a href="#进程间通信ipc" class="headerlink" title="进程间通信ipc"></a><strong>进程间通信</strong>ipc</h3><p>又称IPC(Inter-Process Communication),指多个进程之间相互通信，交换信息的方法。根据进程通信时信息量大小的不同,可以将进程通信划分为两大类型:<br> 1、低级通信,控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递)<br> 2、高级通信,大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等).</p>
<ul>
<li><a href="">管道( pipe )</a>：管道是一种<a href="">半双工的通信方式</a>，数据只能单向流动，而且<a href="">只能在具有亲缘关系的进程间使用</a>。进程的亲缘关系通常是指父子进程关系。</li>
<li><a href="">有名管道 (named pipe) </a>： 有名管道也是半双工的通信方式，但是它<a href="">允许无亲缘关系进程间的通信</a>。</li>
<li><a href="">信号量( semophore )</a> ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。<a href="">不是用于交换大批数据,而用于多线程之间的同步.常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源</a>。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><a href="">消息队列( message queue ) </a>： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列<a href="">克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点</a>。</li>
<li><a href="">信号 ( signal ) </a>： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li>[共享内存( shared memory )] ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是<a href="">最快的 IPC 方式</a>，它是针对其他进程间通信方式运行效率低而专门设计的。<a href="">它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信</a>。</li>
<li><a href="">套接字( socket ) </a>： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li>
</ul>
<h3 id="HTTP（）"><a href="#HTTP（）" class="headerlink" title="HTTP（）"></a>HTTP（）</h3><h3 id="WebSocket-ws"><a href="#WebSocket-ws" class="headerlink" title="WebSocket(ws)"></a>WebSocket(ws)</h3><p><strong>WebSocket</strong>是一种在单个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/TCP">TCP</a>连接上进行<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5">全双工</a>通信的协议。WebSocket通信协议于2011年被<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/IETF">IETF</a>定为标准RFC 6455，并由RFC7936补充规范。WebSocket <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/API">API</a>也被<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/W3C">W3C</a>定为标准。</p>
<p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<p>优点：</p>
<ul>
<li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82">字节</a>（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8E%A9%E7%A0%81">掩码</a>。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</li>
<li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li>
<li>保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li>
<li>更好的二进制支持。Websocket定义了<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制</a>帧，相对HTTP，可以更轻松地处理二进制内容。</li>
<li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%8B%E7%BC%A9">压缩</a>等。</li>
<li>更好的压缩效果。相对于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HTTP%E5%8E%8B%E7%BC%A9">HTTP压缩</a>，Websocket在适当的扩展支持下，可以沿用之前内容的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%8A%E4%B8%8B%E6%96%87">上下文</a>，在传递类似的数据时，可以显著地提高压缩率。</li>
</ul>
<p>WebSocket 是独立的、创建在 TCP 上的协议。</p>
<p>Websocket 通过<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HTTP">HTTP</a>/1.1 协议的101状态码进行握手。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E5%87%A0%E7%A7%8D%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B/" data-id="ckqma5ns500170wu7caos9o14" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-前端入门基础" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/">前端DOM基础</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/" class="article-date"><time datetime="2021-07-02T10:37:40.000Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>浏览器和服务器通过几次握手后，得到服务器传回给浏览器的代码，浏览器接收到代码后进行解析，之后进行三大步骤：DOM构造、布局以及绘制页面，最终变为人人可见的网页</p>
        
          <p class="article-more-link">
            <a class="btn btn-primary" href="/2021/07/02/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/#more">Read More</a>
          </p>
        
      
    </div>

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/" data-id="ckqma5ns500180wu7bcrecrty" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-区块中的交易和回执代码分析" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E5%8C%BA%E5%9D%97%E4%B8%AD%E7%9A%84%E4%BA%A4%E6%98%93%E5%92%8C%E5%9B%9E%E6%89%A7%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">以太坊交易结构代码</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E5%8C%BA%E5%9D%97%E4%B8%AD%E7%9A%84%E4%BA%A4%E6%98%93%E5%92%8C%E5%9B%9E%E6%89%A7%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date"><time datetime="2021-07-02T10:37:40.000Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>core/types中封装了一系列的类型和对这些类型应用的基本方法，本篇分几个模块探索有关的数据结构和基本的方法，并对重要的方法进行解析。</p>
<h6 id="1-交易"><a href="#1-交易" class="headerlink" title="1.交易"></a>1.交易</h6><p><strong>定义（黄皮书）</strong>：</p>
<p>交易**.** 交易（符号，<em>T</em>）是个单一的加密学签名的指令，通常由以太坊系统之外的操作者创建。我们假设外部的操作者是人，软件工具则用于构建和散播 1。这里的交易有两种类型：一种表现为消息调用，另一种则通过代码创建新的账户（称为“合约创建”）。这两种类型的交易都有一些共同的字段：</p>
<p><strong>nonce:</strong> 由交易发送者发出的的交易的数量，由 <em>T</em>n 表示。</p>
<p><strong>gasPrice:</strong> 为执行这个交易所需要进行的计算步骤消耗的每单位 <em>gas</em> 的价格，以 Wei 为单位，由 <em>T</em>p 表示。</p>
<p><strong>gasLimit:</strong> 用于执行这个交易的最大 gas 数量。这个值须在交易开始前设置，且设定后不能再增加，由<em>T</em>g 表示。</p>
<p><strong>to:</strong> 160 位的消息调用接收者地址；对与合约创建交易，用 ∅ 表示 B0 的唯一成员。此字段由 <em>T</em>t 表示<strong>value:</strong> 转移到接收者账户的 Wei 的数量；对于合约创建，则代表给新建合约地址的初始捐款。由 <em>T</em>v表示。</p>
<p><strong>v, r, s:</strong> 与交易签名相符的若干数值，用于确定交易的发送者，由 <em>T</em>w，<em>T</em>r 和 <em>T</em>s 表示。详见附录 F。此外，合约创建还包含以下字段:</p>
<p><strong>init:</strong> 一个不限制大小的字节数组，用来指定账户初始化程序的 EVM 代码，由 <em>T</em><strong>i</strong> 表示。<strong>init</strong>是 EVM 代码片段；它将返回 <strong>body</strong>，这是这个账户每次接收到消息调用时会执行的代码（通过一个交易或者代码的内部执行）。<strong>init</strong> 代码仅会在合约创建时被执行一次，然后就会被丢弃。与此相对，一个消息调用交易包括:<strong>data:</strong> 一个不限制大小的字节数组，用来指定消息调用的输入数据，由 <em>T</em><strong>d</strong> 表示。</p>
<p><strong>与交易有关的代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交易的定义：包含了txdata和交易哈希，size,from，我猜想之所以要和txdata区分开是为取哈希的时候，hash的定义不包含在主交易结构里。</span></span><br><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">	data txdata</span><br><span class="line">	<span class="comment">// caches</span></span><br><span class="line">	hash atomic.Value</span><br><span class="line">	size atomic.Value</span><br><span class="line">	from atomic.Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//txdata是交易的主要内容，和黄皮书上的定义基本吻合</span></span><br><span class="line"><span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">	AccountNonce <span class="keyword">uint64</span>          <span class="string">`json:&quot;nonce&quot;    gencodec:&quot;required&quot;`</span></span><br><span class="line">	Price        *big.Int        <span class="string">`json:&quot;gasPrice&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">	GasLimit     <span class="keyword">uint64</span>          <span class="string">`json:&quot;gas&quot;      gencodec:&quot;required&quot;`</span></span><br><span class="line">	Recipient    *common.Address <span class="string">`json:&quot;to&quot;       rlp:&quot;nil&quot;`</span> <span class="comment">// nil means contract creation</span></span><br><span class="line">	Amount       *big.Int        <span class="string">`json:&quot;value&quot;    gencodec:&quot;required&quot;`</span></span><br><span class="line">	Payload      []<span class="keyword">byte</span>          <span class="string">`json:&quot;input&quot;    gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Signature values</span></span><br><span class="line">	V *big.Int <span class="string">`json:&quot;v&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">	R *big.Int <span class="string">`json:&quot;r&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">	S *big.Int <span class="string">`json:&quot;s&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// This is only used when marshaling to JSON.</span></span><br><span class="line">	Hash *common.Hash <span class="string">`json:&quot;hash&quot; rlp:&quot;-&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//json解析</span></span><br><span class="line"><span class="keyword">type</span> txdataMarshaling <span class="keyword">struct</span> &#123;</span><br><span class="line">	AccountNonce hexutil.Uint64</span><br><span class="line">	Price        *hexutil.Big</span><br><span class="line">	GasLimit     hexutil.Uint64</span><br><span class="line">	Amount       *hexutil.Big</span><br><span class="line">	Payload      hexutil.Bytes</span><br><span class="line">	V            *hexutil.Big</span><br><span class="line">	R            *hexutil.Big</span><br><span class="line">	S            *hexutil.Big</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建交易：封装data，先不管hash,size,from的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTransaction</span><span class="params">(nonce <span class="keyword">uint64</span>, to common.Address, amount *big.Int, gasLimit <span class="keyword">uint64</span>, gasPrice *big.Int, data []<span class="keyword">byte</span>)</span> *<span class="title">Transaction</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> newTransaction(nonce, &amp;to, amount, gasLimit, gasPrice, data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTransaction</span><span class="params">(nonce <span class="keyword">uint64</span>, to *common.Address, amount *big.Int, gasLimit <span class="keyword">uint64</span>, gasPrice *big.Int, data []<span class="keyword">byte</span>)</span> *<span class="title">Transaction</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(data) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		data = common.CopyBytes(data)</span><br><span class="line">	&#125;</span><br><span class="line">	d := txdata&#123;</span><br><span class="line">		AccountNonce: nonce,</span><br><span class="line">		Recipient:    to,</span><br><span class="line">		Payload:      data,</span><br><span class="line">		Amount:       <span class="built_in">new</span>(big.Int),</span><br><span class="line">		GasLimit:     gasLimit,</span><br><span class="line">		Price:        <span class="built_in">new</span>(big.Int),</span><br><span class="line">		V:            <span class="built_in">new</span>(big.Int),</span><br><span class="line">		R:            <span class="built_in">new</span>(big.Int),</span><br><span class="line">		S:            <span class="built_in">new</span>(big.Int),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> amount != <span class="literal">nil</span> &#123;</span><br><span class="line">		d.Amount.Set(amount)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gasPrice != <span class="literal">nil</span> &#123;</span><br><span class="line">		d.Price.Set(gasPrice)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;Transaction&#123;data: d&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交易编码和解码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">EncodeRLP</span><span class="params">(w io.Writer)</span> <span class="title">error</span></span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">DecodeRLP</span><span class="params">(s *rlp.Stream)</span> <span class="title">error</span></span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//解析为/解析json格式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">UnmarshalJSON</span><span class="params">(input []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取交易信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">Data</span><span class="params">()</span> []<span class="title">byte</span></span>       &#123; <span class="keyword">return</span> common.CopyBytes(tx.data.Payload) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">Gas</span><span class="params">()</span> <span class="title">uint64</span></span>        &#123; <span class="keyword">return</span> tx.data.GasLimit &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">GasPrice</span><span class="params">()</span> *<span class="title">big</span>.<span class="title">Int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">new</span>(big.Int).Set(tx.data.Price) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">Value</span><span class="params">()</span> *<span class="title">big</span>.<span class="title">Int</span></span>    &#123; <span class="keyword">return</span> <span class="built_in">new</span>(big.Int).Set(tx.data.Amount) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">Nonce</span><span class="params">()</span> <span class="title">uint64</span></span>      &#123; <span class="keyword">return</span> tx.data.AccountNonce &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Transaction)</span> <span class="title">CheckNonce</span><span class="params">()</span> <span class="title">bool</span></span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-收据"><a href="#2-收据" class="headerlink" title="2.收据"></a>2.收据</h6><p><strong>定义（黄皮书）</strong>：</p>
<p>为了能使交易信息对零知识证明、索引和搜索都是有用的，我们将每个交易执行过程中的一些特定信息编码为交易收据。我们以 <em>B</em><strong>R</strong>[<em>i</em>] 表示第 <em>i</em> 个交易的收据，并把收据信息保存在一个以索引为键的树（index-keyedtrie）中，树的根节点用 <em>H</em>e 保存到区块头中。交易收据 <em>R</em> 是一个包含四个条目的元组：包含交易收据的区块中当交易发生后的累积 gas 使用量 <em>R</em>u；交易过程中创建的日志集合 <em>R</em>l；由这些日志信息所构成的 Bloom 过滤器 <em>R</em>b 和交易的状态代码 <em>R</em>z。</p>
<p><strong>收据定义代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Receipt <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Consensus fields: These fields are defined by the Yellow Paper</span></span><br><span class="line">	PostState         []<span class="keyword">byte</span> <span class="string">`json:&quot;root&quot;`</span></span><br><span class="line">	Status            <span class="keyword">uint64</span> <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">	CumulativeGasUsed <span class="keyword">uint64</span> <span class="string">`json:&quot;cumulativeGasUsed&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">	Bloom             Bloom  <span class="string">`json:&quot;logsBloom&quot;         gencodec:&quot;required&quot;`</span></span><br><span class="line">	Logs              []*Log <span class="string">`json:&quot;logs&quot;              gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Implementation fields: These fields are added by geth when processing a transaction.</span></span><br><span class="line">	<span class="comment">// They are stored in the chain database.</span></span><br><span class="line">	TxHash          common.Hash    <span class="string">`json:&quot;transactionHash&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">	ContractAddress common.Address <span class="string">`json:&quot;contractAddress&quot;`</span></span><br><span class="line">	GasUsed         <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasUsed&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Inclusion information: These fields provide information about the inclusion of the</span></span><br><span class="line">	<span class="comment">// transaction corresponding to this receipt.</span></span><br><span class="line">	BlockHash        common.Hash <span class="string">`json:&quot;blockHash,omitempty&quot;`</span></span><br><span class="line">	BlockNumber      *big.Int    <span class="string">`json:&quot;blockNumber,omitempty&quot;`</span></span><br><span class="line">	TransactionIndex <span class="keyword">uint</span>        <span class="string">`json:&quot;transactionIndex&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h6><p><strong>定义（黄皮书）</strong>：区块**.** 在以太坊中，区块是由以下部分组成的：一些相关信息片段组成的集合（称为 block <em>header</em>，即区块头）；组成区块的交易 <strong>T</strong> 和 其它一些区块头 <strong>U</strong> （这是一些父区块与当前区块的爷爷辈区块相同的区块，这样的区块称为<em>ommers</em>）。</p>
<p><strong>区块代码定义</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">	ParentHash  common.Hash    <span class="string">`json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">	UncleHash   common.Hash    <span class="string">`json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">	Coinbase    common.Address <span class="string">`json:&quot;miner&quot;            gencodec:&quot;required&quot;`</span></span><br><span class="line">	Root        common.Hash    <span class="string">`json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">	TxHash      common.Hash    <span class="string">`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">	ReceiptHash common.Hash    <span class="string">`json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</span></span><br><span class="line">	Bloom       Bloom          <span class="string">`json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">	Difficulty  *big.Int       <span class="string">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">	Number      *big.Int       <span class="string">`json:&quot;number&quot;           gencodec:&quot;required&quot;`</span></span><br><span class="line">	GasLimit    <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</span></span><br><span class="line">	GasUsed     <span class="keyword">uint64</span>         <span class="string">`json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</span></span><br><span class="line">	Time        <span class="keyword">uint64</span>         <span class="string">`json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">	Extra       []<span class="keyword">byte</span>         <span class="string">`json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">	MixDigest   common.Hash    <span class="string">`json:&quot;mixHash&quot;`</span></span><br><span class="line">	Nonce       BlockNonce     <span class="string">`json:&quot;nonce&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">	header       *Header</span><br><span class="line">	uncles       []*Header</span><br><span class="line">	transactions Transactions</span><br><span class="line"></span><br><span class="line">	<span class="comment">// caches</span></span><br><span class="line">	hash atomic.Value</span><br><span class="line">	size atomic.Value</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Td is used by package core to store the total difficulty</span></span><br><span class="line">	<span class="comment">// of the chain up to and including the block.</span></span><br><span class="line">	td *big.Int</span><br><span class="line"></span><br><span class="line">	<span class="comment">// These fields are used by package eth to track</span></span><br><span class="line">	<span class="comment">// inter-peer block relay.</span></span><br><span class="line">	ReceivedAt   time.Time</span><br><span class="line">	ReceivedFrom <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Body <span class="keyword">struct</span> &#123;</span><br><span class="line">	Transactions []*Transaction</span><br><span class="line">	Uncles       []*Header</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新区块的创建：这个新区块的创建过程比较重要，参数有四个：header;txs;uncles;receipts，返回一个新的区块，状态树的根哈希root不在这里声明。下面在代码中加入一些注释和理解。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBlock</span><span class="params">(header *Header, txs []*Transaction, uncles []*Header, receipts []*Receipt)</span> *<span class="title">Block</span></span> &#123;</span><br><span class="line">	b := &amp;Block&#123;header: CopyHeader(header), td: <span class="built_in">new</span>(big.Int)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> panic if len(txs) != len(receipts)先是检查交易的数量和收据的数量是否完整</span></span><br><span class="line">    <span class="comment">//检查如果交易量是0，则交易树的跟哈希是空，若不是零，调用DeriveSha来对这些交易构建tire树并取跟哈希，最后还把这些交易复制到区块中。</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(txs) == <span class="number">0</span> &#123;</span><br><span class="line">		b.header.TxHash = EmptyRootHash</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		b.header.TxHash = DeriveSha(Transactions(txs))</span><br><span class="line">		b.transactions = <span class="built_in">make</span>(Transactions, <span class="built_in">len</span>(txs))</span><br><span class="line">		<span class="built_in">copy</span>(b.transactions, txs)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//和构建交易树类似，构建收据树</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(receipts) == <span class="number">0</span> &#123;</span><br><span class="line">		b.header.ReceiptHash = EmptyRootHash</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		b.header.ReceiptHash = DeriveSha(Receipts(receipts))</span><br><span class="line">		b.header.Bloom = CreateBloom(receipts)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将叔块加入到区块当中</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(uncles) == <span class="number">0</span> &#123;</span><br><span class="line">		b.header.UncleHash = EmptyUncleHash</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		b.header.UncleHash = CalcUncleHash(uncles)</span><br><span class="line">		b.uncles = <span class="built_in">make</span>([]*Header, <span class="built_in">len</span>(uncles))</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> uncles &#123;</span><br><span class="line">			b.uncles[i] = CopyHeader(uncles[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>涉及到的DeriveSha函数，用于构建MPT树。</p>
<p>在core/types/derive_sha.go中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DerivableList <span class="keyword">interface</span> &#123;</span><br><span class="line">	Len() <span class="keyword">int</span></span><br><span class="line">	GetRlp(i <span class="keyword">int</span>) []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeriveSha</span><span class="params">(list DerivableList)</span> <span class="title">common</span>.<span class="title">Hash</span></span> &#123;</span><br><span class="line">	keybuf := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	trie := <span class="built_in">new</span>(trie.Trie)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; list.Len(); i++ &#123;</span><br><span class="line">		keybuf.Reset()</span><br><span class="line">		rlp.Encode(keybuf, <span class="keyword">uint</span>(i))</span><br><span class="line">		trie.Update(keybuf.Bytes(), list.GetRlp(i))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> trie.Hash()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其流程是：先新建trie树，之后将输入的list遍历，将每个元素的（RLP编码-内容）键值对调用trie.Update函数更新trie树，直到遍历完。之后返回trie的根哈希。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E5%8C%BA%E5%9D%97%E4%B8%AD%E7%9A%84%E4%BA%A4%E6%98%93%E5%92%8C%E5%9B%9E%E6%89%A7%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ckqma5ns7001a0wu70oa8h7vl" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-问题" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/%E9%97%AE%E9%A2%98/">以太坊源码阅读过程中的问题&lt;一&gt;</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/%E9%97%AE%E9%A2%98/" class="article-date"><time datetime="2021-07-02T10:37:40.000Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>list.Filter函数把哪些不可以升级的交易过滤了；</p>
<p>哪些节点维护交易池；</p>
<p>交易池的定义抽象地起到什么作用，节点维护交易池的动机；</p>
<p>几个维度交易的排序，除了price，是否还有time时间戳的先后；</p>
<p>新块来了之后如果出现分叉，如何操作交易池的现在的区块链接口和交易池的升降级；</p>
<p>reset操作再详细看些;</p>
<p>虚拟机存储与stateDB状态树等等有关系，增加讨论</p>
<hr>
<p>一些反思：跟看的这些数据结构有关的走的流程；</p>
<p>一些编码细节；</p>
<p>工程师角度的流程分析，试着用自己的语言描述代码构成；</p>
<p>读代码的思路：宏观和具体，理论和解释；</p>
<p>在代码中写好注释</p>
<hr>
<p>交易树的构建细节；</p>
<p>交易池的构建；</p>
<p>涉及到交易、收据、区块的流程分析；</p>
<p>rlp、hex、hp编码；</p>
<p>收据树具体，和布隆过滤器具体，智能合约的event是不是就写入日志的；</p>
<p>secure trie的作用；</p>
<p>回执不在区块中在哪里；</p>
<p>statedb具体为何用pending\dirty状态；</p>
<hr>
<p>宏观过程：确定一个topic/address如何确定在哪个区块的哪个收据的哪个log里，整个过程是怎样的<br>区块链到底是什么不可篡改<br>别的节点怎么验证的<br>和智能合约相关的</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/%E9%97%AE%E9%A2%98/" data-id="ckqma5nsf001c0wu74y83380v" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-BlockChain-Papers-in-Top-Security-Conferences" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/02/BlockChain-Papers-in-Top-Security-Conferences/">BlockChain Papers in Top Security Conferences</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2021/07/02/BlockChain-Papers-in-Top-Security-Conferences/" class="article-date"><time datetime="2021-07-02T10:37:40.000Z" itemprop="datePublished">2021-07-02</time></a>
</div>

    
    

  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>Summarize blockchian papers in IEEE S&amp;P 2021, NDSS 2021, USENIX Security 2021 and CCS 2020</p>
        
          <p class="article-more-link">
            <a class="btn btn-primary" href="/2021/07/02/BlockChain-Papers-in-Top-Security-Conferences/#more">Read More</a>
          </p>
        
      
    </div>

    

    <footer class="article-footer">
      <a data-url="https://yezzi.tech/2021/07/02/BlockChain-Papers-in-Top-Security-Conferences/" data-id="ckqma5nsg001d0wu789inh994" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/paper-notes/" rel="tag">paper notes</a></li></ul>


    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li class="disabled"><span class="page-prev"><i class="fa fa-chevron-left"></i> Prev</a></li><li class="active"><span class="page-number">1</span></li><li><a class="page-number" href="/page/2/">2</a></li><li><a class="page-number" href="/page/3/">3</a></li><li><a class="page-number" href="/page/4/">4</a></li><li><a class="page-next" rel="next" href="/page/2/">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p> Nice papers collected in the field of <em>AI</em>, <em>Apllied Cryptography</em> and <em>Blockchain</em>, records of some computer technologies, and personal thoughts.  If you are inteseted in my field, feel free to contact me. (Wechat: mzliu_xdu) </p>

</div>


  


  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list" itemprop="keywords"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Bitcoin/" rel="tag">Bitcoin</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/go/" rel="tag">go</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/golang/" rel="tag">golang</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/hyperledger-fabric/" rel="tag">hyperledger fabric</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/java/" rel="tag">java</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/paper-notes/" rel="tag">paper notes</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag">以太坊</a><span class="sidebar-module-list-count">18</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tag Cloud</h4>
    <p class="tagcloud">
      <a href="/tags/Bitcoin/" style="font-size: 10px;">Bitcoin</a> <a href="/tags/go/" style="font-size: 10px;">go</a> <a href="/tags/golang/" style="font-size: 17.5px;">golang</a> <a href="/tags/hyperledger-fabric/" style="font-size: 12.5px;">hyperledger fabric</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/paper-notes/" style="font-size: 15px;">paper notes</a> <a href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" style="font-size: 20px;">以太坊</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a>
    </p>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2021/07/">July 2021</a><span class="sidebar-module-list-count">13</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/02/">February 2020</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">9</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/08/">August 2019</a><span class="sidebar-module-list-count">2</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2021/07/02/DoERS_note/">BlockChain Papers in Top Security Conferences</a>
        </li>
      
        <li>
          <a href="/2021/07/02/%E4%BA%A4%E6%98%93%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E7%AD%BE/">以太坊签名相关代码</a>
        </li>
      
        <li>
          <a href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81/">以太坊中的各种编码</a>
        </li>
      
        <li>
          <a href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%B1%A0%EF%BC%882%EF%BC%89/">以太坊交易池代码分析 part2(共2部分)</a>
        </li>
      
        <li>
          <a href="/2021/07/02/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7/">以太坊账户简单分析</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2021 Mingzhe Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>




<script src="/js/script.js"></script>


</body>
</html>
